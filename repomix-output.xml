This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

- Pay special attention to the Repository Instruction. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.lock, **/dist/**, **/build/**, **/coverage/**, **/*.log, **/*.svg, **/assets/**, **/*.test.ts, **/public/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.agents/
  skills/
    fixing-motion-performance/
      SKILL.md
    git-commit/
      SKILL.md
    typescript-expert/
      references/
        tsconfig-strict.json
        typescript-cheatsheet.md
        utility-types.ts
      scripts/
        ts_diagnostic.py
      SKILL.md
    vercel-react-best-practices/
      rules/
        advanced-event-handler-refs.md
        advanced-init-once.md
        advanced-use-latest.md
        async-api-routes.md
        async-defer-await.md
        async-dependencies.md
        async-parallel.md
        async-suspense-boundaries.md
        bundle-barrel-imports.md
        bundle-conditional.md
        bundle-defer-third-party.md
        bundle-dynamic-imports.md
        bundle-preload.md
        client-event-listeners.md
        client-localstorage-schema.md
        client-passive-event-listeners.md
        client-swr-dedup.md
        js-batch-dom-css.md
        js-cache-function-results.md
        js-cache-property-access.md
        js-cache-storage.md
        js-combine-iterations.md
        js-early-exit.md
        js-hoist-regexp.md
        js-index-maps.md
        js-length-check-first.md
        js-min-max-loop.md
        js-set-map-lookups.md
        js-tosorted-immutable.md
        rendering-activity.md
        rendering-animate-svg-wrapper.md
        rendering-conditional-render.md
        rendering-content-visibility.md
        rendering-hoist-jsx.md
        rendering-hydration-no-flicker.md
        rendering-hydration-suppress-warning.md
        rendering-svg-precision.md
        rendering-usetransition-loading.md
        rerender-defer-reads.md
        rerender-dependencies.md
        rerender-derived-state-no-effect.md
        rerender-derived-state.md
        rerender-functional-setstate.md
        rerender-lazy-state-init.md
        rerender-memo-with-default-value.md
        rerender-memo.md
        rerender-move-effect-to-event.md
        rerender-simple-expression-in-memo.md
        rerender-transitions.md
        rerender-use-ref-transient-values.md
        server-after-nonblocking.md
        server-auth-actions.md
        server-cache-lru.md
        server-cache-react.md
        server-dedup-props.md
        server-parallel-fetching.md
        server-serialization.md
      AGENTS.md
      SKILL.md
    web-performance-optimization/
      SKILL.md
.gemini/
  commands/
    speckit.analyze.toml
    speckit.checklist.toml
    speckit.clarify.toml
    speckit.constitution.toml
    speckit.implement.toml
    speckit.plan.toml
    speckit.specify.toml
    speckit.tasks.toml
    speckit.taskstoissues.toml
.specify/
  memory/
    constitution.md
  scripts/
    bash/
      check-prerequisites.sh
      common.sh
      create-new-feature.sh
      setup-plan.sh
      update-agent-context.sh
  templates/
    agent-file-template.md
    checklist-template.md
    plan-template.md
    spec-template.md
    tasks-template.md
src/
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
index.html
package.json
progress.md
repomix-instruction.md
repomix.config.json
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".agents/skills/fixing-motion-performance/SKILL.md">
  1: ---
  2: name: fixing-motion-performance
  3: description: Fix animation performance issues.
  4: ---
  5: 
  6: # fixing-motion-performance
  7: 
  8: Fix animation performance issues.
  9: 
 10: ## how to use
 11: 
 12: - `/fixing-motion-performance`
 13:   Apply these constraints to any UI animation work in this conversation.
 14: 
 15: - `/fixing-motion-performance <file>`
 16:   Review the file against all rules below and report:
 17:   - violations (quote the exact line or snippet)
 18:   - why it matters (one short sentence)
 19:   - a concrete fix (code-level suggestion)
 20: 
 21: Do not migrate animation libraries unless explicitly requested. Apply rules within the existing stack.
 22: 
 23: ## when to apply
 24: 
 25: Reference these guidelines when:
 26: - adding or changing UI animations (CSS, WAAPI, Motion, rAF, GSAP)
 27: - refactoring janky interactions or transitions
 28: - implementing scroll-linked motion or reveal-on-scroll
 29: - animating layout, filters, masks, gradients, or CSS variables
 30: - reviewing components that use will-change, transforms, or measurement
 31: 
 32: ## rendering steps glossary
 33: 
 34: - composite: transform, opacity
 35: - paint: color, borders, gradients, masks, images, filters
 36: - layout: size, position, flow, grid, flex
 37: 
 38: ## rule categories by priority
 39: 
 40: | priority | category | impact |
 41: |----------|----------|--------|
 42: | 1 | never patterns | critical |
 43: | 2 | choose the mechanism | critical |
 44: | 3 | measurement | high |
 45: | 4 | scroll | high |
 46: | 5 | paint | medium-high |
 47: | 6 | layers | medium |
 48: | 7 | blur and filters | medium |
 49: | 8 | view transitions | low |
 50: | 9 | tool boundaries | critical |
 51: 
 52: ## quick reference
 53: 
 54: ### 1. never patterns (critical)
 55: 
 56: - do not interleave layout reads and writes in the same frame
 57: - do not animate layout continuously on large or meaningful surfaces
 58: - do not drive animation from scrollTop, scrollY, or scroll events
 59: - no requestAnimationFrame loops without a stop condition
 60: - do not mix multiple animation systems that each measure or mutate layout
 61: 
 62: ### 2. choose the mechanism (critical)
 63: 
 64: - default to transform and opacity for motion
 65: - use JS-driven animation only when interaction requires it
 66: - paint or layout animation is acceptable only on small, isolated surfaces
 67: - one-shot effects are acceptable more often than continuous motion
 68: - prefer downgrading technique over removing motion entirely
 69: 
 70: ### 3. measurement (high)
 71: 
 72: - measure once, then animate via transform or opacity
 73: - batch all DOM reads before writes
 74: - do not read layout repeatedly during an animation
 75: - prefer FLIP-style transitions for layout-like effects
 76: - prefer approaches that batch measurement and writes
 77: 
 78: ### 4. scroll (high)
 79: 
 80: - prefer Scroll or View Timelines for scroll-linked motion when available
 81: - use IntersectionObserver for visibility and pausing
 82: - do not poll scroll position for animation
 83: - pause or stop animations when off-screen
 84: - scroll-linked motion must not trigger continuous layout or paint on large surfaces
 85: 
 86: ### 5. paint (medium-high)
 87: 
 88: - paint-triggering animation is allowed only on small, isolated elements
 89: - do not animate paint-heavy properties on large containers
 90: - do not animate CSS variables for transform, opacity, or position
 91: - do not animate inherited CSS variables
 92: - scope animated CSS variables locally and avoid inheritance
 93: 
 94: ### 6. layers (medium)
 95: 
 96: - compositor motion requires layer promotion, never assume it
 97: - use will-change temporarily and surgically
 98: - avoid many or large promoted layers
 99: - validate layer behavior with tooling when performance matters
100: 
101: ### 7. blur and filters (medium)
102: 
103: - keep blur animation small (<=8px)
104: - use blur only for short, one-time effects
105: - never animate blur continuously
106: - never animate blur on large surfaces
107: - prefer opacity and translate before blur
108: 
109: ### 8. view transitions (low)
110: 
111: - use view transitions only for navigation-level changes
112: - avoid view transitions for interaction-heavy UI
113: - avoid view transitions when interruption or cancellation is required
114: - treat size changes as potentially layout-triggering
115: 
116: ### 9. tool boundaries (critical)
117: 
118: - do not migrate or rewrite animation libraries unless explicitly requested
119: - apply these rules within the existing animation system
120: - never partially migrate APIs or mix styles within the same component
121: 
122: ## review guidance
123: 
124: - enforce critical rules first (never patterns, tool boundaries)
125: - choose the least expensive rendering work that matches the intent
126: - for any non-default choice, state the constraint that justifies it (surface size, duration, or interaction requirement)
127: - when reviewing, prefer actionable notes and concrete alternatives over theory
</file>

<file path=".agents/skills/git-commit/SKILL.md">
  1: ---
  2: name: git-commit
  3: description: 'Execute git commit with conventional commit message analysis, intelligent staging, and message generation. Use when user asks to commit changes, create a git commit, or mentions "/commit". Supports: (1) Auto-detecting type and scope from changes, (2) Generating conventional commit messages from diff, (3) Interactive commit with optional type/scope/description overrides, (4) Intelligent file staging for logical grouping'
  4: license: MIT
  5: allowed-tools: Bash
  6: ---
  7: 
  8: # Git Commit with Conventional Commits
  9: 
 10: ## Overview
 11: 
 12: Create standardized, semantic git commits using the Conventional Commits specification. Analyze the actual diff to determine appropriate type, scope, and message.
 13: 
 14: ## Conventional Commit Format
 15: 
 16: ```
 17: <type>[optional scope]: <description>
 18: 
 19: [optional body]
 20: 
 21: [optional footer(s)]
 22: ```
 23: 
 24: ## Commit Types
 25: 
 26: | Type       | Purpose                        |
 27: | ---------- | ------------------------------ |
 28: | `feat`     | New feature                    |
 29: | `fix`      | Bug fix                        |
 30: | `docs`     | Documentation only             |
 31: | `style`    | Formatting/style (no logic)    |
 32: | `refactor` | Code refactor (no feature/fix) |
 33: | `perf`     | Performance improvement        |
 34: | `test`     | Add/update tests               |
 35: | `build`    | Build system/dependencies      |
 36: | `ci`       | CI/config changes              |
 37: | `chore`    | Maintenance/misc               |
 38: | `revert`   | Revert commit                  |
 39: 
 40: ## Breaking Changes
 41: 
 42: ```
 43: # Exclamation mark after type/scope
 44: feat!: remove deprecated endpoint
 45: 
 46: # BREAKING CHANGE footer
 47: feat: allow config to extend other configs
 48: 
 49: BREAKING CHANGE: `extends` key behavior changed
 50: ```
 51: 
 52: ## Workflow
 53: 
 54: ### 1. Analyze Diff
 55: 
 56: ```bash
 57: # If files are staged, use staged diff
 58: git diff --staged
 59: 
 60: # If nothing staged, use working tree diff
 61: git diff
 62: 
 63: # Also check status
 64: git status --porcelain
 65: ```
 66: 
 67: ### 2. Stage Files (if needed)
 68: 
 69: If nothing is staged or you want to group changes differently:
 70: 
 71: ```bash
 72: # Stage specific files
 73: git add path/to/file1 path/to/file2
 74: 
 75: # Stage by pattern
 76: git add *.test.*
 77: git add src/components/*
 78: 
 79: # Interactive staging
 80: git add -p
 81: ```
 82: 
 83: **Never commit secrets** (.env, credentials.json, private keys).
 84: 
 85: ### 3. Generate Commit Message
 86: 
 87: Analyze the diff to determine:
 88: 
 89: - **Type**: What kind of change is this?
 90: - **Scope**: What area/module is affected?
 91: - **Description**: One-line summary of what changed (present tense, imperative mood, <72 chars)
 92: 
 93: ### 4. Execute Commit
 94: 
 95: ```bash
 96: # Single line
 97: git commit -m "<type>[scope]: <description>"
 98: 
 99: # Multi-line with body/footer
100: git commit -m "$(cat <<'EOF'
101: <type>[scope]: <description>
102: 
103: <optional body>
104: 
105: <optional footer>
106: EOF
107: )"
108: ```
109: 
110: ## Best Practices
111: 
112: - One logical change per commit
113: - Present tense: "add" not "added"
114: - Imperative mood: "fix bug" not "fixes bug"
115: - Reference issues: `Closes #123`, `Refs #456`
116: - Keep description under 72 characters
117: 
118: ## Git Safety Protocol
119: 
120: - NEVER update git config
121: - NEVER run destructive commands (--force, hard reset) without explicit request
122: - NEVER skip hooks (--no-verify) unless user asks
123: - NEVER force push to main/master
124: - If commit fails due to hooks, fix and create NEW commit (don't amend)
</file>

<file path=".agents/skills/typescript-expert/references/tsconfig-strict.json">
 1: {
 2:     "$schema": "https://json.schemastore.org/tsconfig",
 3:     "display": "Strict TypeScript 5.x",
 4:     "compilerOptions": {
 5:         // =========================================================================
 6:         // STRICTNESS (Maximum Type Safety)
 7:         // =========================================================================
 8:         "strict": true,
 9:         "noUncheckedIndexedAccess": true,
10:         "noImplicitOverride": true,
11:         "noPropertyAccessFromIndexSignature": true,
12:         "exactOptionalPropertyTypes": true,
13:         "noFallthroughCasesInSwitch": true,
14:         "forceConsistentCasingInFileNames": true,
15:         // =========================================================================
16:         // MODULE SYSTEM (Modern ESM)
17:         // =========================================================================
18:         "module": "ESNext",
19:         "moduleResolution": "bundler",
20:         "resolveJsonModule": true,
21:         "esModuleInterop": true,
22:         "allowSyntheticDefaultImports": true,
23:         "isolatedModules": true,
24:         "verbatimModuleSyntax": true,
25:         // =========================================================================
26:         // OUTPUT
27:         // =========================================================================
28:         "target": "ES2022",
29:         "lib": [
30:             "ES2022",
31:             "DOM",
32:             "DOM.Iterable"
33:         ],
34:         "declaration": true,
35:         "declarationMap": true,
36:         "sourceMap": true,
37:         // =========================================================================
38:         // PERFORMANCE
39:         // =========================================================================
40:         "skipLibCheck": true,
41:         "incremental": true,
42:         // =========================================================================
43:         // PATH ALIASES
44:         // =========================================================================
45:         "baseUrl": ".",
46:         "paths": {
47:             "@/*": [
48:                 "./src/*"
49:             ],
50:             "@/components/*": [
51:                 "./src/components/*"
52:             ],
53:             "@/lib/*": [
54:                 "./src/lib/*"
55:             ],
56:             "@/types/*": [
57:                 "./src/types/*"
58:             ],
59:             "@/utils/*": [
60:                 "./src/utils/*"
61:             ]
62:         },
63:         // =========================================================================
64:         // JSX (for React projects)
65:         // =========================================================================
66:         // "jsx": "react-jsx",
67:         // =========================================================================
68:         // EMIT
69:         // =========================================================================
70:         "noEmit": true, // Let bundler handle emit
71:         // "outDir": "./dist",
72:         // "rootDir": "./src",
73:         // =========================================================================
74:         // DECORATORS (if needed)
75:         // =========================================================================
76:         // "experimentalDecorators": true,
77:         // "emitDecoratorMetadata": true
78:     },
79:     "include": [
80:         "src/**/*.ts",
81:         "src/**/*.tsx",
82:         "src/**/*.d.ts"
83:     ],
84:     "exclude": [
85:         "node_modules",
86:         "dist",
87:         "build",
88:         "coverage",
89:         "**/*.test.ts",
90:         "**/*.spec.ts"
91:     ]
92: }
</file>

<file path=".agents/skills/typescript-expert/references/typescript-cheatsheet.md">
  1: # TypeScript Cheatsheet
  2: 
  3: ## Type Basics
  4: 
  5: ```typescript
  6: // Primitives
  7: const name: string = 'John'
  8: const age: number = 30
  9: const isActive: boolean = true
 10: const nothing: null = null
 11: const notDefined: undefined = undefined
 12: 
 13: // Arrays
 14: const numbers: number[] = [1, 2, 3]
 15: const strings: Array<string> = ['a', 'b', 'c']
 16: 
 17: // Tuple
 18: const tuple: [string, number] = ['hello', 42]
 19: 
 20: // Object
 21: const user: { name: string; age: number } = { name: 'John', age: 30 }
 22: 
 23: // Union
 24: const value: string | number = 'hello'
 25: 
 26: // Literal
 27: const direction: 'up' | 'down' | 'left' | 'right' = 'up'
 28: 
 29: // Any vs Unknown
 30: const anyValue: any = 'anything'     // ‚ùå Avoid
 31: const unknownValue: unknown = 'safe' // ‚úÖ Prefer, requires narrowing
 32: ```
 33: 
 34: ## Type Aliases & Interfaces
 35: 
 36: ```typescript
 37: // Type Alias
 38: type Point = {
 39:   x: number
 40:   y: number
 41: }
 42: 
 43: // Interface (preferred for objects)
 44: interface User {
 45:   id: string
 46:   name: string
 47:   email?: string  // Optional
 48:   readonly createdAt: Date  // Readonly
 49: }
 50: 
 51: // Extending
 52: interface Admin extends User {
 53:   permissions: string[]
 54: }
 55: 
 56: // Intersection
 57: type AdminUser = User & { permissions: string[] }
 58: ```
 59: 
 60: ## Generics
 61: 
 62: ```typescript
 63: // Generic function
 64: function identity<T>(value: T): T {
 65:   return value
 66: }
 67: 
 68: // Generic with constraint
 69: function getLength<T extends { length: number }>(item: T): number {
 70:   return item.length
 71: }
 72: 
 73: // Generic interface
 74: interface ApiResponse<T> {
 75:   data: T
 76:   status: number
 77:   message: string
 78: }
 79: 
 80: // Generic with default
 81: type Container<T = string> = {
 82:   value: T
 83: }
 84: 
 85: // Multiple generics
 86: function merge<T, U>(obj1: T, obj2: U): T & U {
 87:   return { ...obj1, ...obj2 }
 88: }
 89: ```
 90: 
 91: ## Utility Types
 92: 
 93: ```typescript
 94: interface User {
 95:   id: string
 96:   name: string
 97:   email: string
 98:   age: number
 99: }
100: 
101: // Partial - all optional
102: type PartialUser = Partial<User>
103: 
104: // Required - all required
105: type RequiredUser = Required<User>
106: 
107: // Readonly - all readonly
108: type ReadonlyUser = Readonly<User>
109: 
110: // Pick - select properties
111: type UserName = Pick<User, 'id' | 'name'>
112: 
113: // Omit - exclude properties
114: type UserWithoutEmail = Omit<User, 'email'>
115: 
116: // Record - key-value map
117: type UserMap = Record<string, User>
118: 
119: // Extract - extract from union
120: type StringOrNumber = string | number | boolean
121: type OnlyStrings = Extract<StringOrNumber, string>
122: 
123: // Exclude - exclude from union
124: type NotString = Exclude<StringOrNumber, string>
125: 
126: // NonNullable - remove null/undefined
127: type MaybeString = string | null | undefined
128: type DefinitelyString = NonNullable<MaybeString>
129: 
130: // ReturnType - get function return type
131: function getUser() { return { name: 'John' } }
132: type UserReturn = ReturnType<typeof getUser>
133: 
134: // Parameters - get function parameters
135: type GetUserParams = Parameters<typeof getUser>
136: 
137: // Awaited - unwrap Promise
138: type ResolvedUser = Awaited<Promise<User>>
139: ```
140: 
141: ## Conditional Types
142: 
143: ```typescript
144: // Basic conditional
145: type IsString<T> = T extends string ? true : false
146: 
147: // Infer keyword
148: type UnwrapPromise<T> = T extends Promise<infer U> ? U : T
149: 
150: // Distributive conditional
151: type ToArray<T> = T extends any ? T[] : never
152: type Result = ToArray<string | number>  // string[] | number[]
153: 
154: // NonDistributive
155: type ToArrayNonDist<T> = [T] extends [any] ? T[] : never
156: ```
157: 
158: ## Template Literal Types
159: 
160: ```typescript
161: type Color = 'red' | 'green' | 'blue'
162: type Size = 'small' | 'medium' | 'large'
163: 
164: // Combine
165: type ColorSize = `${Color}-${Size}`
166: // 'red-small' | 'red-medium' | 'red-large' | ...
167: 
168: // Event handlers
169: type EventName = 'click' | 'focus' | 'blur'
170: type EventHandler = `on${Capitalize<EventName>}`
171: // 'onClick' | 'onFocus' | 'onBlur'
172: ```
173: 
174: ## Mapped Types
175: 
176: ```typescript
177: // Basic mapped type
178: type Optional<T> = {
179:   [K in keyof T]?: T[K]
180: }
181: 
182: // With key remapping
183: type Getters<T> = {
184:   [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K]
185: }
186: 
187: // Filter keys
188: type OnlyStrings<T> = {
189:   [K in keyof T as T[K] extends string ? K : never]: T[K]
190: }
191: ```
192: 
193: ## Type Guards
194: 
195: ```typescript
196: // typeof guard
197: function process(value: string | number) {
198:   if (typeof value === 'string') {
199:     return value.toUpperCase()  // string
200:   }
201:   return value.toFixed(2)  // number
202: }
203: 
204: // instanceof guard
205: class Dog { bark() {} }
206: class Cat { meow() {} }
207: 
208: function makeSound(animal: Dog | Cat) {
209:   if (animal instanceof Dog) {
210:     animal.bark()
211:   } else {
212:     animal.meow()
213:   }
214: }
215: 
216: // in guard
217: interface Bird { fly(): void }
218: interface Fish { swim(): void }
219: 
220: function move(animal: Bird | Fish) {
221:   if ('fly' in animal) {
222:     animal.fly()
223:   } else {
224:     animal.swim()
225:   }
226: }
227: 
228: // Custom type guard
229: function isString(value: unknown): value is string {
230:   return typeof value === 'string'
231: }
232: 
233: // Assertion function
234: function assertIsString(value: unknown): asserts value is string {
235:   if (typeof value !== 'string') {
236:     throw new Error('Not a string')
237:   }
238: }
239: ```
240: 
241: ## Discriminated Unions
242: 
243: ```typescript
244: // With type discriminant
245: type Success<T> = { type: 'success'; data: T }
246: type Error = { type: 'error'; message: string }
247: type Loading = { type: 'loading' }
248: 
249: type State<T> = Success<T> | Error | Loading
250: 
251: function handle<T>(state: State<T>) {
252:   switch (state.type) {
253:     case 'success':
254:       return state.data  // T
255:     case 'error':
256:       return state.message  // string
257:     case 'loading':
258:       return null
259:   }
260: }
261: 
262: // Exhaustive check
263: function assertNever(value: never): never {
264:   throw new Error(`Unexpected value: ${value}`)
265: }
266: ```
267: 
268: ## Branded Types
269: 
270: ```typescript
271: // Create branded type
272: type Brand<K, T> = K & { __brand: T }
273: 
274: type UserId = Brand<string, 'UserId'>
275: type OrderId = Brand<string, 'OrderId'>
276: 
277: // Constructor functions
278: function createUserId(id: string): UserId {
279:   return id as UserId
280: }
281: 
282: function createOrderId(id: string): OrderId {
283:   return id as OrderId
284: }
285: 
286: // Usage - prevents mixing
287: function getOrder(orderId: OrderId, userId: UserId) {}
288: 
289: const userId = createUserId('user-123')
290: const orderId = createOrderId('order-456')
291: 
292: getOrder(orderId, userId)  // ‚úÖ OK
293: // getOrder(userId, orderId)  // ‚ùå Error - types don't match
294: ```
295: 
296: ## Module Declarations
297: 
298: ```typescript
299: // Declare module for untyped package
300: declare module 'untyped-package' {
301:   export function doSomething(): void
302:   export const value: string
303: }
304: 
305: // Augment existing module
306: declare module 'express' {
307:   interface Request {
308:     user?: { id: string }
309:   }
310: }
311: 
312: // Declare global
313: declare global {
314:   interface Window {
315:     myGlobal: string
316:   }
317: }
318: ```
319: 
320: ## TSConfig Essentials
321: 
322: ```json
323: {
324:   "compilerOptions": {
325:     // Strictness
326:     "strict": true,
327:     "noUncheckedIndexedAccess": true,
328:     "noImplicitOverride": true,
329:     
330:     // Modules
331:     "module": "ESNext",
332:     "moduleResolution": "bundler",
333:     "esModuleInterop": true,
334:     
335:     // Output
336:     "target": "ES2022",
337:     "lib": ["ES2022", "DOM"],
338:     
339:     // Performance
340:     "skipLibCheck": true,
341:     "incremental": true,
342:     
343:     // Paths
344:     "baseUrl": ".",
345:     "paths": {
346:       "@/*": ["./src/*"]
347:     }
348:   }
349: }
350: ```
351: 
352: ## Best Practices
353: 
354: ```typescript
355: // ‚úÖ Prefer interface for objects
356: interface User {
357:   name: string
358: }
359: 
360: // ‚úÖ Use const assertions
361: const routes = ['home', 'about'] as const
362: 
363: // ‚úÖ Use satisfies for validation
364: const config = {
365:   api: 'https://api.example.com'
366: } satisfies Record<string, string>
367: 
368: // ‚úÖ Use unknown over any
369: function parse(input: unknown) {
370:   if (typeof input === 'string') {
371:     return JSON.parse(input)
372:   }
373: }
374: 
375: // ‚úÖ Explicit return types for public APIs
376: export function getUser(id: string): User | null {
377:   // ...
378: }
379: 
380: // ‚ùå Avoid
381: const data: any = fetchData()
382: data.anything.goes.wrong  // No type safety
383: ```
</file>

<file path=".agents/skills/typescript-expert/references/utility-types.ts">
  1: /**
  2:  * TypeScript Utility Types Library
  3:  * 
  4:  * A collection of commonly used utility types for TypeScript projects.
  5:  * Copy and use as needed in your projects.
  6:  */
  7: // =============================================================================
  8: // BRANDED TYPES
  9: // =============================================================================
 10: /**
 11:  * Create nominal/branded types to prevent primitive obsession.
 12:  * 
 13:  * @example
 14:  * type UserId = Brand<string, 'UserId'>
 15:  * type OrderId = Brand<string, 'OrderId'>
 16:  */
 17: export type Brand<K, T> = K & { readonly __brand: T }
 18: // Branded type constructors
 19: export type UserId = Brand<string, 'UserId'>
 20: export type Email = Brand<string, 'Email'>
 21: export type UUID = Brand<string, 'UUID'>
 22: export type Timestamp = Brand<number, 'Timestamp'>
 23: export type PositiveNumber = Brand<number, 'PositiveNumber'>
 24: // =============================================================================
 25: // RESULT TYPE (Error Handling)
 26: // =============================================================================
 27: /**
 28:  * Type-safe error handling without exceptions.
 29:  */
 30: export type Result<T, E = Error> =
 31:     | { success: true; data: T }
 32:     | { success: false; error: E }
 33: export const ok = <T>(data: T): Result<T, never> => ({
 34:     success: true,
 35:     data
 36: })
 37: export const err = <E>(error: E): Result<never, E> => ({
 38:     success: false,
 39:     error
 40: })
 41: // =============================================================================
 42: // OPTION TYPE (Nullable Handling)  
 43: // =============================================================================
 44: /**
 45:  * Explicit optional value handling.
 46:  */
 47: export type Option<T> = Some<T> | None
 48: export type Some<T> = { type: 'some'; value: T }
 49: export type None = { type: 'none' }
 50: export const some = <T>(value: T): Some<T> => ({ type: 'some', value })
 51: export const none: None = { type: 'none' }
 52: // =============================================================================
 53: // DEEP UTILITIES
 54: // =============================================================================
 55: /**
 56:  * Make all properties deeply readonly.
 57:  */
 58: export type DeepReadonly<T> = T extends (...args: any[]) => any
 59:     ? T
 60:     : T extends object
 61:     ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
 62:     : T
 63: /**
 64:  * Make all properties deeply optional.
 65:  */
 66: export type DeepPartial<T> = T extends object
 67:     ? { [K in keyof T]?: DeepPartial<T[K]> }
 68:     : T
 69: /**
 70:  * Make all properties deeply required.
 71:  */
 72: export type DeepRequired<T> = T extends object
 73:     ? { [K in keyof T]-?: DeepRequired<T[K]> }
 74:     : T
 75: /**
 76:  * Make all properties deeply mutable (remove readonly).
 77:  */
 78: export type DeepMutable<T> = T extends object
 79:     ? { -readonly [K in keyof T]: DeepMutable<T[K]> }
 80:     : T
 81: // =============================================================================
 82: // OBJECT UTILITIES
 83: // =============================================================================
 84: /**
 85:  * Get keys of object where value matches type.
 86:  */
 87: export type KeysOfType<T, V> = {
 88:     [K in keyof T]: T[K] extends V ? K : never
 89: }[keyof T]
 90: /**
 91:  * Pick properties by value type.
 92:  */
 93: export type PickByType<T, V> = Pick<T, KeysOfType<T, V>>
 94: /**
 95:  * Omit properties by value type.
 96:  */
 97: export type OmitByType<T, V> = Omit<T, KeysOfType<T, V>>
 98: /**
 99:  * Make specific keys optional.
100:  */
101: export type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>
102: /**
103:  * Make specific keys required.
104:  */
105: export type RequiredBy<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>
106: /**
107:  * Make specific keys readonly.
108:  */
109: export type ReadonlyBy<T, K extends keyof T> = Omit<T, K> & Readonly<Pick<T, K>>
110: /**
111:  * Merge two types (second overrides first).
112:  */
113: export type Merge<T, U> = Omit<T, keyof U> & U
114: // =============================================================================
115: // ARRAY UTILITIES
116: // =============================================================================
117: /**
118:  * Get element type from array.
119:  */
120: export type ElementOf<T> = T extends (infer E)[] ? E : never
121: /**
122:  * Tuple of specific length.
123:  */
124: export type Tuple<T, N extends number> = N extends N
125:     ? number extends N
126:     ? T[]
127:     : _TupleOf<T, N, []>
128:     : never
129: type _TupleOf<T, N extends number, R extends unknown[]> = R['length'] extends N
130:     ? R
131:     : _TupleOf<T, N, [T, ...R]>
132: /**
133:  * Non-empty array.
134:  */
135: export type NonEmptyArray<T> = [T, ...T[]]
136: /**
137:  * At least N elements.
138:  */
139: export type AtLeast<T, N extends number> = [...Tuple<T, N>, ...T[]]
140: // =============================================================================
141: // FUNCTION UTILITIES
142: // =============================================================================
143: /**
144:  * Get function arguments as tuple.
145:  */
146: export type Arguments<T> = T extends (...args: infer A) => any ? A : never
147: /**
148:  * Get first argument of function.
149:  */
150: export type FirstArgument<T> = T extends (first: infer F, ...args: any[]) => any
151:     ? F
152:     : never
153: /**
154:  * Async version of function.
155:  */
156: export type AsyncFunction<T extends (...args: any[]) => any> = (
157:     ...args: Parameters<T>
158: ) => Promise<Awaited<ReturnType<T>>>
159: /**
160:  * Promisify return type.
161:  */
162: export type Promisify<T> = T extends (...args: infer A) => infer R
163:     ? (...args: A) => Promise<Awaited<R>>
164:     : never
165: // =============================================================================
166: // STRING UTILITIES
167: // =============================================================================
168: /**
169:  * Split string by delimiter.
170:  */
171: export type Split<S extends string, D extends string> =
172:     S extends `${infer T}${D}${infer U}`
173:     ? [T, ...Split<U, D>]
174:     : [S]
175: /**
176:  * Join tuple to string.
177:  */
178: export type Join<T extends string[], D extends string> =
179:     T extends []
180:     ? ''
181:     : T extends [infer F extends string]
182:     ? F
183:     : T extends [infer F extends string, ...infer R extends string[]]
184:     ? `${F}${D}${Join<R, D>}`
185:     : never
186: /**
187:  * Path to nested object.
188:  */
189: export type PathOf<T, K extends keyof T = keyof T> = K extends string
190:     ? T[K] extends object
191:     ? K | `${K}.${PathOf<T[K]>}`
192:     : K
193:     : never
194: // =============================================================================
195: // UNION UTILITIES
196: // =============================================================================
197: /**
198:  * Last element of union.
199:  */
200: export type UnionLast<T> = UnionToIntersection<
201:     T extends any ? () => T : never
202: > extends () => infer R
203:     ? R
204:     : never
205: /**
206:  * Union to intersection.
207:  */
208: export type UnionToIntersection<U> = (
209:     U extends any ? (k: U) => void : never
210: ) extends (k: infer I) => void
211:     ? I
212:     : never
213: /**
214:  * Union to tuple.
215:  */
216: export type UnionToTuple<T, L = UnionLast<T>> = [T] extends [never]
217:     ? []
218:     : [...UnionToTuple<Exclude<T, L>>, L]
219: // =============================================================================
220: // VALIDATION UTILITIES
221: // =============================================================================
222: /**
223:  * Assert type at compile time.
224:  */
225: export type AssertEqual<T, U> =
226:     (<V>() => V extends T ? 1 : 2) extends (<V>() => V extends U ? 1 : 2)
227:     ? true
228:     : false
229: /**
230:  * Ensure type is not never.
231:  */
232: export type IsNever<T> = [T] extends [never] ? true : false
233: /**
234:  * Ensure type is any.
235:  */
236: export type IsAny<T> = 0 extends 1 & T ? true : false
237: /**
238:  * Ensure type is unknown.
239:  */
240: export type IsUnknown<T> = IsAny<T> extends true
241:     ? false
242:     : unknown extends T
243:     ? true
244:     : false
245: // =============================================================================
246: // JSON UTILITIES
247: // =============================================================================
248: /**
249:  * JSON-safe types.
250:  */
251: export type JsonPrimitive = string | number | boolean | null
252: export type JsonArray = JsonValue[]
253: export type JsonObject = { [key: string]: JsonValue }
254: export type JsonValue = JsonPrimitive | JsonArray | JsonObject
255: /**
256:  * Make type JSON-serializable.
257:  */
258: export type Jsonify<T> = T extends JsonPrimitive
259:     ? T
260:     : T extends undefined | ((...args: any[]) => any) | symbol
261:     ? never
262:     : T extends { toJSON(): infer R }
263:     ? R
264:     : T extends object
265:     ? { [K in keyof T]: Jsonify<T[K]> }
266:     : never
267: // =============================================================================
268: // EXHAUSTIVE CHECK
269: // =============================================================================
270: /**
271:  * Ensure all cases are handled in switch/if.
272:  */
273: export function assertNever(value: never, message?: string): never {
274:     throw new Error(message ?? `Unexpected value: ${value}`)
275: }
276: /**
277:  * Exhaustive check without throwing.
278:  */
279: export function exhaustiveCheck(_value: never): void {
280:     // This function should never be called
281: }
</file>

<file path=".agents/skills/typescript-expert/scripts/ts_diagnostic.py">
  1: #!/usr/bin/env python3
  2: """
  3: TypeScript Project Diagnostic Script
  4: Analyzes TypeScript projects for configuration, performance, and common issues.
  5: """
  6: import subprocess
  7: import sys
  8: import os
  9: import json
 10: from pathlib import Path
 11: def run_cmd(cmd: str) -> str:
 12:     """Run shell command and return output."""
 13:     try:
 14:         result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
 15:         return result.stdout + result.stderr
 16:     except Exception as e:
 17:         return str(e)
 18: def check_versions():
 19:     """Check TypeScript and Node versions."""
 20:     print("\nüì¶ Versions:")
 21:     print("-" * 40)
 22:     ts_version = run_cmd("npx tsc --version 2>/dev/null").strip()
 23:     node_version = run_cmd("node -v 2>/dev/null").strip()
 24:     print(f"  TypeScript: {ts_version or 'Not found'}")
 25:     print(f"  Node.js: {node_version or 'Not found'}")
 26: def check_tsconfig():
 27:     """Analyze tsconfig.json settings."""
 28:     print("\n‚öôÔ∏è TSConfig Analysis:")
 29:     print("-" * 40)
 30:     tsconfig_path = Path("tsconfig.json")
 31:     if not tsconfig_path.exists():
 32:         print("‚ö†Ô∏è tsconfig.json not found")
 33:         return
 34:     try:
 35:         with open(tsconfig_path) as f:
 36:             config = json.load(f)
 37:         compiler_opts = config.get("compilerOptions", {})
 38:         # Check strict mode
 39:         if compiler_opts.get("strict"):
 40:             print("‚úÖ Strict mode enabled")
 41:         else:
 42:             print("‚ö†Ô∏è Strict mode NOT enabled")
 43:         # Check important flags
 44:         flags = {
 45:             "noUncheckedIndexedAccess": "Unchecked index access protection",
 46:             "noImplicitOverride": "Implicit override protection",
 47:             "skipLibCheck": "Skip lib check (performance)",
 48:             "incremental": "Incremental compilation"
 49:         }
 50:         for flag, desc in flags.items():
 51:             status = "‚úÖ" if compiler_opts.get(flag) else "‚ö™"
 52:             print(f"  {status} {desc}: {compiler_opts.get(flag, 'not set')}")
 53:         # Check module settings
 54:         print(f"\n  Module: {compiler_opts.get('module', 'not set')}")
 55:         print(f"  Module Resolution: {compiler_opts.get('moduleResolution', 'not set')}")
 56:         print(f"  Target: {compiler_opts.get('target', 'not set')}")
 57:     except json.JSONDecodeError:
 58:         print("‚ùå Invalid JSON in tsconfig.json")
 59: def check_tooling():
 60:     """Detect TypeScript tooling ecosystem."""
 61:     print("\nüõ†Ô∏è Tooling Detection:")
 62:     print("-" * 40)
 63:     pkg_path = Path("package.json")
 64:     if not pkg_path.exists():
 65:         print("‚ö†Ô∏è package.json not found")
 66:         return
 67:     try:
 68:         with open(pkg_path) as f:
 69:             pkg = json.load(f)
 70:         all_deps = {**pkg.get("dependencies", {}), **pkg.get("devDependencies", {})}
 71:         tools = {
 72:             "biome": "Biome (linter/formatter)",
 73:             "eslint": "ESLint",
 74:             "prettier": "Prettier",
 75:             "vitest": "Vitest (testing)",
 76:             "jest": "Jest (testing)",
 77:             "turborepo": "Turborepo (monorepo)",
 78:             "turbo": "Turbo (monorepo)",
 79:             "nx": "Nx (monorepo)",
 80:             "lerna": "Lerna (monorepo)"
 81:         }
 82:         for tool, desc in tools.items():
 83:             for dep in all_deps:
 84:                 if tool in dep.lower():
 85:                     print(f"  ‚úÖ {desc}")
 86:                     break
 87:     except json.JSONDecodeError:
 88:         print("‚ùå Invalid JSON in package.json")
 89: def check_monorepo():
 90:     """Check for monorepo configuration."""
 91:     print("\nüì¶ Monorepo Check:")
 92:     print("-" * 40)
 93:     indicators = [
 94:         ("pnpm-workspace.yaml", "PNPM Workspace"),
 95:         ("lerna.json", "Lerna"),
 96:         ("nx.json", "Nx"),
 97:         ("turbo.json", "Turborepo")
 98:     ]
 99:     found = False
100:     for file, name in indicators:
101:         if Path(file).exists():
102:             print(f"  ‚úÖ {name} detected")
103:             found = True
104:     if not found:
105:         print("  ‚ö™ No monorepo configuration detected")
106: def check_type_errors():
107:     """Run quick type check."""
108:     print("\nüîç Type Check:")
109:     print("-" * 40)
110:     result = run_cmd("npx tsc --noEmit 2>&1 | head -20")
111:     if "error TS" in result:
112:         errors = result.count("error TS")
113:         print(f"  ‚ùå {errors}+ type errors found")
114:         print(result[:500])
115:     else:
116:         print("  ‚úÖ No type errors")
117: def check_any_usage():
118:     """Check for any type usage."""
119:     print("\n‚ö†Ô∏è 'any' Type Usage:")
120:     print("-" * 40)
121:     result = run_cmd("grep -r ': any' --include='*.ts' --include='*.tsx' src/ 2>/dev/null | wc -l")
122:     count = result.strip()
123:     if count and count != "0":
124:         print(f"  ‚ö†Ô∏è Found {count} occurrences of ': any'")
125:         sample = run_cmd("grep -rn ': any' --include='*.ts' --include='*.tsx' src/ 2>/dev/null | head -5")
126:         if sample:
127:             print(sample)
128:     else:
129:         print("  ‚úÖ No explicit 'any' types found")
130: def check_type_assertions():
131:     """Check for type assertions."""
132:     print("\n‚ö†Ô∏è Type Assertions (as):")
133:     print("-" * 40)
134:     result = run_cmd("grep -r ' as ' --include='*.ts' --include='*.tsx' src/ 2>/dev/null | grep -v 'import' | wc -l")
135:     count = result.strip()
136:     if count and count != "0":
137:         print(f"  ‚ö†Ô∏è Found {count} type assertions")
138:     else:
139:         print("  ‚úÖ No type assertions found")
140: def check_performance():
141:     """Check type checking performance."""
142:     print("\n‚è±Ô∏è Type Check Performance:")
143:     print("-" * 40)
144:     result = run_cmd("npx tsc --extendedDiagnostics --noEmit 2>&1 | grep -E 'Check time|Files:|Lines:|Nodes:'")
145:     if result.strip():
146:         for line in result.strip().split('\n'):
147:             print(f"  {line}")
148:     else:
149:         print("  ‚ö†Ô∏è Could not measure performance")
150: def main():
151:     print("=" * 50)
152:     print("üîç TypeScript Project Diagnostic Report")
153:     print("=" * 50)
154:     check_versions()
155:     check_tsconfig()
156:     check_tooling()
157:     check_monorepo()
158:     check_any_usage()
159:     check_type_assertions()
160:     check_type_errors()
161:     check_performance()
162:     print("\n" + "=" * 50)
163:     print("‚úÖ Diagnostic Complete")
164:     print("=" * 50)
165: if __name__ == "__main__":
166:     main()
</file>

<file path=".agents/skills/typescript-expert/SKILL.md">
  1: ---
  2: name: typescript-expert
  3: description: >-
  4:   TypeScript and JavaScript expert with deep knowledge of type-level
  5:   programming, performance optimization, monorepo management, migration
  6:   strategies, and modern tooling. Use PROACTIVELY for any TypeScript/JavaScript
  7:   issues including complex type gymnastics, build performance, debugging, and
  8:   architectural decisions. If a specialized expert is a better fit, I will
  9:   recommend switching and stop.
 10: category: framework
 11: bundle: [typescript-type-expert, typescript-build-expert]
 12: displayName: TypeScript
 13: color: blue
 14: ---
 15: 
 16: # TypeScript Expert
 17: 
 18: You are an advanced TypeScript expert with deep, practical knowledge of type-level programming, performance optimization, and real-world problem solving based on current best practices.
 19: 
 20: ## When invoked:
 21: 
 22: 0. If the issue requires ultra-specific expertise, recommend switching and stop:
 23:    - Deep webpack/vite/rollup bundler internals ‚Üí typescript-build-expert
 24:    - Complex ESM/CJS migration or circular dependency analysis ‚Üí typescript-module-expert
 25:    - Type performance profiling or compiler internals ‚Üí typescript-type-expert
 26: 
 27:    Example to output:
 28:    "This requires deep bundler expertise. Please invoke: 'Use the typescript-build-expert subagent.' Stopping here."
 29: 
 30: 1. Analyze project setup comprehensively:
 31:    
 32:    **Use internal tools first (Read, Grep, Glob) for better performance. Shell commands are fallbacks.**
 33:    
 34:    ```bash
 35:    # Core versions and configuration
 36:    npx tsc --version
 37:    node -v
 38:    # Detect tooling ecosystem (prefer parsing package.json)
 39:    node -e "const p=require('./package.json');console.log(Object.keys({...p.devDependencies,...p.dependencies}||{}).join('\n'))" 2>/dev/null | grep -E 'biome|eslint|prettier|vitest|jest|turborepo|nx' || echo "No tooling detected"
 40:    # Check for monorepo (fixed precedence)
 41:    (test -f pnpm-workspace.yaml || test -f lerna.json || test -f nx.json || test -f turbo.json) && echo "Monorepo detected"
 42:    ```
 43:    
 44:    **After detection, adapt approach:**
 45:    - Match import style (absolute vs relative)
 46:    - Respect existing baseUrl/paths configuration
 47:    - Prefer existing project scripts over raw tools
 48:    - In monorepos, consider project references before broad tsconfig changes
 49: 
 50: 2. Identify the specific problem category and complexity level
 51: 
 52: 3. Apply the appropriate solution strategy from my expertise
 53: 
 54: 4. Validate thoroughly:
 55:    ```bash
 56:    # Fast fail approach (avoid long-lived processes)
 57:    npm run -s typecheck || npx tsc --noEmit
 58:    npm test -s || npx vitest run --reporter=basic --no-watch
 59:    # Only if needed and build affects outputs/config
 60:    npm run -s build
 61:    ```
 62:    
 63:    **Safety note:** Avoid watch/serve processes in validation. Use one-shot diagnostics only.
 64: 
 65: ## Advanced Type System Expertise
 66: 
 67: ### Type-Level Programming Patterns
 68: 
 69: **Branded Types for Domain Modeling**
 70: ```typescript
 71: // Create nominal types to prevent primitive obsession
 72: type Brand<K, T> = K & { __brand: T };
 73: type UserId = Brand<string, 'UserId'>;
 74: type OrderId = Brand<string, 'OrderId'>;
 75: 
 76: // Prevents accidental mixing of domain primitives
 77: function processOrder(orderId: OrderId, userId: UserId) { }
 78: ```
 79: - Use for: Critical domain primitives, API boundaries, currency/units
 80: - Resource: https://egghead.io/blog/using-branded-types-in-typescript
 81: 
 82: **Advanced Conditional Types**
 83: ```typescript
 84: // Recursive type manipulation
 85: type DeepReadonly<T> = T extends (...args: any[]) => any 
 86:   ? T 
 87:   : T extends object 
 88:     ? { readonly [K in keyof T]: DeepReadonly<T[K]> }
 89:     : T;
 90: 
 91: // Template literal type magic
 92: type PropEventSource<Type> = {
 93:   on<Key extends string & keyof Type>
 94:     (eventName: `${Key}Changed`, callback: (newValue: Type[Key]) => void): void;
 95: };
 96: ```
 97: - Use for: Library APIs, type-safe event systems, compile-time validation
 98: - Watch for: Type instantiation depth errors (limit recursion to 10 levels)
 99: 
100: **Type Inference Techniques**
101: ```typescript
102: // Use 'satisfies' for constraint validation (TS 5.0+)
103: const config = {
104:   api: "https://api.example.com",
105:   timeout: 5000
106: } satisfies Record<string, string | number>;
107: // Preserves literal types while ensuring constraints
108: 
109: // Const assertions for maximum inference
110: const routes = ['/home', '/about', '/contact'] as const;
111: type Route = typeof routes[number]; // '/home' | '/about' | '/contact'
112: ```
113: 
114: ### Performance Optimization Strategies
115: 
116: **Type Checking Performance**
117: ```bash
118: # Diagnose slow type checking
119: npx tsc --extendedDiagnostics --incremental false | grep -E "Check time|Files:|Lines:|Nodes:"
120: 
121: # Common fixes for "Type instantiation is excessively deep"
122: # 1. Replace type intersections with interfaces
123: # 2. Split large union types (>100 members)
124: # 3. Avoid circular generic constraints
125: # 4. Use type aliases to break recursion
126: ```
127: 
128: **Build Performance Patterns**
129: - Enable `skipLibCheck: true` for library type checking only (often significantly improves performance on large projects, but avoid masking app typing issues)
130: - Use `incremental: true` with `.tsbuildinfo` cache
131: - Configure `include`/`exclude` precisely
132: - For monorepos: Use project references with `composite: true`
133: 
134: ## Real-World Problem Resolution
135: 
136: ### Complex Error Patterns
137: 
138: **"The inferred type of X cannot be named"**
139: - Cause: Missing type export or circular dependency
140: - Fix priority:
141:   1. Export the required type explicitly
142:   2. Use `ReturnType<typeof function>` helper
143:   3. Break circular dependencies with type-only imports
144: - Resource: https://github.com/microsoft/TypeScript/issues/47663
145: 
146: **Missing type declarations**
147: - Quick fix with ambient declarations:
148: ```typescript
149: // types/ambient.d.ts
150: declare module 'some-untyped-package' {
151:   const value: unknown;
152:   export default value;
153:   export = value; // if CJS interop is needed
154: }
155: ```
156: - For more details: [Declaration Files Guide](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)
157: 
158: **"Excessive stack depth comparing types"**
159: - Cause: Circular or deeply recursive types
160: - Fix priority:
161:   1. Limit recursion depth with conditional types
162:   2. Use `interface` extends instead of type intersection
163:   3. Simplify generic constraints
164: ```typescript
165: // Bad: Infinite recursion
166: type InfiniteArray<T> = T | InfiniteArray<T>[];
167: 
168: // Good: Limited recursion
169: type NestedArray<T, D extends number = 5> = 
170:   D extends 0 ? T : T | NestedArray<T, [-1, 0, 1, 2, 3, 4][D]>[];
171: ```
172: 
173: **Module Resolution Mysteries**
174: - "Cannot find module" despite file existing:
175:   1. Check `moduleResolution` matches your bundler
176:   2. Verify `baseUrl` and `paths` alignment
177:   3. For monorepos: Ensure workspace protocol (workspace:*)
178:   4. Try clearing cache: `rm -rf node_modules/.cache .tsbuildinfo`
179: 
180: **Path Mapping at Runtime**
181: - TypeScript paths only work at compile time, not runtime
182: - Node.js runtime solutions:
183:   - ts-node: Use `ts-node -r tsconfig-paths/register`
184:   - Node ESM: Use loader alternatives or avoid TS paths at runtime
185:   - Production: Pre-compile with resolved paths
186: 
187: ### Migration Expertise
188: 
189: **JavaScript to TypeScript Migration**
190: ```bash
191: # Incremental migration strategy
192: # 1. Enable allowJs and checkJs (merge into existing tsconfig.json):
193: # Add to existing tsconfig.json:
194: # {
195: #   "compilerOptions": {
196: #     "allowJs": true,
197: #     "checkJs": true
198: #   }
199: # }
200: 
201: # 2. Rename files gradually (.js ‚Üí .ts)
202: # 3. Add types file by file using AI assistance
203: # 4. Enable strict mode features one by one
204: 
205: # Automated helpers (if installed/needed)
206: command -v ts-migrate >/dev/null 2>&1 && npx ts-migrate migrate . --sources 'src/**/*.js'
207: command -v typesync >/dev/null 2>&1 && npx typesync  # Install missing @types packages
208: ```
209: 
210: **Tool Migration Decisions**
211: 
212: | From | To | When | Migration Effort |
213: |------|-----|------|-----------------|
214: | ESLint + Prettier | Biome | Need much faster speed, okay with fewer rules | Low (1 day) |
215: | TSC for linting | Type-check only | Have 100+ files, need faster feedback | Medium (2-3 days) |
216: | Lerna | Nx/Turborepo | Need caching, parallel builds | High (1 week) |
217: | CJS | ESM | Node 18+, modern tooling | High (varies) |
218: 
219: ### Monorepo Management
220: 
221: **Nx vs Turborepo Decision Matrix**
222: - Choose **Turborepo** if: Simple structure, need speed, <20 packages
223: - Choose **Nx** if: Complex dependencies, need visualization, plugins required
224: - Performance: Nx often performs better on large monorepos (>50 packages)
225: 
226: **TypeScript Monorepo Configuration**
227: ```json
228: // Root tsconfig.json
229: {
230:   "references": [
231:     { "path": "./packages/core" },
232:     { "path": "./packages/ui" },
233:     { "path": "./apps/web" }
234:   ],
235:   "compilerOptions": {
236:     "composite": true,
237:     "declaration": true,
238:     "declarationMap": true
239:   }
240: }
241: ```
242: 
243: ## Modern Tooling Expertise
244: 
245: ### Biome vs ESLint
246: 
247: **Use Biome when:**
248: - Speed is critical (often faster than traditional setups)
249: - Want single tool for lint + format
250: - TypeScript-first project
251: - Okay with 64 TS rules vs 100+ in typescript-eslint
252: 
253: **Stay with ESLint when:**
254: - Need specific rules/plugins
255: - Have complex custom rules
256: - Working with Vue/Angular (limited Biome support)
257: - Need type-aware linting (Biome doesn't have this yet)
258: 
259: ### Type Testing Strategies
260: 
261: **Vitest Type Testing (Recommended)**
262: ```typescript
263: // in avatar.test-d.ts
264: import { expectTypeOf } from 'vitest'
265: import type { Avatar } from './avatar'
266: 
267: test('Avatar props are correctly typed', () => {
268:   expectTypeOf<Avatar>().toHaveProperty('size')
269:   expectTypeOf<Avatar['size']>().toEqualTypeOf<'sm' | 'md' | 'lg'>()
270: })
271: ```
272: 
273: **When to Test Types:**
274: - Publishing libraries
275: - Complex generic functions
276: - Type-level utilities
277: - API contracts
278: 
279: ## Debugging Mastery
280: 
281: ### CLI Debugging Tools
282: ```bash
283: # Debug TypeScript files directly (if tools installed)
284: command -v tsx >/dev/null 2>&1 && npx tsx --inspect src/file.ts
285: command -v ts-node >/dev/null 2>&1 && npx ts-node --inspect-brk src/file.ts
286: 
287: # Trace module resolution issues
288: npx tsc --traceResolution > resolution.log 2>&1
289: grep "Module resolution" resolution.log
290: 
291: # Debug type checking performance (use --incremental false for clean trace)
292: npx tsc --generateTrace trace --incremental false
293: # Analyze trace (if installed)
294: command -v @typescript/analyze-trace >/dev/null 2>&1 && npx @typescript/analyze-trace trace
295: 
296: # Memory usage analysis
297: node --max-old-space-size=8192 node_modules/typescript/lib/tsc.js
298: ```
299: 
300: ### Custom Error Classes
301: ```typescript
302: // Proper error class with stack preservation
303: class DomainError extends Error {
304:   constructor(
305:     message: string,
306:     public code: string,
307:     public statusCode: number
308:   ) {
309:     super(message);
310:     this.name = 'DomainError';
311:     Error.captureStackTrace(this, this.constructor);
312:   }
313: }
314: ```
315: 
316: ## Current Best Practices
317: 
318: ### Strict by Default
319: ```json
320: {
321:   "compilerOptions": {
322:     "strict": true,
323:     "noUncheckedIndexedAccess": true,
324:     "noImplicitOverride": true,
325:     "exactOptionalPropertyTypes": true,
326:     "noPropertyAccessFromIndexSignature": true
327:   }
328: }
329: ```
330: 
331: ### ESM-First Approach
332: - Set `"type": "module"` in package.json
333: - Use `.mts` for TypeScript ESM files if needed
334: - Configure `"moduleResolution": "bundler"` for modern tools
335: - Use dynamic imports for CJS: `const pkg = await import('cjs-package')`
336:   - Note: `await import()` requires async function or top-level await in ESM
337:   - For CJS packages in ESM: May need `(await import('pkg')).default` depending on the package's export structure and your compiler settings
338: 
339: ### AI-Assisted Development
340: - GitHub Copilot excels at TypeScript generics
341: - Use AI for boilerplate type definitions
342: - Validate AI-generated types with type tests
343: - Document complex types for AI context
344: 
345: ## Code Review Checklist
346: 
347: When reviewing TypeScript/JavaScript code, focus on these domain-specific aspects:
348: 
349: ### Type Safety
350: - [ ] No implicit `any` types (use `unknown` or proper types)
351: - [ ] Strict null checks enabled and properly handled
352: - [ ] Type assertions (`as`) justified and minimal
353: - [ ] Generic constraints properly defined
354: - [ ] Discriminated unions for error handling
355: - [ ] Return types explicitly declared for public APIs
356: 
357: ### TypeScript Best Practices
358: - [ ] Prefer `interface` over `type` for object shapes (better error messages)
359: - [ ] Use const assertions for literal types
360: - [ ] Leverage type guards and predicates
361: - [ ] Avoid type gymnastics when simpler solution exists
362: - [ ] Template literal types used appropriately
363: - [ ] Branded types for domain primitives
364: 
365: ### Performance Considerations
366: - [ ] Type complexity doesn't cause slow compilation
367: - [ ] No excessive type instantiation depth
368: - [ ] Avoid complex mapped types in hot paths
369: - [ ] Use `skipLibCheck: true` in tsconfig
370: - [ ] Project references configured for monorepos
371: 
372: ### Module System
373: - [ ] Consistent import/export patterns
374: - [ ] No circular dependencies
375: - [ ] Proper use of barrel exports (avoid over-bundling)
376: - [ ] ESM/CJS compatibility handled correctly
377: - [ ] Dynamic imports for code splitting
378: 
379: ### Error Handling Patterns
380: - [ ] Result types or discriminated unions for errors
381: - [ ] Custom error classes with proper inheritance
382: - [ ] Type-safe error boundaries
383: - [ ] Exhaustive switch cases with `never` type
384: 
385: ### Code Organization
386: - [ ] Types co-located with implementation
387: - [ ] Shared types in dedicated modules
388: - [ ] Avoid global type augmentation when possible
389: - [ ] Proper use of declaration files (.d.ts)
390: 
391: ## Quick Decision Trees
392: 
393: ### "Which tool should I use?"
394: ```
395: Type checking only? ‚Üí tsc
396: Type checking + linting speed critical? ‚Üí Biome  
397: Type checking + comprehensive linting? ‚Üí ESLint + typescript-eslint
398: Type testing? ‚Üí Vitest expectTypeOf
399: Build tool? ‚Üí Project size <10 packages? Turborepo. Else? Nx
400: ```
401: 
402: ### "How do I fix this performance issue?"
403: ```
404: Slow type checking? ‚Üí skipLibCheck, incremental, project references
405: Slow builds? ‚Üí Check bundler config, enable caching
406: Slow tests? ‚Üí Vitest with threads, avoid type checking in tests
407: Slow language server? ‚Üí Exclude node_modules, limit files in tsconfig
408: ```
409: 
410: ## Expert Resources
411: 
412: ### Performance
413: - [TypeScript Wiki Performance](https://github.com/microsoft/TypeScript/wiki/Performance)
414: - [Type instantiation tracking](https://github.com/microsoft/TypeScript/pull/48077)
415: 
416: ### Advanced Patterns
417: - [Type Challenges](https://github.com/type-challenges/type-challenges)
418: - [Type-Level TypeScript Course](https://type-level-typescript.com)
419: 
420: ### Tools
421: - [Biome](https://biomejs.dev) - Fast linter/formatter
422: - [TypeStat](https://github.com/JoshuaKGoldberg/TypeStat) - Auto-fix TypeScript types
423: - [ts-migrate](https://github.com/airbnb/ts-migrate) - Migration toolkit
424: 
425: ### Testing
426: - [Vitest Type Testing](https://vitest.dev/guide/testing-types)
427: - [tsd](https://github.com/tsdjs/tsd) - Standalone type testing
428: 
429: Always validate changes don't break existing functionality before considering the issue resolved.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/advanced-event-handler-refs.md">
 1: ---
 2: title: Store Event Handlers in Refs
 3: impact: LOW
 4: impactDescription: stable subscriptions
 5: tags: advanced, hooks, refs, event-handlers, optimization
 6: ---
 7: 
 8: ## Store Event Handlers in Refs
 9: 
10: Store callbacks in refs when used in effects that shouldn't re-subscribe on callback changes.
11: 
12: **Incorrect (re-subscribes on every render):**
13: 
14: ```tsx
15: function useWindowEvent(event: string, handler: (e) => void) {
16:   useEffect(() => {
17:     window.addEventListener(event, handler)
18:     return () => window.removeEventListener(event, handler)
19:   }, [event, handler])
20: }
21: ```
22: 
23: **Correct (stable subscription):**
24: 
25: ```tsx
26: function useWindowEvent(event: string, handler: (e) => void) {
27:   const handlerRef = useRef(handler)
28:   useEffect(() => {
29:     handlerRef.current = handler
30:   }, [handler])
31: 
32:   useEffect(() => {
33:     const listener = (e) => handlerRef.current(e)
34:     window.addEventListener(event, listener)
35:     return () => window.removeEventListener(event, listener)
36:   }, [event])
37: }
38: ```
39: 
40: **Alternative: use `useEffectEvent` if you're on latest React:**
41: 
42: ```tsx
43: import { useEffectEvent } from 'react'
44: 
45: function useWindowEvent(event: string, handler: (e) => void) {
46:   const onEvent = useEffectEvent(handler)
47: 
48:   useEffect(() => {
49:     window.addEventListener(event, onEvent)
50:     return () => window.removeEventListener(event, onEvent)
51:   }, [event])
52: }
53: ```
54: 
55: `useEffectEvent` provides a cleaner API for the same pattern: it creates a stable function reference that always calls the latest version of the handler.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/advanced-init-once.md">
 1: ---
 2: title: Initialize App Once, Not Per Mount
 3: impact: LOW-MEDIUM
 4: impactDescription: avoids duplicate init in development
 5: tags: initialization, useEffect, app-startup, side-effects
 6: ---
 7: 
 8: ## Initialize App Once, Not Per Mount
 9: 
10: Do not put app-wide initialization that must run once per app load inside `useEffect([])` of a component. Components can remount and effects will re-run. Use a module-level guard or top-level init in the entry module instead.
11: 
12: **Incorrect (runs twice in dev, re-runs on remount):**
13: 
14: ```tsx
15: function Comp() {
16:   useEffect(() => {
17:     loadFromStorage()
18:     checkAuthToken()
19:   }, [])
20: 
21:   // ...
22: }
23: ```
24: 
25: **Correct (once per app load):**
26: 
27: ```tsx
28: let didInit = false
29: 
30: function Comp() {
31:   useEffect(() => {
32:     if (didInit) return
33:     didInit = true
34:     loadFromStorage()
35:     checkAuthToken()
36:   }, [])
37: 
38:   // ...
39: }
40: ```
41: 
42: Reference: [Initializing the application](https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/advanced-use-latest.md">
 1: ---
 2: title: useEffectEvent for Stable Callback Refs
 3: impact: LOW
 4: impactDescription: prevents effect re-runs
 5: tags: advanced, hooks, useEffectEvent, refs, optimization
 6: ---
 7: 
 8: ## useEffectEvent for Stable Callback Refs
 9: 
10: Access latest values in callbacks without adding them to dependency arrays. Prevents effect re-runs while avoiding stale closures.
11: 
12: **Incorrect (effect re-runs on every callback change):**
13: 
14: ```tsx
15: function SearchInput({ onSearch }: { onSearch: (q: string) => void }) {
16:   const [query, setQuery] = useState('')
17: 
18:   useEffect(() => {
19:     const timeout = setTimeout(() => onSearch(query), 300)
20:     return () => clearTimeout(timeout)
21:   }, [query, onSearch])
22: }
23: ```
24: 
25: **Correct (using React's useEffectEvent):**
26: 
27: ```tsx
28: import { useEffectEvent } from 'react';
29: 
30: function SearchInput({ onSearch }: { onSearch: (q: string) => void }) {
31:   const [query, setQuery] = useState('')
32:   const onSearchEvent = useEffectEvent(onSearch)
33: 
34:   useEffect(() => {
35:     const timeout = setTimeout(() => onSearchEvent(query), 300)
36:     return () => clearTimeout(timeout)
37:   }, [query])
38: }
39: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/async-api-routes.md">
 1: ---
 2: title: Prevent Waterfall Chains in API Routes
 3: impact: CRITICAL
 4: impactDescription: 2-10√ó improvement
 5: tags: api-routes, server-actions, waterfalls, parallelization
 6: ---
 7: 
 8: ## Prevent Waterfall Chains in API Routes
 9: 
10: In API routes and Server Actions, start independent operations immediately, even if you don't await them yet.
11: 
12: **Incorrect (config waits for auth, data waits for both):**
13: 
14: ```typescript
15: export async function GET(request: Request) {
16:   const session = await auth()
17:   const config = await fetchConfig()
18:   const data = await fetchData(session.user.id)
19:   return Response.json({ data, config })
20: }
21: ```
22: 
23: **Correct (auth and config start immediately):**
24: 
25: ```typescript
26: export async function GET(request: Request) {
27:   const sessionPromise = auth()
28:   const configPromise = fetchConfig()
29:   const session = await sessionPromise
30:   const [config, data] = await Promise.all([
31:     configPromise,
32:     fetchData(session.user.id)
33:   ])
34:   return Response.json({ data, config })
35: }
36: ```
37: 
38: For operations with more complex dependency chains, use `better-all` to automatically maximize parallelism (see Dependency-Based Parallelization).
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/async-defer-await.md">
 1: ---
 2: title: Defer Await Until Needed
 3: impact: HIGH
 4: impactDescription: avoids blocking unused code paths
 5: tags: async, await, conditional, optimization
 6: ---
 7: 
 8: ## Defer Await Until Needed
 9: 
10: Move `await` operations into the branches where they're actually used to avoid blocking code paths that don't need them.
11: 
12: **Incorrect (blocks both branches):**
13: 
14: ```typescript
15: async function handleRequest(userId: string, skipProcessing: boolean) {
16:   const userData = await fetchUserData(userId)
17:   
18:   if (skipProcessing) {
19:     // Returns immediately but still waited for userData
20:     return { skipped: true }
21:   }
22:   
23:   // Only this branch uses userData
24:   return processUserData(userData)
25: }
26: ```
27: 
28: **Correct (only blocks when needed):**
29: 
30: ```typescript
31: async function handleRequest(userId: string, skipProcessing: boolean) {
32:   if (skipProcessing) {
33:     // Returns immediately without waiting
34:     return { skipped: true }
35:   }
36:   
37:   // Fetch only when needed
38:   const userData = await fetchUserData(userId)
39:   return processUserData(userData)
40: }
41: ```
42: 
43: **Another example (early return optimization):**
44: 
45: ```typescript
46: // Incorrect: always fetches permissions
47: async function updateResource(resourceId: string, userId: string) {
48:   const permissions = await fetchPermissions(userId)
49:   const resource = await getResource(resourceId)
50:   
51:   if (!resource) {
52:     return { error: 'Not found' }
53:   }
54:   
55:   if (!permissions.canEdit) {
56:     return { error: 'Forbidden' }
57:   }
58:   
59:   return await updateResourceData(resource, permissions)
60: }
61: 
62: // Correct: fetches only when needed
63: async function updateResource(resourceId: string, userId: string) {
64:   const resource = await getResource(resourceId)
65:   
66:   if (!resource) {
67:     return { error: 'Not found' }
68:   }
69:   
70:   const permissions = await fetchPermissions(userId)
71:   
72:   if (!permissions.canEdit) {
73:     return { error: 'Forbidden' }
74:   }
75:   
76:   return await updateResourceData(resource, permissions)
77: }
78: ```
79: 
80: This optimization is especially valuable when the skipped branch is frequently taken, or when the deferred operation is expensive.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/async-dependencies.md">
 1: ---
 2: title: Dependency-Based Parallelization
 3: impact: CRITICAL
 4: impactDescription: 2-10√ó improvement
 5: tags: async, parallelization, dependencies, better-all
 6: ---
 7: 
 8: ## Dependency-Based Parallelization
 9: 
10: For operations with partial dependencies, use `better-all` to maximize parallelism. It automatically starts each task at the earliest possible moment.
11: 
12: **Incorrect (profile waits for config unnecessarily):**
13: 
14: ```typescript
15: const [user, config] = await Promise.all([
16:   fetchUser(),
17:   fetchConfig()
18: ])
19: const profile = await fetchProfile(user.id)
20: ```
21: 
22: **Correct (config and profile run in parallel):**
23: 
24: ```typescript
25: import { all } from 'better-all'
26: 
27: const { user, config, profile } = await all({
28:   async user() { return fetchUser() },
29:   async config() { return fetchConfig() },
30:   async profile() {
31:     return fetchProfile((await this.$.user).id)
32:   }
33: })
34: ```
35: 
36: **Alternative without extra dependencies:**
37: 
38: We can also create all the promises first, and do `Promise.all()` at the end.
39: 
40: ```typescript
41: const userPromise = fetchUser()
42: const profilePromise = userPromise.then(user => fetchProfile(user.id))
43: 
44: const [user, config, profile] = await Promise.all([
45:   userPromise,
46:   fetchConfig(),
47:   profilePromise
48: ])
49: ```
50: 
51: Reference: [https://github.com/shuding/better-all](https://github.com/shuding/better-all)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/async-parallel.md">
 1: ---
 2: title: Promise.all() for Independent Operations
 3: impact: CRITICAL
 4: impactDescription: 2-10√ó improvement
 5: tags: async, parallelization, promises, waterfalls
 6: ---
 7: 
 8: ## Promise.all() for Independent Operations
 9: 
10: When async operations have no interdependencies, execute them concurrently using `Promise.all()`.
11: 
12: **Incorrect (sequential execution, 3 round trips):**
13: 
14: ```typescript
15: const user = await fetchUser()
16: const posts = await fetchPosts()
17: const comments = await fetchComments()
18: ```
19: 
20: **Correct (parallel execution, 1 round trip):**
21: 
22: ```typescript
23: const [user, posts, comments] = await Promise.all([
24:   fetchUser(),
25:   fetchPosts(),
26:   fetchComments()
27: ])
28: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/async-suspense-boundaries.md">
 1: ---
 2: title: Strategic Suspense Boundaries
 3: impact: HIGH
 4: impactDescription: faster initial paint
 5: tags: async, suspense, streaming, layout-shift
 6: ---
 7: 
 8: ## Strategic Suspense Boundaries
 9: 
10: Instead of awaiting data in async components before returning JSX, use Suspense boundaries to show the wrapper UI faster while data loads.
11: 
12: **Incorrect (wrapper blocked by data fetching):**
13: 
14: ```tsx
15: async function Page() {
16:   const data = await fetchData() // Blocks entire page
17:   
18:   return (
19:     <div>
20:       <div>Sidebar</div>
21:       <div>Header</div>
22:       <div>
23:         <DataDisplay data={data} />
24:       </div>
25:       <div>Footer</div>
26:     </div>
27:   )
28: }
29: ```
30: 
31: The entire layout waits for data even though only the middle section needs it.
32: 
33: **Correct (wrapper shows immediately, data streams in):**
34: 
35: ```tsx
36: function Page() {
37:   return (
38:     <div>
39:       <div>Sidebar</div>
40:       <div>Header</div>
41:       <div>
42:         <Suspense fallback={<Skeleton />}>
43:           <DataDisplay />
44:         </Suspense>
45:       </div>
46:       <div>Footer</div>
47:     </div>
48:   )
49: }
50: 
51: async function DataDisplay() {
52:   const data = await fetchData() // Only blocks this component
53:   return <div>{data.content}</div>
54: }
55: ```
56: 
57: Sidebar, Header, and Footer render immediately. Only DataDisplay waits for data.
58: 
59: **Alternative (share promise across components):**
60: 
61: ```tsx
62: function Page() {
63:   // Start fetch immediately, but don't await
64:   const dataPromise = fetchData()
65:   
66:   return (
67:     <div>
68:       <div>Sidebar</div>
69:       <div>Header</div>
70:       <Suspense fallback={<Skeleton />}>
71:         <DataDisplay dataPromise={dataPromise} />
72:         <DataSummary dataPromise={dataPromise} />
73:       </Suspense>
74:       <div>Footer</div>
75:     </div>
76:   )
77: }
78: 
79: function DataDisplay({ dataPromise }: { dataPromise: Promise<Data> }) {
80:   const data = use(dataPromise) // Unwraps the promise
81:   return <div>{data.content}</div>
82: }
83: 
84: function DataSummary({ dataPromise }: { dataPromise: Promise<Data> }) {
85:   const data = use(dataPromise) // Reuses the same promise
86:   return <div>{data.summary}</div>
87: }
88: ```
89: 
90: Both components share the same promise, so only one fetch occurs. Layout renders immediately while both components wait together.
91: 
92: **When NOT to use this pattern:**
93: 
94: - Critical data needed for layout decisions (affects positioning)
95: - SEO-critical content above the fold
96: - Small, fast queries where suspense overhead isn't worth it
97: - When you want to avoid layout shift (loading ‚Üí content jump)
98: 
99: **Trade-off:** Faster initial paint vs potential layout shift. Choose based on your UX priorities.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/bundle-barrel-imports.md">
 1: ---
 2: title: Avoid Barrel File Imports
 3: impact: CRITICAL
 4: impactDescription: 200-800ms import cost, slow builds
 5: tags: bundle, imports, tree-shaking, barrel-files, performance
 6: ---
 7: 
 8: ## Avoid Barrel File Imports
 9: 
10: Import directly from source files instead of barrel files to avoid loading thousands of unused modules. **Barrel files** are entry points that re-export multiple modules (e.g., `index.js` that does `export * from './module'`).
11: 
12: Popular icon and component libraries can have **up to 10,000 re-exports** in their entry file. For many React packages, **it takes 200-800ms just to import them**, affecting both development speed and production cold starts.
13: 
14: **Why tree-shaking doesn't help:** When a library is marked as external (not bundled), the bundler can't optimize it. If you bundle it to enable tree-shaking, builds become substantially slower analyzing the entire module graph.
15: 
16: **Incorrect (imports entire library):**
17: 
18: ```tsx
19: import { Check, X, Menu } from 'lucide-react'
20: // Loads 1,583 modules, takes ~2.8s extra in dev
21: // Runtime cost: 200-800ms on every cold start
22: 
23: import { Button, TextField } from '@mui/material'
24: // Loads 2,225 modules, takes ~4.2s extra in dev
25: ```
26: 
27: **Correct (imports only what you need):**
28: 
29: ```tsx
30: import Check from 'lucide-react/dist/esm/icons/check'
31: import X from 'lucide-react/dist/esm/icons/x'
32: import Menu from 'lucide-react/dist/esm/icons/menu'
33: // Loads only 3 modules (~2KB vs ~1MB)
34: 
35: import Button from '@mui/material/Button'
36: import TextField from '@mui/material/TextField'
37: // Loads only what you use
38: ```
39: 
40: **Alternative (Next.js 13.5+):**
41: 
42: ```js
43: // next.config.js - use optimizePackageImports
44: module.exports = {
45:   experimental: {
46:     optimizePackageImports: ['lucide-react', '@mui/material']
47:   }
48: }
49: 
50: // Then you can keep the ergonomic barrel imports:
51: import { Check, X, Menu } from 'lucide-react'
52: // Automatically transformed to direct imports at build time
53: ```
54: 
55: Direct imports provide 15-70% faster dev boot, 28% faster builds, 40% faster cold starts, and significantly faster HMR.
56: 
57: Libraries commonly affected: `lucide-react`, `@mui/material`, `@mui/icons-material`, `@tabler/icons-react`, `react-icons`, `@headlessui/react`, `@radix-ui/react-*`, `lodash`, `ramda`, `date-fns`, `rxjs`, `react-use`.
58: 
59: Reference: [How we optimized package imports in Next.js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/bundle-conditional.md">
 1: ---
 2: title: Conditional Module Loading
 3: impact: HIGH
 4: impactDescription: loads large data only when needed
 5: tags: bundle, conditional-loading, lazy-loading
 6: ---
 7: 
 8: ## Conditional Module Loading
 9: 
10: Load large data or modules only when a feature is activated.
11: 
12: **Example (lazy-load animation frames):**
13: 
14: ```tsx
15: function AnimationPlayer({ enabled, setEnabled }: { enabled: boolean; setEnabled: React.Dispatch<React.SetStateAction<boolean>> }) {
16:   const [frames, setFrames] = useState<Frame[] | null>(null)
17: 
18:   useEffect(() => {
19:     if (enabled && !frames && typeof window !== 'undefined') {
20:       import('./animation-frames.js')
21:         .then(mod => setFrames(mod.frames))
22:         .catch(() => setEnabled(false))
23:     }
24:   }, [enabled, frames, setEnabled])
25: 
26:   if (!frames) return <Skeleton />
27:   return <Canvas frames={frames} />
28: }
29: ```
30: 
31: The `typeof window !== 'undefined'` check prevents bundling this module for SSR, optimizing server bundle size and build speed.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/bundle-defer-third-party.md">
 1: ---
 2: title: Defer Non-Critical Third-Party Libraries
 3: impact: MEDIUM
 4: impactDescription: loads after hydration
 5: tags: bundle, third-party, analytics, defer
 6: ---
 7: 
 8: ## Defer Non-Critical Third-Party Libraries
 9: 
10: Analytics, logging, and error tracking don't block user interaction. Load them after hydration.
11: 
12: **Incorrect (blocks initial bundle):**
13: 
14: ```tsx
15: import { Analytics } from '@vercel/analytics/react'
16: 
17: export default function RootLayout({ children }) {
18:   return (
19:     <html>
20:       <body>
21:         {children}
22:         <Analytics />
23:       </body>
24:     </html>
25:   )
26: }
27: ```
28: 
29: **Correct (loads after hydration):**
30: 
31: ```tsx
32: import dynamic from 'next/dynamic'
33: 
34: const Analytics = dynamic(
35:   () => import('@vercel/analytics/react').then(m => m.Analytics),
36:   { ssr: false }
37: )
38: 
39: export default function RootLayout({ children }) {
40:   return (
41:     <html>
42:       <body>
43:         {children}
44:         <Analytics />
45:       </body>
46:     </html>
47:   )
48: }
49: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/bundle-dynamic-imports.md">
 1: ---
 2: title: Dynamic Imports for Heavy Components
 3: impact: CRITICAL
 4: impactDescription: directly affects TTI and LCP
 5: tags: bundle, dynamic-import, code-splitting, next-dynamic
 6: ---
 7: 
 8: ## Dynamic Imports for Heavy Components
 9: 
10: Use `next/dynamic` to lazy-load large components not needed on initial render.
11: 
12: **Incorrect (Monaco bundles with main chunk ~300KB):**
13: 
14: ```tsx
15: import { MonacoEditor } from './monaco-editor'
16: 
17: function CodePanel({ code }: { code: string }) {
18:   return <MonacoEditor value={code} />
19: }
20: ```
21: 
22: **Correct (Monaco loads on demand):**
23: 
24: ```tsx
25: import dynamic from 'next/dynamic'
26: 
27: const MonacoEditor = dynamic(
28:   () => import('./monaco-editor').then(m => m.MonacoEditor),
29:   { ssr: false }
30: )
31: 
32: function CodePanel({ code }: { code: string }) {
33:   return <MonacoEditor value={code} />
34: }
35: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/bundle-preload.md">
 1: ---
 2: title: Preload Based on User Intent
 3: impact: MEDIUM
 4: impactDescription: reduces perceived latency
 5: tags: bundle, preload, user-intent, hover
 6: ---
 7: 
 8: ## Preload Based on User Intent
 9: 
10: Preload heavy bundles before they're needed to reduce perceived latency.
11: 
12: **Example (preload on hover/focus):**
13: 
14: ```tsx
15: function EditorButton({ onClick }: { onClick: () => void }) {
16:   const preload = () => {
17:     if (typeof window !== 'undefined') {
18:       void import('./monaco-editor')
19:     }
20:   }
21: 
22:   return (
23:     <button
24:       onMouseEnter={preload}
25:       onFocus={preload}
26:       onClick={onClick}
27:     >
28:       Open Editor
29:     </button>
30:   )
31: }
32: ```
33: 
34: **Example (preload when feature flag is enabled):**
35: 
36: ```tsx
37: function FlagsProvider({ children, flags }: Props) {
38:   useEffect(() => {
39:     if (flags.editorEnabled && typeof window !== 'undefined') {
40:       void import('./monaco-editor').then(mod => mod.init())
41:     }
42:   }, [flags.editorEnabled])
43: 
44:   return <FlagsContext.Provider value={flags}>
45:     {children}
46:   </FlagsContext.Provider>
47: }
48: ```
49: 
50: The `typeof window !== 'undefined'` check prevents bundling preloaded modules for SSR, optimizing server bundle size and build speed.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/client-event-listeners.md">
 1: ---
 2: title: Deduplicate Global Event Listeners
 3: impact: LOW
 4: impactDescription: single listener for N components
 5: tags: client, swr, event-listeners, subscription
 6: ---
 7: 
 8: ## Deduplicate Global Event Listeners
 9: 
10: Use `useSWRSubscription()` to share global event listeners across component instances.
11: 
12: **Incorrect (N instances = N listeners):**
13: 
14: ```tsx
15: function useKeyboardShortcut(key: string, callback: () => void) {
16:   useEffect(() => {
17:     const handler = (e: KeyboardEvent) => {
18:       if (e.metaKey && e.key === key) {
19:         callback()
20:       }
21:     }
22:     window.addEventListener('keydown', handler)
23:     return () => window.removeEventListener('keydown', handler)
24:   }, [key, callback])
25: }
26: ```
27: 
28: When using the `useKeyboardShortcut` hook multiple times, each instance will register a new listener.
29: 
30: **Correct (N instances = 1 listener):**
31: 
32: ```tsx
33: import useSWRSubscription from 'swr/subscription'
34: 
35: // Module-level Map to track callbacks per key
36: const keyCallbacks = new Map<string, Set<() => void>>()
37: 
38: function useKeyboardShortcut(key: string, callback: () => void) {
39:   // Register this callback in the Map
40:   useEffect(() => {
41:     if (!keyCallbacks.has(key)) {
42:       keyCallbacks.set(key, new Set())
43:     }
44:     keyCallbacks.get(key)!.add(callback)
45: 
46:     return () => {
47:       const set = keyCallbacks.get(key)
48:       if (set) {
49:         set.delete(callback)
50:         if (set.size === 0) {
51:           keyCallbacks.delete(key)
52:         }
53:       }
54:     }
55:   }, [key, callback])
56: 
57:   useSWRSubscription('global-keydown', () => {
58:     const handler = (e: KeyboardEvent) => {
59:       if (e.metaKey && keyCallbacks.has(e.key)) {
60:         keyCallbacks.get(e.key)!.forEach(cb => cb())
61:       }
62:     }
63:     window.addEventListener('keydown', handler)
64:     return () => window.removeEventListener('keydown', handler)
65:   })
66: }
67: 
68: function Profile() {
69:   // Multiple shortcuts will share the same listener
70:   useKeyboardShortcut('p', () => { /* ... */ }) 
71:   useKeyboardShortcut('k', () => { /* ... */ })
72:   // ...
73: }
74: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/client-localstorage-schema.md">
 1: ---
 2: title: Version and Minimize localStorage Data
 3: impact: MEDIUM
 4: impactDescription: prevents schema conflicts, reduces storage size
 5: tags: client, localStorage, storage, versioning, data-minimization
 6: ---
 7: 
 8: ## Version and Minimize localStorage Data
 9: 
10: Add version prefix to keys and store only needed fields. Prevents schema conflicts and accidental storage of sensitive data.
11: 
12: **Incorrect:**
13: 
14: ```typescript
15: // No version, stores everything, no error handling
16: localStorage.setItem('userConfig', JSON.stringify(fullUserObject))
17: const data = localStorage.getItem('userConfig')
18: ```
19: 
20: **Correct:**
21: 
22: ```typescript
23: const VERSION = 'v2'
24: 
25: function saveConfig(config: { theme: string; language: string }) {
26:   try {
27:     localStorage.setItem(`userConfig:${VERSION}`, JSON.stringify(config))
28:   } catch {
29:     // Throws in incognito/private browsing, quota exceeded, or disabled
30:   }
31: }
32: 
33: function loadConfig() {
34:   try {
35:     const data = localStorage.getItem(`userConfig:${VERSION}`)
36:     return data ? JSON.parse(data) : null
37:   } catch {
38:     return null
39:   }
40: }
41: 
42: // Migration from v1 to v2
43: function migrate() {
44:   try {
45:     const v1 = localStorage.getItem('userConfig:v1')
46:     if (v1) {
47:       const old = JSON.parse(v1)
48:       saveConfig({ theme: old.darkMode ? 'dark' : 'light', language: old.lang })
49:       localStorage.removeItem('userConfig:v1')
50:     }
51:   } catch {}
52: }
53: ```
54: 
55: **Store minimal fields from server responses:**
56: 
57: ```typescript
58: // User object has 20+ fields, only store what UI needs
59: function cachePrefs(user: FullUser) {
60:   try {
61:     localStorage.setItem('prefs:v1', JSON.stringify({
62:       theme: user.preferences.theme,
63:       notifications: user.preferences.notifications
64:     }))
65:   } catch {}
66: }
67: ```
68: 
69: **Always wrap in try-catch:** `getItem()` and `setItem()` throw in incognito/private browsing (Safari, Firefox), when quota exceeded, or when disabled.
70: 
71: **Benefits:** Schema evolution via versioning, reduced storage size, prevents storing tokens/PII/internal flags.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/client-passive-event-listeners.md">
 1: ---
 2: title: Use Passive Event Listeners for Scrolling Performance
 3: impact: MEDIUM
 4: impactDescription: eliminates scroll delay caused by event listeners
 5: tags: client, event-listeners, scrolling, performance, touch, wheel
 6: ---
 7: 
 8: ## Use Passive Event Listeners for Scrolling Performance
 9: 
10: Add `{ passive: true }` to touch and wheel event listeners to enable immediate scrolling. Browsers normally wait for listeners to finish to check if `preventDefault()` is called, causing scroll delay.
11: 
12: **Incorrect:**
13: 
14: ```typescript
15: useEffect(() => {
16:   const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)
17:   const handleWheel = (e: WheelEvent) => console.log(e.deltaY)
18:   
19:   document.addEventListener('touchstart', handleTouch)
20:   document.addEventListener('wheel', handleWheel)
21:   
22:   return () => {
23:     document.removeEventListener('touchstart', handleTouch)
24:     document.removeEventListener('wheel', handleWheel)
25:   }
26: }, [])
27: ```
28: 
29: **Correct:**
30: 
31: ```typescript
32: useEffect(() => {
33:   const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)
34:   const handleWheel = (e: WheelEvent) => console.log(e.deltaY)
35:   
36:   document.addEventListener('touchstart', handleTouch, { passive: true })
37:   document.addEventListener('wheel', handleWheel, { passive: true })
38:   
39:   return () => {
40:     document.removeEventListener('touchstart', handleTouch)
41:     document.removeEventListener('wheel', handleWheel)
42:   }
43: }, [])
44: ```
45: 
46: **Use passive when:** tracking/analytics, logging, any listener that doesn't call `preventDefault()`.
47: 
48: **Don't use passive when:** implementing custom swipe gestures, custom zoom controls, or any listener that needs `preventDefault()`.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/client-swr-dedup.md">
 1: ---
 2: title: Use SWR for Automatic Deduplication
 3: impact: MEDIUM-HIGH
 4: impactDescription: automatic deduplication
 5: tags: client, swr, deduplication, data-fetching
 6: ---
 7: 
 8: ## Use SWR for Automatic Deduplication
 9: 
10: SWR enables request deduplication, caching, and revalidation across component instances.
11: 
12: **Incorrect (no deduplication, each instance fetches):**
13: 
14: ```tsx
15: function UserList() {
16:   const [users, setUsers] = useState([])
17:   useEffect(() => {
18:     fetch('/api/users')
19:       .then(r => r.json())
20:       .then(setUsers)
21:   }, [])
22: }
23: ```
24: 
25: **Correct (multiple instances share one request):**
26: 
27: ```tsx
28: import useSWR from 'swr'
29: 
30: function UserList() {
31:   const { data: users } = useSWR('/api/users', fetcher)
32: }
33: ```
34: 
35: **For immutable data:**
36: 
37: ```tsx
38: import { useImmutableSWR } from '@/lib/swr'
39: 
40: function StaticContent() {
41:   const { data } = useImmutableSWR('/api/config', fetcher)
42: }
43: ```
44: 
45: **For mutations:**
46: 
47: ```tsx
48: import { useSWRMutation } from 'swr/mutation'
49: 
50: function UpdateButton() {
51:   const { trigger } = useSWRMutation('/api/user', updateUser)
52:   return <button onClick={() => trigger()}>Update</button>
53: }
54: ```
55: 
56: Reference: [https://swr.vercel.app](https://swr.vercel.app)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-batch-dom-css.md">
  1: ---
  2: title: Avoid Layout Thrashing
  3: impact: MEDIUM
  4: impactDescription: prevents forced synchronous layouts and reduces performance bottlenecks
  5: tags: javascript, dom, css, performance, reflow, layout-thrashing
  6: ---
  7: 
  8: ## Avoid Layout Thrashing
  9: 
 10: Avoid interleaving style writes with layout reads. When you read a layout property (like `offsetWidth`, `getBoundingClientRect()`, or `getComputedStyle()`) between style changes, the browser is forced to trigger a synchronous reflow.
 11: 
 12: **This is OK (browser batches style changes):**
 13: ```typescript
 14: function updateElementStyles(element: HTMLElement) {
 15:   // Each line invalidates style, but browser batches the recalculation
 16:   element.style.width = '100px'
 17:   element.style.height = '200px'
 18:   element.style.backgroundColor = 'blue'
 19:   element.style.border = '1px solid black'
 20: }
 21: ```
 22: 
 23: **Incorrect (interleaved reads and writes force reflows):**
 24: ```typescript
 25: function layoutThrashing(element: HTMLElement) {
 26:   element.style.width = '100px'
 27:   const width = element.offsetWidth  // Forces reflow
 28:   element.style.height = '200px'
 29:   const height = element.offsetHeight  // Forces another reflow
 30: }
 31: ```
 32: 
 33: **Correct (batch writes, then read once):**
 34: ```typescript
 35: function updateElementStyles(element: HTMLElement) {
 36:   // Batch all writes together
 37:   element.style.width = '100px'
 38:   element.style.height = '200px'
 39:   element.style.backgroundColor = 'blue'
 40:   element.style.border = '1px solid black'
 41:   
 42:   // Read after all writes are done (single reflow)
 43:   const { width, height } = element.getBoundingClientRect()
 44: }
 45: ```
 46: 
 47: **Correct (batch reads, then writes):**
 48: ```typescript
 49: function avoidThrashing(element: HTMLElement) {
 50:   // Read phase - all layout queries first
 51:   const rect1 = element.getBoundingClientRect()
 52:   const offsetWidth = element.offsetWidth
 53:   const offsetHeight = element.offsetHeight
 54:   
 55:   // Write phase - all style changes after
 56:   element.style.width = '100px'
 57:   element.style.height = '200px'
 58: }
 59: ```
 60: 
 61: **Better: use CSS classes**
 62: ```css
 63: .highlighted-box {
 64:   width: 100px;
 65:   height: 200px;
 66:   background-color: blue;
 67:   border: 1px solid black;
 68: }
 69: ```
 70: ```typescript
 71: function updateElementStyles(element: HTMLElement) {
 72:   element.classList.add('highlighted-box')
 73:   
 74:   const { width, height } = element.getBoundingClientRect()
 75: }
 76: ```
 77: 
 78: **React example:**
 79: ```tsx
 80: // Incorrect: interleaving style changes with layout queries
 81: function Box({ isHighlighted }: { isHighlighted: boolean }) {
 82:   const ref = useRef<HTMLDivElement>(null)
 83:   
 84:   useEffect(() => {
 85:     if (ref.current && isHighlighted) {
 86:       ref.current.style.width = '100px'
 87:       const width = ref.current.offsetWidth // Forces layout
 88:       ref.current.style.height = '200px'
 89:     }
 90:   }, [isHighlighted])
 91:   
 92:   return <div ref={ref}>Content</div>
 93: }
 94: 
 95: // Correct: toggle class
 96: function Box({ isHighlighted }: { isHighlighted: boolean }) {
 97:   return (
 98:     <div className={isHighlighted ? 'highlighted-box' : ''}>
 99:       Content
100:     </div>
101:   )
102: }
103: ```
104: 
105: Prefer CSS classes over inline styles when possible. CSS files are cached by the browser, and classes provide better separation of concerns and are easier to maintain.
106: 
107: See [this gist](https://gist.github.com/paulirish/5d52fb081b3570c81e3a) and [CSS Triggers](https://csstriggers.com/) for more information on layout-forcing operations.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-cache-function-results.md">
 1: ---
 2: title: Cache Repeated Function Calls
 3: impact: MEDIUM
 4: impactDescription: avoid redundant computation
 5: tags: javascript, cache, memoization, performance
 6: ---
 7: 
 8: ## Cache Repeated Function Calls
 9: 
10: Use a module-level Map to cache function results when the same function is called repeatedly with the same inputs during render.
11: 
12: **Incorrect (redundant computation):**
13: 
14: ```typescript
15: function ProjectList({ projects }: { projects: Project[] }) {
16:   return (
17:     <div>
18:       {projects.map(project => {
19:         // slugify() called 100+ times for same project names
20:         const slug = slugify(project.name)
21:         
22:         return <ProjectCard key={project.id} slug={slug} />
23:       })}
24:     </div>
25:   )
26: }
27: ```
28: 
29: **Correct (cached results):**
30: 
31: ```typescript
32: // Module-level cache
33: const slugifyCache = new Map<string, string>()
34: 
35: function cachedSlugify(text: string): string {
36:   if (slugifyCache.has(text)) {
37:     return slugifyCache.get(text)!
38:   }
39:   const result = slugify(text)
40:   slugifyCache.set(text, result)
41:   return result
42: }
43: 
44: function ProjectList({ projects }: { projects: Project[] }) {
45:   return (
46:     <div>
47:       {projects.map(project => {
48:         // Computed only once per unique project name
49:         const slug = cachedSlugify(project.name)
50:         
51:         return <ProjectCard key={project.id} slug={slug} />
52:       })}
53:     </div>
54:   )
55: }
56: ```
57: 
58: **Simpler pattern for single-value functions:**
59: 
60: ```typescript
61: let isLoggedInCache: boolean | null = null
62: 
63: function isLoggedIn(): boolean {
64:   if (isLoggedInCache !== null) {
65:     return isLoggedInCache
66:   }
67:   
68:   isLoggedInCache = document.cookie.includes('auth=')
69:   return isLoggedInCache
70: }
71: 
72: // Clear cache when auth changes
73: function onAuthChange() {
74:   isLoggedInCache = null
75: }
76: ```
77: 
78: Use a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.
79: 
80: Reference: [How we made the Vercel Dashboard twice as fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-cache-property-access.md">
 1: ---
 2: title: Cache Property Access in Loops
 3: impact: LOW-MEDIUM
 4: impactDescription: reduces lookups
 5: tags: javascript, loops, optimization, caching
 6: ---
 7: 
 8: ## Cache Property Access in Loops
 9: 
10: Cache object property lookups in hot paths.
11: 
12: **Incorrect (3 lookups √ó N iterations):**
13: 
14: ```typescript
15: for (let i = 0; i < arr.length; i++) {
16:   process(obj.config.settings.value)
17: }
18: ```
19: 
20: **Correct (1 lookup total):**
21: 
22: ```typescript
23: const value = obj.config.settings.value
24: const len = arr.length
25: for (let i = 0; i < len; i++) {
26:   process(value)
27: }
28: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-cache-storage.md">
 1: ---
 2: title: Cache Storage API Calls
 3: impact: LOW-MEDIUM
 4: impactDescription: reduces expensive I/O
 5: tags: javascript, localStorage, storage, caching, performance
 6: ---
 7: 
 8: ## Cache Storage API Calls
 9: 
10: `localStorage`, `sessionStorage`, and `document.cookie` are synchronous and expensive. Cache reads in memory.
11: 
12: **Incorrect (reads storage on every call):**
13: 
14: ```typescript
15: function getTheme() {
16:   return localStorage.getItem('theme') ?? 'light'
17: }
18: // Called 10 times = 10 storage reads
19: ```
20: 
21: **Correct (Map cache):**
22: 
23: ```typescript
24: const storageCache = new Map<string, string | null>()
25: 
26: function getLocalStorage(key: string) {
27:   if (!storageCache.has(key)) {
28:     storageCache.set(key, localStorage.getItem(key))
29:   }
30:   return storageCache.get(key)
31: }
32: 
33: function setLocalStorage(key: string, value: string) {
34:   localStorage.setItem(key, value)
35:   storageCache.set(key, value)  // keep cache in sync
36: }
37: ```
38: 
39: Use a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.
40: 
41: **Cookie caching:**
42: 
43: ```typescript
44: let cookieCache: Record<string, string> | null = null
45: 
46: function getCookie(name: string) {
47:   if (!cookieCache) {
48:     cookieCache = Object.fromEntries(
49:       document.cookie.split('; ').map(c => c.split('='))
50:     )
51:   }
52:   return cookieCache[name]
53: }
54: ```
55: 
56: **Important (invalidate on external changes):**
57: 
58: If storage can change externally (another tab, server-set cookies), invalidate cache:
59: 
60: ```typescript
61: window.addEventListener('storage', (e) => {
62:   if (e.key) storageCache.delete(e.key)
63: })
64: 
65: document.addEventListener('visibilitychange', () => {
66:   if (document.visibilityState === 'visible') {
67:     storageCache.clear()
68:   }
69: })
70: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-combine-iterations.md">
 1: ---
 2: title: Combine Multiple Array Iterations
 3: impact: LOW-MEDIUM
 4: impactDescription: reduces iterations
 5: tags: javascript, arrays, loops, performance
 6: ---
 7: 
 8: ## Combine Multiple Array Iterations
 9: 
10: Multiple `.filter()` or `.map()` calls iterate the array multiple times. Combine into one loop.
11: 
12: **Incorrect (3 iterations):**
13: 
14: ```typescript
15: const admins = users.filter(u => u.isAdmin)
16: const testers = users.filter(u => u.isTester)
17: const inactive = users.filter(u => !u.isActive)
18: ```
19: 
20: **Correct (1 iteration):**
21: 
22: ```typescript
23: const admins: User[] = []
24: const testers: User[] = []
25: const inactive: User[] = []
26: 
27: for (const user of users) {
28:   if (user.isAdmin) admins.push(user)
29:   if (user.isTester) testers.push(user)
30:   if (!user.isActive) inactive.push(user)
31: }
32: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-early-exit.md">
 1: ---
 2: title: Early Return from Functions
 3: impact: LOW-MEDIUM
 4: impactDescription: avoids unnecessary computation
 5: tags: javascript, functions, optimization, early-return
 6: ---
 7: 
 8: ## Early Return from Functions
 9: 
10: Return early when result is determined to skip unnecessary processing.
11: 
12: **Incorrect (processes all items even after finding answer):**
13: 
14: ```typescript
15: function validateUsers(users: User[]) {
16:   let hasError = false
17:   let errorMessage = ''
18:   
19:   for (const user of users) {
20:     if (!user.email) {
21:       hasError = true
22:       errorMessage = 'Email required'
23:     }
24:     if (!user.name) {
25:       hasError = true
26:       errorMessage = 'Name required'
27:     }
28:     // Continues checking all users even after error found
29:   }
30:   
31:   return hasError ? { valid: false, error: errorMessage } : { valid: true }
32: }
33: ```
34: 
35: **Correct (returns immediately on first error):**
36: 
37: ```typescript
38: function validateUsers(users: User[]) {
39:   for (const user of users) {
40:     if (!user.email) {
41:       return { valid: false, error: 'Email required' }
42:     }
43:     if (!user.name) {
44:       return { valid: false, error: 'Name required' }
45:     }
46:   }
47: 
48:   return { valid: true }
49: }
50: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-hoist-regexp.md">
 1: ---
 2: title: Hoist RegExp Creation
 3: impact: LOW-MEDIUM
 4: impactDescription: avoids recreation
 5: tags: javascript, regexp, optimization, memoization
 6: ---
 7: 
 8: ## Hoist RegExp Creation
 9: 
10: Don't create RegExp inside render. Hoist to module scope or memoize with `useMemo()`.
11: 
12: **Incorrect (new RegExp every render):**
13: 
14: ```tsx
15: function Highlighter({ text, query }: Props) {
16:   const regex = new RegExp(`(${query})`, 'gi')
17:   const parts = text.split(regex)
18:   return <>{parts.map((part, i) => ...)}</>
19: }
20: ```
21: 
22: **Correct (memoize or hoist):**
23: 
24: ```tsx
25: const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
26: 
27: function Highlighter({ text, query }: Props) {
28:   const regex = useMemo(
29:     () => new RegExp(`(${escapeRegex(query)})`, 'gi'),
30:     [query]
31:   )
32:   const parts = text.split(regex)
33:   return <>{parts.map((part, i) => ...)}</>
34: }
35: ```
36: 
37: **Warning (global regex has mutable state):**
38: 
39: Global regex (`/g`) has mutable `lastIndex` state:
40: 
41: ```typescript
42: const regex = /foo/g
43: regex.test('foo')  // true, lastIndex = 3
44: regex.test('foo')  // false, lastIndex = 0
45: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-index-maps.md">
 1: ---
 2: title: Build Index Maps for Repeated Lookups
 3: impact: LOW-MEDIUM
 4: impactDescription: 1M ops to 2K ops
 5: tags: javascript, map, indexing, optimization, performance
 6: ---
 7: 
 8: ## Build Index Maps for Repeated Lookups
 9: 
10: Multiple `.find()` calls by the same key should use a Map.
11: 
12: **Incorrect (O(n) per lookup):**
13: 
14: ```typescript
15: function processOrders(orders: Order[], users: User[]) {
16:   return orders.map(order => ({
17:     ...order,
18:     user: users.find(u => u.id === order.userId)
19:   }))
20: }
21: ```
22: 
23: **Correct (O(1) per lookup):**
24: 
25: ```typescript
26: function processOrders(orders: Order[], users: User[]) {
27:   const userById = new Map(users.map(u => [u.id, u]))
28: 
29:   return orders.map(order => ({
30:     ...order,
31:     user: userById.get(order.userId)
32:   }))
33: }
34: ```
35: 
36: Build map once (O(n)), then all lookups are O(1).
37: For 1000 orders √ó 1000 users: 1M ops ‚Üí 2K ops.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-length-check-first.md">
 1: ---
 2: title: Early Length Check for Array Comparisons
 3: impact: MEDIUM-HIGH
 4: impactDescription: avoids expensive operations when lengths differ
 5: tags: javascript, arrays, performance, optimization, comparison
 6: ---
 7: 
 8: ## Early Length Check for Array Comparisons
 9: 
10: When comparing arrays with expensive operations (sorting, deep equality, serialization), check lengths first. If lengths differ, the arrays cannot be equal.
11: 
12: In real-world applications, this optimization is especially valuable when the comparison runs in hot paths (event handlers, render loops).
13: 
14: **Incorrect (always runs expensive comparison):**
15: 
16: ```typescript
17: function hasChanges(current: string[], original: string[]) {
18:   // Always sorts and joins, even when lengths differ
19:   return current.sort().join() !== original.sort().join()
20: }
21: ```
22: 
23: Two O(n log n) sorts run even when `current.length` is 5 and `original.length` is 100. There is also overhead of joining the arrays and comparing the strings.
24: 
25: **Correct (O(1) length check first):**
26: 
27: ```typescript
28: function hasChanges(current: string[], original: string[]) {
29:   // Early return if lengths differ
30:   if (current.length !== original.length) {
31:     return true
32:   }
33:   // Only sort when lengths match
34:   const currentSorted = current.toSorted()
35:   const originalSorted = original.toSorted()
36:   for (let i = 0; i < currentSorted.length; i++) {
37:     if (currentSorted[i] !== originalSorted[i]) {
38:       return true
39:     }
40:   }
41:   return false
42: }
43: ```
44: 
45: This new approach is more efficient because:
46: - It avoids the overhead of sorting and joining the arrays when lengths differ
47: - It avoids consuming memory for the joined strings (especially important for large arrays)
48: - It avoids mutating the original arrays
49: - It returns early when a difference is found
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-min-max-loop.md">
 1: ---
 2: title: Use Loop for Min/Max Instead of Sort
 3: impact: LOW
 4: impactDescription: O(n) instead of O(n log n)
 5: tags: javascript, arrays, performance, sorting, algorithms
 6: ---
 7: 
 8: ## Use Loop for Min/Max Instead of Sort
 9: 
10: Finding the smallest or largest element only requires a single pass through the array. Sorting is wasteful and slower.
11: 
12: **Incorrect (O(n log n) - sort to find latest):**
13: 
14: ```typescript
15: interface Project {
16:   id: string
17:   name: string
18:   updatedAt: number
19: }
20: 
21: function getLatestProject(projects: Project[]) {
22:   const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)
23:   return sorted[0]
24: }
25: ```
26: 
27: Sorts the entire array just to find the maximum value.
28: 
29: **Incorrect (O(n log n) - sort for oldest and newest):**
30: 
31: ```typescript
32: function getOldestAndNewest(projects: Project[]) {
33:   const sorted = [...projects].sort((a, b) => a.updatedAt - b.updatedAt)
34:   return { oldest: sorted[0], newest: sorted[sorted.length - 1] }
35: }
36: ```
37: 
38: Still sorts unnecessarily when only min/max are needed.
39: 
40: **Correct (O(n) - single loop):**
41: 
42: ```typescript
43: function getLatestProject(projects: Project[]) {
44:   if (projects.length === 0) return null
45:   
46:   let latest = projects[0]
47:   
48:   for (let i = 1; i < projects.length; i++) {
49:     if (projects[i].updatedAt > latest.updatedAt) {
50:       latest = projects[i]
51:     }
52:   }
53:   
54:   return latest
55: }
56: 
57: function getOldestAndNewest(projects: Project[]) {
58:   if (projects.length === 0) return { oldest: null, newest: null }
59:   
60:   let oldest = projects[0]
61:   let newest = projects[0]
62:   
63:   for (let i = 1; i < projects.length; i++) {
64:     if (projects[i].updatedAt < oldest.updatedAt) oldest = projects[i]
65:     if (projects[i].updatedAt > newest.updatedAt) newest = projects[i]
66:   }
67:   
68:   return { oldest, newest }
69: }
70: ```
71: 
72: Single pass through the array, no copying, no sorting.
73: 
74: **Alternative (Math.min/Math.max for small arrays):**
75: 
76: ```typescript
77: const numbers = [5, 2, 8, 1, 9]
78: const min = Math.min(...numbers)
79: const max = Math.max(...numbers)
80: ```
81: 
82: This works for small arrays, but can be slower or just throw an error for very large arrays due to spread operator limitations. Maximal array length is approximately 124000 in Chrome 143 and 638000 in Safari 18; exact numbers may vary - see [the fiddle](https://jsfiddle.net/qw1jabsx/4/). Use the loop approach for reliability.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-set-map-lookups.md">
 1: ---
 2: title: Use Set/Map for O(1) Lookups
 3: impact: LOW-MEDIUM
 4: impactDescription: O(n) to O(1)
 5: tags: javascript, set, map, data-structures, performance
 6: ---
 7: 
 8: ## Use Set/Map for O(1) Lookups
 9: 
10: Convert arrays to Set/Map for repeated membership checks.
11: 
12: **Incorrect (O(n) per check):**
13: 
14: ```typescript
15: const allowedIds = ['a', 'b', 'c', ...]
16: items.filter(item => allowedIds.includes(item.id))
17: ```
18: 
19: **Correct (O(1) per check):**
20: 
21: ```typescript
22: const allowedIds = new Set(['a', 'b', 'c', ...])
23: items.filter(item => allowedIds.has(item.id))
24: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/js-tosorted-immutable.md">
 1: ---
 2: title: Use toSorted() Instead of sort() for Immutability
 3: impact: MEDIUM-HIGH
 4: impactDescription: prevents mutation bugs in React state
 5: tags: javascript, arrays, immutability, react, state, mutation
 6: ---
 7: 
 8: ## Use toSorted() Instead of sort() for Immutability
 9: 
10: `.sort()` mutates the array in place, which can cause bugs with React state and props. Use `.toSorted()` to create a new sorted array without mutation.
11: 
12: **Incorrect (mutates original array):**
13: 
14: ```typescript
15: function UserList({ users }: { users: User[] }) {
16:   // Mutates the users prop array!
17:   const sorted = useMemo(
18:     () => users.sort((a, b) => a.name.localeCompare(b.name)),
19:     [users]
20:   )
21:   return <div>{sorted.map(renderUser)}</div>
22: }
23: ```
24: 
25: **Correct (creates new array):**
26: 
27: ```typescript
28: function UserList({ users }: { users: User[] }) {
29:   // Creates new sorted array, original unchanged
30:   const sorted = useMemo(
31:     () => users.toSorted((a, b) => a.name.localeCompare(b.name)),
32:     [users]
33:   )
34:   return <div>{sorted.map(renderUser)}</div>
35: }
36: ```
37: 
38: **Why this matters in React:**
39: 
40: 1. Props/state mutations break React's immutability model - React expects props and state to be treated as read-only
41: 2. Causes stale closure bugs - Mutating arrays inside closures (callbacks, effects) can lead to unexpected behavior
42: 
43: **Browser support (fallback for older browsers):**
44: 
45: `.toSorted()` is available in all modern browsers (Chrome 110+, Safari 16+, Firefox 115+, Node.js 20+). For older environments, use spread operator:
46: 
47: ```typescript
48: // Fallback for older browsers
49: const sorted = [...items].sort((a, b) => a.value - b.value)
50: ```
51: 
52: **Other immutable array methods:**
53: 
54: - `.toSorted()` - immutable sort
55: - `.toReversed()` - immutable reverse
56: - `.toSpliced()` - immutable splice
57: - `.with()` - immutable element replacement
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-activity.md">
 1: ---
 2: title: Use Activity Component for Show/Hide
 3: impact: MEDIUM
 4: impactDescription: preserves state/DOM
 5: tags: rendering, activity, visibility, state-preservation
 6: ---
 7: 
 8: ## Use Activity Component for Show/Hide
 9: 
10: Use React's `<Activity>` to preserve state/DOM for expensive components that frequently toggle visibility.
11: 
12: **Usage:**
13: 
14: ```tsx
15: import { Activity } from 'react'
16: 
17: function Dropdown({ isOpen }: Props) {
18:   return (
19:     <Activity mode={isOpen ? 'visible' : 'hidden'}>
20:       <ExpensiveMenu />
21:     </Activity>
22:   )
23: }
24: ```
25: 
26: Avoids expensive re-renders and state loss.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-animate-svg-wrapper.md">
 1: ---
 2: title: Animate SVG Wrapper Instead of SVG Element
 3: impact: LOW
 4: impactDescription: enables hardware acceleration
 5: tags: rendering, svg, css, animation, performance
 6: ---
 7: 
 8: ## Animate SVG Wrapper Instead of SVG Element
 9: 
10: Many browsers don't have hardware acceleration for CSS3 animations on SVG elements. Wrap SVG in a `<div>` and animate the wrapper instead.
11: 
12: **Incorrect (animating SVG directly - no hardware acceleration):**
13: 
14: ```tsx
15: function LoadingSpinner() {
16:   return (
17:     <svg 
18:       className="animate-spin"
19:       width="24" 
20:       height="24" 
21:       viewBox="0 0 24 24"
22:     >
23:       <circle cx="12" cy="12" r="10" stroke="currentColor" />
24:     </svg>
25:   )
26: }
27: ```
28: 
29: **Correct (animating wrapper div - hardware accelerated):**
30: 
31: ```tsx
32: function LoadingSpinner() {
33:   return (
34:     <div className="animate-spin">
35:       <svg 
36:         width="24" 
37:         height="24" 
38:         viewBox="0 0 24 24"
39:       >
40:         <circle cx="12" cy="12" r="10" stroke="currentColor" />
41:       </svg>
42:     </div>
43:   )
44: }
45: ```
46: 
47: This applies to all CSS transforms and transitions (`transform`, `opacity`, `translate`, `scale`, `rotate`). The wrapper div allows browsers to use GPU acceleration for smoother animations.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-conditional-render.md">
 1: ---
 2: title: Use Explicit Conditional Rendering
 3: impact: LOW
 4: impactDescription: prevents rendering 0 or NaN
 5: tags: rendering, conditional, jsx, falsy-values
 6: ---
 7: 
 8: ## Use Explicit Conditional Rendering
 9: 
10: Use explicit ternary operators (`? :`) instead of `&&` for conditional rendering when the condition can be `0`, `NaN`, or other falsy values that render.
11: 
12: **Incorrect (renders "0" when count is 0):**
13: 
14: ```tsx
15: function Badge({ count }: { count: number }) {
16:   return (
17:     <div>
18:       {count && <span className="badge">{count}</span>}
19:     </div>
20:   )
21: }
22: 
23: // When count = 0, renders: <div>0</div>
24: // When count = 5, renders: <div><span class="badge">5</span></div>
25: ```
26: 
27: **Correct (renders nothing when count is 0):**
28: 
29: ```tsx
30: function Badge({ count }: { count: number }) {
31:   return (
32:     <div>
33:       {count > 0 ? <span className="badge">{count}</span> : null}
34:     </div>
35:   )
36: }
37: 
38: // When count = 0, renders: <div></div>
39: // When count = 5, renders: <div><span class="badge">5</span></div>
40: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-content-visibility.md">
 1: ---
 2: title: CSS content-visibility for Long Lists
 3: impact: HIGH
 4: impactDescription: faster initial render
 5: tags: rendering, css, content-visibility, long-lists
 6: ---
 7: 
 8: ## CSS content-visibility for Long Lists
 9: 
10: Apply `content-visibility: auto` to defer off-screen rendering.
11: 
12: **CSS:**
13: 
14: ```css
15: .message-item {
16:   content-visibility: auto;
17:   contain-intrinsic-size: 0 80px;
18: }
19: ```
20: 
21: **Example:**
22: 
23: ```tsx
24: function MessageList({ messages }: { messages: Message[] }) {
25:   return (
26:     <div className="overflow-y-auto h-screen">
27:       {messages.map(msg => (
28:         <div key={msg.id} className="message-item">
29:           <Avatar user={msg.author} />
30:           <div>{msg.content}</div>
31:         </div>
32:       ))}
33:     </div>
34:   )
35: }
36: ```
37: 
38: For 1000 messages, browser skips layout/paint for ~990 off-screen items (10√ó faster initial render).
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-hoist-jsx.md">
 1: ---
 2: title: Hoist Static JSX Elements
 3: impact: LOW
 4: impactDescription: avoids re-creation
 5: tags: rendering, jsx, static, optimization
 6: ---
 7: 
 8: ## Hoist Static JSX Elements
 9: 
10: Extract static JSX outside components to avoid re-creation.
11: 
12: **Incorrect (recreates element every render):**
13: 
14: ```tsx
15: function LoadingSkeleton() {
16:   return <div className="animate-pulse h-20 bg-gray-200" />
17: }
18: 
19: function Container() {
20:   return (
21:     <div>
22:       {loading && <LoadingSkeleton />}
23:     </div>
24:   )
25: }
26: ```
27: 
28: **Correct (reuses same element):**
29: 
30: ```tsx
31: const loadingSkeleton = (
32:   <div className="animate-pulse h-20 bg-gray-200" />
33: )
34: 
35: function Container() {
36:   return (
37:     <div>
38:       {loading && loadingSkeleton}
39:     </div>
40:   )
41: }
42: ```
43: 
44: This is especially helpful for large and static SVG nodes, which can be expensive to recreate on every render.
45: 
46: **Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler automatically hoists static JSX elements and optimizes component re-renders, making manual hoisting unnecessary.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-hydration-no-flicker.md">
 1: ---
 2: title: Prevent Hydration Mismatch Without Flickering
 3: impact: MEDIUM
 4: impactDescription: avoids visual flicker and hydration errors
 5: tags: rendering, ssr, hydration, localStorage, flicker
 6: ---
 7: 
 8: ## Prevent Hydration Mismatch Without Flickering
 9: 
10: When rendering content that depends on client-side storage (localStorage, cookies), avoid both SSR breakage and post-hydration flickering by injecting a synchronous script that updates the DOM before React hydrates.
11: 
12: **Incorrect (breaks SSR):**
13: 
14: ```tsx
15: function ThemeWrapper({ children }: { children: ReactNode }) {
16:   // localStorage is not available on server - throws error
17:   const theme = localStorage.getItem('theme') || 'light'
18:   
19:   return (
20:     <div className={theme}>
21:       {children}
22:     </div>
23:   )
24: }
25: ```
26: 
27: Server-side rendering will fail because `localStorage` is undefined.
28: 
29: **Incorrect (visual flickering):**
30: 
31: ```tsx
32: function ThemeWrapper({ children }: { children: ReactNode }) {
33:   const [theme, setTheme] = useState('light')
34:   
35:   useEffect(() => {
36:     // Runs after hydration - causes visible flash
37:     const stored = localStorage.getItem('theme')
38:     if (stored) {
39:       setTheme(stored)
40:     }
41:   }, [])
42:   
43:   return (
44:     <div className={theme}>
45:       {children}
46:     </div>
47:   )
48: }
49: ```
50: 
51: Component first renders with default value (`light`), then updates after hydration, causing a visible flash of incorrect content.
52: 
53: **Correct (no flicker, no hydration mismatch):**
54: 
55: ```tsx
56: function ThemeWrapper({ children }: { children: ReactNode }) {
57:   return (
58:     <>
59:       <div id="theme-wrapper">
60:         {children}
61:       </div>
62:       <script
63:         dangerouslySetInnerHTML={{
64:           __html: `
65:             (function() {
66:               try {
67:                 var theme = localStorage.getItem('theme') || 'light';
68:                 var el = document.getElementById('theme-wrapper');
69:                 if (el) el.className = theme;
70:               } catch (e) {}
71:             })();
72:           `,
73:         }}
74:       />
75:     </>
76:   )
77: }
78: ```
79: 
80: The inline script executes synchronously before showing the element, ensuring the DOM already has the correct value. No flickering, no hydration mismatch.
81: 
82: This pattern is especially useful for theme toggles, user preferences, authentication states, and any client-only data that should render immediately without flashing default values.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-hydration-suppress-warning.md">
 1: ---
 2: title: Suppress Expected Hydration Mismatches
 3: impact: LOW-MEDIUM
 4: impactDescription: avoids noisy hydration warnings for known differences
 5: tags: rendering, hydration, ssr, nextjs
 6: ---
 7: 
 8: ## Suppress Expected Hydration Mismatches
 9: 
10: In SSR frameworks (e.g., Next.js), some values are intentionally different on server vs client (random IDs, dates, locale/timezone formatting). For these *expected* mismatches, wrap the dynamic text in an element with `suppressHydrationWarning` to prevent noisy warnings. Do not use this to hide real bugs. Don‚Äôt overuse it.
11: 
12: **Incorrect (known mismatch warnings):**
13: 
14: ```tsx
15: function Timestamp() {
16:   return <span>{new Date().toLocaleString()}</span>
17: }
18: ```
19: 
20: **Correct (suppress expected mismatch only):**
21: 
22: ```tsx
23: function Timestamp() {
24:   return (
25:     <span suppressHydrationWarning>
26:       {new Date().toLocaleString()}
27:     </span>
28:   )
29: }
30: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-svg-precision.md">
 1: ---
 2: title: Optimize SVG Precision
 3: impact: LOW
 4: impactDescription: reduces file size
 5: tags: rendering, svg, optimization, svgo
 6: ---
 7: 
 8: ## Optimize SVG Precision
 9: 
10: Reduce SVG coordinate precision to decrease file size. The optimal precision depends on the viewBox size, but in general reducing precision should be considered.
11: 
12: **Incorrect (excessive precision):**
13: 
14: ```svg
15: <path d="M 10.293847 20.847362 L 30.938472 40.192837" />
16: ```
17: 
18: **Correct (1 decimal place):**
19: 
20: ```svg
21: <path d="M 10.3 20.8 L 30.9 40.2" />
22: ```
23: 
24: **Automate with SVGO:**
25: 
26: ```bash
27: npx svgo --precision=1 --multipass icon.svg
28: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rendering-usetransition-loading.md">
 1: ---
 2: title: Use useTransition Over Manual Loading States
 3: impact: LOW
 4: impactDescription: reduces re-renders and improves code clarity
 5: tags: rendering, transitions, useTransition, loading, state
 6: ---
 7: 
 8: ## Use useTransition Over Manual Loading States
 9: 
10: Use `useTransition` instead of manual `useState` for loading states. This provides built-in `isPending` state and automatically manages transitions.
11: 
12: **Incorrect (manual loading state):**
13: 
14: ```tsx
15: function SearchResults() {
16:   const [query, setQuery] = useState('')
17:   const [results, setResults] = useState([])
18:   const [isLoading, setIsLoading] = useState(false)
19: 
20:   const handleSearch = async (value: string) => {
21:     setIsLoading(true)
22:     setQuery(value)
23:     const data = await fetchResults(value)
24:     setResults(data)
25:     setIsLoading(false)
26:   }
27: 
28:   return (
29:     <>
30:       <input onChange={(e) => handleSearch(e.target.value)} />
31:       {isLoading && <Spinner />}
32:       <ResultsList results={results} />
33:     </>
34:   )
35: }
36: ```
37: 
38: **Correct (useTransition with built-in pending state):**
39: 
40: ```tsx
41: import { useTransition, useState } from 'react'
42: 
43: function SearchResults() {
44:   const [query, setQuery] = useState('')
45:   const [results, setResults] = useState([])
46:   const [isPending, startTransition] = useTransition()
47: 
48:   const handleSearch = (value: string) => {
49:     setQuery(value) // Update input immediately
50:     
51:     startTransition(async () => {
52:       // Fetch and update results
53:       const data = await fetchResults(value)
54:       setResults(data)
55:     })
56:   }
57: 
58:   return (
59:     <>
60:       <input onChange={(e) => handleSearch(e.target.value)} />
61:       {isPending && <Spinner />}
62:       <ResultsList results={results} />
63:     </>
64:   )
65: }
66: ```
67: 
68: **Benefits:**
69: 
70: - **Automatic pending state**: No need to manually manage `setIsLoading(true/false)`
71: - **Error resilience**: Pending state correctly resets even if the transition throws
72: - **Better responsiveness**: Keeps the UI responsive during updates
73: - **Interrupt handling**: New transitions automatically cancel pending ones
74: 
75: Reference: [useTransition](https://react.dev/reference/react/useTransition)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-defer-reads.md">
 1: ---
 2: title: Defer State Reads to Usage Point
 3: impact: MEDIUM
 4: impactDescription: avoids unnecessary subscriptions
 5: tags: rerender, searchParams, localStorage, optimization
 6: ---
 7: 
 8: ## Defer State Reads to Usage Point
 9: 
10: Don't subscribe to dynamic state (searchParams, localStorage) if you only read it inside callbacks.
11: 
12: **Incorrect (subscribes to all searchParams changes):**
13: 
14: ```tsx
15: function ShareButton({ chatId }: { chatId: string }) {
16:   const searchParams = useSearchParams()
17: 
18:   const handleShare = () => {
19:     const ref = searchParams.get('ref')
20:     shareChat(chatId, { ref })
21:   }
22: 
23:   return <button onClick={handleShare}>Share</button>
24: }
25: ```
26: 
27: **Correct (reads on demand, no subscription):**
28: 
29: ```tsx
30: function ShareButton({ chatId }: { chatId: string }) {
31:   const handleShare = () => {
32:     const params = new URLSearchParams(window.location.search)
33:     const ref = params.get('ref')
34:     shareChat(chatId, { ref })
35:   }
36: 
37:   return <button onClick={handleShare}>Share</button>
38: }
39: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-dependencies.md">
 1: ---
 2: title: Narrow Effect Dependencies
 3: impact: LOW
 4: impactDescription: minimizes effect re-runs
 5: tags: rerender, useEffect, dependencies, optimization
 6: ---
 7: 
 8: ## Narrow Effect Dependencies
 9: 
10: Specify primitive dependencies instead of objects to minimize effect re-runs.
11: 
12: **Incorrect (re-runs on any user field change):**
13: 
14: ```tsx
15: useEffect(() => {
16:   console.log(user.id)
17: }, [user])
18: ```
19: 
20: **Correct (re-runs only when id changes):**
21: 
22: ```tsx
23: useEffect(() => {
24:   console.log(user.id)
25: }, [user.id])
26: ```
27: 
28: **For derived state, compute outside effect:**
29: 
30: ```tsx
31: // Incorrect: runs on width=767, 766, 765...
32: useEffect(() => {
33:   if (width < 768) {
34:     enableMobileMode()
35:   }
36: }, [width])
37: 
38: // Correct: runs only on boolean transition
39: const isMobile = width < 768
40: useEffect(() => {
41:   if (isMobile) {
42:     enableMobileMode()
43:   }
44: }, [isMobile])
45: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-derived-state-no-effect.md">
 1: ---
 2: title: Calculate Derived State During Rendering
 3: impact: MEDIUM
 4: impactDescription: avoids redundant renders and state drift
 5: tags: rerender, derived-state, useEffect, state
 6: ---
 7: 
 8: ## Calculate Derived State During Rendering
 9: 
10: If a value can be computed from current props/state, do not store it in state or update it in an effect. Derive it during render to avoid extra renders and state drift. Do not set state in effects solely in response to prop changes; prefer derived values or keyed resets instead.
11: 
12: **Incorrect (redundant state and effect):**
13: 
14: ```tsx
15: function Form() {
16:   const [firstName, setFirstName] = useState('First')
17:   const [lastName, setLastName] = useState('Last')
18:   const [fullName, setFullName] = useState('')
19: 
20:   useEffect(() => {
21:     setFullName(firstName + ' ' + lastName)
22:   }, [firstName, lastName])
23: 
24:   return <p>{fullName}</p>
25: }
26: ```
27: 
28: **Correct (derive during render):**
29: 
30: ```tsx
31: function Form() {
32:   const [firstName, setFirstName] = useState('First')
33:   const [lastName, setLastName] = useState('Last')
34:   const fullName = firstName + ' ' + lastName
35: 
36:   return <p>{fullName}</p>
37: }
38: ```
39: 
40: References: [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-derived-state.md">
 1: ---
 2: title: Subscribe to Derived State
 3: impact: MEDIUM
 4: impactDescription: reduces re-render frequency
 5: tags: rerender, derived-state, media-query, optimization
 6: ---
 7: 
 8: ## Subscribe to Derived State
 9: 
10: Subscribe to derived boolean state instead of continuous values to reduce re-render frequency.
11: 
12: **Incorrect (re-renders on every pixel change):**
13: 
14: ```tsx
15: function Sidebar() {
16:   const width = useWindowWidth()  // updates continuously
17:   const isMobile = width < 768
18:   return <nav className={isMobile ? 'mobile' : 'desktop'} />
19: }
20: ```
21: 
22: **Correct (re-renders only when boolean changes):**
23: 
24: ```tsx
25: function Sidebar() {
26:   const isMobile = useMediaQuery('(max-width: 767px)')
27:   return <nav className={isMobile ? 'mobile' : 'desktop'} />
28: }
29: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-functional-setstate.md">
 1: ---
 2: title: Use Functional setState Updates
 3: impact: MEDIUM
 4: impactDescription: prevents stale closures and unnecessary callback recreations
 5: tags: react, hooks, useState, useCallback, callbacks, closures
 6: ---
 7: 
 8: ## Use Functional setState Updates
 9: 
10: When updating state based on the current state value, use the functional update form of setState instead of directly referencing the state variable. This prevents stale closures, eliminates unnecessary dependencies, and creates stable callback references.
11: 
12: **Incorrect (requires state as dependency):**
13: 
14: ```tsx
15: function TodoList() {
16:   const [items, setItems] = useState(initialItems)
17:   
18:   // Callback must depend on items, recreated on every items change
19:   const addItems = useCallback((newItems: Item[]) => {
20:     setItems([...items, ...newItems])
21:   }, [items])  // ‚ùå items dependency causes recreations
22:   
23:   // Risk of stale closure if dependency is forgotten
24:   const removeItem = useCallback((id: string) => {
25:     setItems(items.filter(item => item.id !== id))
26:   }, [])  // ‚ùå Missing items dependency - will use stale items!
27:   
28:   return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />
29: }
30: ```
31: 
32: The first callback is recreated every time `items` changes, which can cause child components to re-render unnecessarily. The second callback has a stale closure bug‚Äîit will always reference the initial `items` value.
33: 
34: **Correct (stable callbacks, no stale closures):**
35: 
36: ```tsx
37: function TodoList() {
38:   const [items, setItems] = useState(initialItems)
39:   
40:   // Stable callback, never recreated
41:   const addItems = useCallback((newItems: Item[]) => {
42:     setItems(curr => [...curr, ...newItems])
43:   }, [])  // ‚úÖ No dependencies needed
44:   
45:   // Always uses latest state, no stale closure risk
46:   const removeItem = useCallback((id: string) => {
47:     setItems(curr => curr.filter(item => item.id !== id))
48:   }, [])  // ‚úÖ Safe and stable
49:   
50:   return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />
51: }
52: ```
53: 
54: **Benefits:**
55: 
56: 1. **Stable callback references** - Callbacks don't need to be recreated when state changes
57: 2. **No stale closures** - Always operates on the latest state value
58: 3. **Fewer dependencies** - Simplifies dependency arrays and reduces memory leaks
59: 4. **Prevents bugs** - Eliminates the most common source of React closure bugs
60: 
61: **When to use functional updates:**
62: 
63: - Any setState that depends on the current state value
64: - Inside useCallback/useMemo when state is needed
65: - Event handlers that reference state
66: - Async operations that update state
67: 
68: **When direct updates are fine:**
69: 
70: - Setting state to a static value: `setCount(0)`
71: - Setting state from props/arguments only: `setName(newName)`
72: - State doesn't depend on previous value
73: 
74: **Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler can automatically optimize some cases, but functional updates are still recommended for correctness and to prevent stale closure bugs.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-lazy-state-init.md">
 1: ---
 2: title: Use Lazy State Initialization
 3: impact: MEDIUM
 4: impactDescription: wasted computation on every render
 5: tags: react, hooks, useState, performance, initialization
 6: ---
 7: 
 8: ## Use Lazy State Initialization
 9: 
10: Pass a function to `useState` for expensive initial values. Without the function form, the initializer runs on every render even though the value is only used once.
11: 
12: **Incorrect (runs on every render):**
13: 
14: ```tsx
15: function FilteredList({ items }: { items: Item[] }) {
16:   // buildSearchIndex() runs on EVERY render, even after initialization
17:   const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))
18:   const [query, setQuery] = useState('')
19:   
20:   // When query changes, buildSearchIndex runs again unnecessarily
21:   return <SearchResults index={searchIndex} query={query} />
22: }
23: 
24: function UserProfile() {
25:   // JSON.parse runs on every render
26:   const [settings, setSettings] = useState(
27:     JSON.parse(localStorage.getItem('settings') || '{}')
28:   )
29:   
30:   return <SettingsForm settings={settings} onChange={setSettings} />
31: }
32: ```
33: 
34: **Correct (runs only once):**
35: 
36: ```tsx
37: function FilteredList({ items }: { items: Item[] }) {
38:   // buildSearchIndex() runs ONLY on initial render
39:   const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))
40:   const [query, setQuery] = useState('')
41:   
42:   return <SearchResults index={searchIndex} query={query} />
43: }
44: 
45: function UserProfile() {
46:   // JSON.parse runs only on initial render
47:   const [settings, setSettings] = useState(() => {
48:     const stored = localStorage.getItem('settings')
49:     return stored ? JSON.parse(stored) : {}
50:   })
51:   
52:   return <SettingsForm settings={settings} onChange={setSettings} />
53: }
54: ```
55: 
56: Use lazy initialization when computing initial values from localStorage/sessionStorage, building data structures (indexes, maps), reading from the DOM, or performing heavy transformations.
57: 
58: For simple primitives (`useState(0)`), direct references (`useState(props.value)`), or cheap literals (`useState({})`), the function form is unnecessary.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-memo-with-default-value.md">
 1: ---
 2: 
 3: title: Extract Default Non-primitive Parameter Value from Memoized Component to Constant
 4: impact: MEDIUM
 5: impactDescription: restores memoization by using a constant for default value
 6: tags: rerender, memo, optimization
 7: 
 8: ---
 9: 
10: ## Extract Default Non-primitive Parameter Value from Memoized Component to Constant
11: 
12: When memoized component has a default value for some non-primitive optional parameter, such as an array, function, or object, calling the component without that parameter results in broken memoization. This is because new value instances are created on every rerender, and they do not pass strict equality comparison in `memo()`.
13: 
14: To address this issue, extract the default value into a constant.
15: 
16: **Incorrect (`onClick` has different values on every rerender):**
17: 
18: ```tsx
19: const UserAvatar = memo(function UserAvatar({ onClick = () => {} }: { onClick?: () => void }) {
20:   // ...
21: })
22: 
23: // Used without optional onClick
24: <UserAvatar />
25: ```
26: 
27: **Correct (stable default value):**
28: 
29: ```tsx
30: const NOOP = () => {};
31: 
32: const UserAvatar = memo(function UserAvatar({ onClick = NOOP }: { onClick?: () => void }) {
33:   // ...
34: })
35: 
36: // Used without optional onClick
37: <UserAvatar />
38: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-memo.md">
 1: ---
 2: title: Extract to Memoized Components
 3: impact: MEDIUM
 4: impactDescription: enables early returns
 5: tags: rerender, memo, useMemo, optimization
 6: ---
 7: 
 8: ## Extract to Memoized Components
 9: 
10: Extract expensive work into memoized components to enable early returns before computation.
11: 
12: **Incorrect (computes avatar even when loading):**
13: 
14: ```tsx
15: function Profile({ user, loading }: Props) {
16:   const avatar = useMemo(() => {
17:     const id = computeAvatarId(user)
18:     return <Avatar id={id} />
19:   }, [user])
20: 
21:   if (loading) return <Skeleton />
22:   return <div>{avatar}</div>
23: }
24: ```
25: 
26: **Correct (skips computation when loading):**
27: 
28: ```tsx
29: const UserAvatar = memo(function UserAvatar({ user }: { user: User }) {
30:   const id = useMemo(() => computeAvatarId(user), [user])
31:   return <Avatar id={id} />
32: })
33: 
34: function Profile({ user, loading }: Props) {
35:   if (loading) return <Skeleton />
36:   return (
37:     <div>
38:       <UserAvatar user={user} />
39:     </div>
40:   )
41: }
42: ```
43: 
44: **Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, manual memoization with `memo()` and `useMemo()` is not necessary. The compiler automatically optimizes re-renders.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-move-effect-to-event.md">
 1: ---
 2: title: Put Interaction Logic in Event Handlers
 3: impact: MEDIUM
 4: impactDescription: avoids effect re-runs and duplicate side effects
 5: tags: rerender, useEffect, events, side-effects, dependencies
 6: ---
 7: 
 8: ## Put Interaction Logic in Event Handlers
 9: 
10: If a side effect is triggered by a specific user action (submit, click, drag), run it in that event handler. Do not model the action as state + effect; it makes effects re-run on unrelated changes and can duplicate the action.
11: 
12: **Incorrect (event modeled as state + effect):**
13: 
14: ```tsx
15: function Form() {
16:   const [submitted, setSubmitted] = useState(false)
17:   const theme = useContext(ThemeContext)
18: 
19:   useEffect(() => {
20:     if (submitted) {
21:       post('/api/register')
22:       showToast('Registered', theme)
23:     }
24:   }, [submitted, theme])
25: 
26:   return <button onClick={() => setSubmitted(true)}>Submit</button>
27: }
28: ```
29: 
30: **Correct (do it in the handler):**
31: 
32: ```tsx
33: function Form() {
34:   const theme = useContext(ThemeContext)
35: 
36:   function handleSubmit() {
37:     post('/api/register')
38:     showToast('Registered', theme)
39:   }
40: 
41:   return <button onClick={handleSubmit}>Submit</button>
42: }
43: ```
44: 
45: Reference: [Should this code move to an event handler?](https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-simple-expression-in-memo.md">
 1: ---
 2: title: Do not wrap a simple expression with a primitive result type in useMemo
 3: impact: LOW-MEDIUM
 4: impactDescription: wasted computation on every render
 5: tags: rerender, useMemo, optimization
 6: ---
 7: 
 8: ## Do not wrap a simple expression with a primitive result type in useMemo
 9: 
10: When an expression is simple (few logical or arithmetical operators) and has a primitive result type (boolean, number, string), do not wrap it in `useMemo`.
11: Calling `useMemo` and comparing hook dependencies may consume more resources than the expression itself.
12: 
13: **Incorrect:**
14: 
15: ```tsx
16: function Header({ user, notifications }: Props) {
17:   const isLoading = useMemo(() => {
18:     return user.isLoading || notifications.isLoading
19:   }, [user.isLoading, notifications.isLoading])
20: 
21:   if (isLoading) return <Skeleton />
22:   // return some markup
23: }
24: ```
25: 
26: **Correct:**
27: 
28: ```tsx
29: function Header({ user, notifications }: Props) {
30:   const isLoading = user.isLoading || notifications.isLoading
31: 
32:   if (isLoading) return <Skeleton />
33:   // return some markup
34: }
35: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-transitions.md">
 1: ---
 2: title: Use Transitions for Non-Urgent Updates
 3: impact: MEDIUM
 4: impactDescription: maintains UI responsiveness
 5: tags: rerender, transitions, startTransition, performance
 6: ---
 7: 
 8: ## Use Transitions for Non-Urgent Updates
 9: 
10: Mark frequent, non-urgent state updates as transitions to maintain UI responsiveness.
11: 
12: **Incorrect (blocks UI on every scroll):**
13: 
14: ```tsx
15: function ScrollTracker() {
16:   const [scrollY, setScrollY] = useState(0)
17:   useEffect(() => {
18:     const handler = () => setScrollY(window.scrollY)
19:     window.addEventListener('scroll', handler, { passive: true })
20:     return () => window.removeEventListener('scroll', handler)
21:   }, [])
22: }
23: ```
24: 
25: **Correct (non-blocking updates):**
26: 
27: ```tsx
28: import { startTransition } from 'react'
29: 
30: function ScrollTracker() {
31:   const [scrollY, setScrollY] = useState(0)
32:   useEffect(() => {
33:     const handler = () => {
34:       startTransition(() => setScrollY(window.scrollY))
35:     }
36:     window.addEventListener('scroll', handler, { passive: true })
37:     return () => window.removeEventListener('scroll', handler)
38:   }, [])
39: }
40: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/rerender-use-ref-transient-values.md">
 1: ---
 2: title: Use useRef for Transient Values
 3: impact: MEDIUM
 4: impactDescription: avoids unnecessary re-renders on frequent updates
 5: tags: rerender, useref, state, performance
 6: ---
 7: 
 8: ## Use useRef for Transient Values
 9: 
10: When a value changes frequently and you don't want a re-render on every update (e.g., mouse trackers, intervals, transient flags), store it in `useRef` instead of `useState`. Keep component state for UI; use refs for temporary DOM-adjacent values. Updating a ref does not trigger a re-render.
11: 
12: **Incorrect (renders every update):**
13: 
14: ```tsx
15: function Tracker() {
16:   const [lastX, setLastX] = useState(0)
17: 
18:   useEffect(() => {
19:     const onMove = (e: MouseEvent) => setLastX(e.clientX)
20:     window.addEventListener('mousemove', onMove)
21:     return () => window.removeEventListener('mousemove', onMove)
22:   }, [])
23: 
24:   return (
25:     <div
26:       style={{
27:         position: 'fixed',
28:         top: 0,
29:         left: lastX,
30:         width: 8,
31:         height: 8,
32:         background: 'black',
33:       }}
34:     />
35:   )
36: }
37: ```
38: 
39: **Correct (no re-render for tracking):**
40: 
41: ```tsx
42: function Tracker() {
43:   const lastXRef = useRef(0)
44:   const dotRef = useRef<HTMLDivElement>(null)
45: 
46:   useEffect(() => {
47:     const onMove = (e: MouseEvent) => {
48:       lastXRef.current = e.clientX
49:       const node = dotRef.current
50:       if (node) {
51:         node.style.transform = `translateX(${e.clientX}px)`
52:       }
53:     }
54:     window.addEventListener('mousemove', onMove)
55:     return () => window.removeEventListener('mousemove', onMove)
56:   }, [])
57: 
58:   return (
59:     <div
60:       ref={dotRef}
61:       style={{
62:         position: 'fixed',
63:         top: 0,
64:         left: 0,
65:         width: 8,
66:         height: 8,
67:         background: 'black',
68:         transform: 'translateX(0px)',
69:       }}
70:     />
71:   )
72: }
73: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-after-nonblocking.md">
 1: ---
 2: title: Use after() for Non-Blocking Operations
 3: impact: MEDIUM
 4: impactDescription: faster response times
 5: tags: server, async, logging, analytics, side-effects
 6: ---
 7: 
 8: ## Use after() for Non-Blocking Operations
 9: 
10: Use Next.js's `after()` to schedule work that should execute after a response is sent. This prevents logging, analytics, and other side effects from blocking the response.
11: 
12: **Incorrect (blocks response):**
13: 
14: ```tsx
15: import { logUserAction } from '@/app/utils'
16: 
17: export async function POST(request: Request) {
18:   // Perform mutation
19:   await updateDatabase(request)
20:   
21:   // Logging blocks the response
22:   const userAgent = request.headers.get('user-agent') || 'unknown'
23:   await logUserAction({ userAgent })
24:   
25:   return new Response(JSON.stringify({ status: 'success' }), {
26:     status: 200,
27:     headers: { 'Content-Type': 'application/json' }
28:   })
29: }
30: ```
31: 
32: **Correct (non-blocking):**
33: 
34: ```tsx
35: import { after } from 'next/server'
36: import { headers, cookies } from 'next/headers'
37: import { logUserAction } from '@/app/utils'
38: 
39: export async function POST(request: Request) {
40:   // Perform mutation
41:   await updateDatabase(request)
42:   
43:   // Log after response is sent
44:   after(async () => {
45:     const userAgent = (await headers()).get('user-agent') || 'unknown'
46:     const sessionCookie = (await cookies()).get('session-id')?.value || 'anonymous'
47:     
48:     logUserAction({ sessionCookie, userAgent })
49:   })
50:   
51:   return new Response(JSON.stringify({ status: 'success' }), {
52:     status: 200,
53:     headers: { 'Content-Type': 'application/json' }
54:   })
55: }
56: ```
57: 
58: The response is sent immediately while logging happens in the background.
59: 
60: **Common use cases:**
61: 
62: - Analytics tracking
63: - Audit logging
64: - Sending notifications
65: - Cache invalidation
66: - Cleanup tasks
67: 
68: **Important notes:**
69: 
70: - `after()` runs even if the response fails or redirects
71: - Works in Server Actions, Route Handlers, and Server Components
72: 
73: Reference: [https://nextjs.org/docs/app/api-reference/functions/after](https://nextjs.org/docs/app/api-reference/functions/after)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-auth-actions.md">
 1: ---
 2: title: Authenticate Server Actions Like API Routes
 3: impact: CRITICAL
 4: impactDescription: prevents unauthorized access to server mutations
 5: tags: server, server-actions, authentication, security, authorization
 6: ---
 7: 
 8: ## Authenticate Server Actions Like API Routes
 9: 
10: **Impact: CRITICAL (prevents unauthorized access to server mutations)**
11: 
12: Server Actions (functions with `"use server"`) are exposed as public endpoints, just like API routes. Always verify authentication and authorization **inside** each Server Action‚Äîdo not rely solely on middleware, layout guards, or page-level checks, as Server Actions can be invoked directly.
13: 
14: Next.js documentation explicitly states: "Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation."
15: 
16: **Incorrect (no authentication check):**
17: 
18: ```typescript
19: 'use server'
20: 
21: export async function deleteUser(userId: string) {
22:   // Anyone can call this! No auth check
23:   await db.user.delete({ where: { id: userId } })
24:   return { success: true }
25: }
26: ```
27: 
28: **Correct (authentication inside the action):**
29: 
30: ```typescript
31: 'use server'
32: 
33: import { verifySession } from '@/lib/auth'
34: import { unauthorized } from '@/lib/errors'
35: 
36: export async function deleteUser(userId: string) {
37:   // Always check auth inside the action
38:   const session = await verifySession()
39:   
40:   if (!session) {
41:     throw unauthorized('Must be logged in')
42:   }
43:   
44:   // Check authorization too
45:   if (session.user.role !== 'admin' && session.user.id !== userId) {
46:     throw unauthorized('Cannot delete other users')
47:   }
48:   
49:   await db.user.delete({ where: { id: userId } })
50:   return { success: true }
51: }
52: ```
53: 
54: **With input validation:**
55: 
56: ```typescript
57: 'use server'
58: 
59: import { verifySession } from '@/lib/auth'
60: import { z } from 'zod'
61: 
62: const updateProfileSchema = z.object({
63:   userId: z.string().uuid(),
64:   name: z.string().min(1).max(100),
65:   email: z.string().email()
66: })
67: 
68: export async function updateProfile(data: unknown) {
69:   // Validate input first
70:   const validated = updateProfileSchema.parse(data)
71:   
72:   // Then authenticate
73:   const session = await verifySession()
74:   if (!session) {
75:     throw new Error('Unauthorized')
76:   }
77:   
78:   // Then authorize
79:   if (session.user.id !== validated.userId) {
80:     throw new Error('Can only update own profile')
81:   }
82:   
83:   // Finally perform the mutation
84:   await db.user.update({
85:     where: { id: validated.userId },
86:     data: {
87:       name: validated.name,
88:       email: validated.email
89:     }
90:   })
91:   
92:   return { success: true }
93: }
94: ```
95: 
96: Reference: [https://nextjs.org/docs/app/guides/authentication](https://nextjs.org/docs/app/guides/authentication)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-cache-lru.md">
 1: ---
 2: title: Cross-Request LRU Caching
 3: impact: HIGH
 4: impactDescription: caches across requests
 5: tags: server, cache, lru, cross-request
 6: ---
 7: 
 8: ## Cross-Request LRU Caching
 9: 
10: `React.cache()` only works within one request. For data shared across sequential requests (user clicks button A then button B), use an LRU cache.
11: 
12: **Implementation:**
13: 
14: ```typescript
15: import { LRUCache } from 'lru-cache'
16: 
17: const cache = new LRUCache<string, any>({
18:   max: 1000,
19:   ttl: 5 * 60 * 1000  // 5 minutes
20: })
21: 
22: export async function getUser(id: string) {
23:   const cached = cache.get(id)
24:   if (cached) return cached
25: 
26:   const user = await db.user.findUnique({ where: { id } })
27:   cache.set(id, user)
28:   return user
29: }
30: 
31: // Request 1: DB query, result cached
32: // Request 2: cache hit, no DB query
33: ```
34: 
35: Use when sequential user actions hit multiple endpoints needing the same data within seconds.
36: 
37: **With Vercel's [Fluid Compute](https://vercel.com/docs/fluid-compute):** LRU caching is especially effective because multiple concurrent requests can share the same function instance and cache. This means the cache persists across requests without needing external storage like Redis.
38: 
39: **In traditional serverless:** Each invocation runs in isolation, so consider Redis for cross-process caching.
40: 
41: Reference: [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-cache-react.md">
 1: ---
 2: title: Per-Request Deduplication with React.cache()
 3: impact: MEDIUM
 4: impactDescription: deduplicates within request
 5: tags: server, cache, react-cache, deduplication
 6: ---
 7: 
 8: ## Per-Request Deduplication with React.cache()
 9: 
10: Use `React.cache()` for server-side request deduplication. Authentication and database queries benefit most.
11: 
12: **Usage:**
13: 
14: ```typescript
15: import { cache } from 'react'
16: 
17: export const getCurrentUser = cache(async () => {
18:   const session = await auth()
19:   if (!session?.user?.id) return null
20:   return await db.user.findUnique({
21:     where: { id: session.user.id }
22:   })
23: })
24: ```
25: 
26: Within a single request, multiple calls to `getCurrentUser()` execute the query only once.
27: 
28: **Avoid inline objects as arguments:**
29: 
30: `React.cache()` uses shallow equality (`Object.is`) to determine cache hits. Inline objects create new references each call, preventing cache hits.
31: 
32: **Incorrect (always cache miss):**
33: 
34: ```typescript
35: const getUser = cache(async (params: { uid: number }) => {
36:   return await db.user.findUnique({ where: { id: params.uid } })
37: })
38: 
39: // Each call creates new object, never hits cache
40: getUser({ uid: 1 })
41: getUser({ uid: 1 })  // Cache miss, runs query again
42: ```
43: 
44: **Correct (cache hit):**
45: 
46: ```typescript
47: const getUser = cache(async (uid: number) => {
48:   return await db.user.findUnique({ where: { id: uid } })
49: })
50: 
51: // Primitive args use value equality
52: getUser(1)
53: getUser(1)  // Cache hit, returns cached result
54: ```
55: 
56: If you must pass objects, pass the same reference:
57: 
58: ```typescript
59: const params = { uid: 1 }
60: getUser(params)  // Query runs
61: getUser(params)  // Cache hit (same reference)
62: ```
63: 
64: **Next.js-Specific Note:**
65: 
66: In Next.js, the `fetch` API is automatically extended with request memoization. Requests with the same URL and options are automatically deduplicated within a single request, so you don't need `React.cache()` for `fetch` calls. However, `React.cache()` is still essential for other async tasks:
67: 
68: - Database queries (Prisma, Drizzle, etc.)
69: - Heavy computations
70: - Authentication checks
71: - File system operations
72: - Any non-fetch async work
73: 
74: Use `React.cache()` to deduplicate these operations across your component tree.
75: 
76: Reference: [React.cache documentation](https://react.dev/reference/react/cache)
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-dedup-props.md">
 1: ---
 2: title: Avoid Duplicate Serialization in RSC Props
 3: impact: LOW
 4: impactDescription: reduces network payload by avoiding duplicate serialization
 5: tags: server, rsc, serialization, props, client-components
 6: ---
 7: 
 8: ## Avoid Duplicate Serialization in RSC Props
 9: 
10: **Impact: LOW (reduces network payload by avoiding duplicate serialization)**
11: 
12: RSC‚Üíclient serialization deduplicates by object reference, not value. Same reference = serialized once; new reference = serialized again. Do transformations (`.toSorted()`, `.filter()`, `.map()`) in client, not server.
13: 
14: **Incorrect (duplicates array):**
15: 
16: ```tsx
17: // RSC: sends 6 strings (2 arrays √ó 3 items)
18: <ClientList usernames={usernames} usernamesOrdered={usernames.toSorted()} />
19: ```
20: 
21: **Correct (sends 3 strings):**
22: 
23: ```tsx
24: // RSC: send once
25: <ClientList usernames={usernames} />
26: 
27: // Client: transform there
28: 'use client'
29: const sorted = useMemo(() => [...usernames].sort(), [usernames])
30: ```
31: 
32: **Nested deduplication behavior:**
33: 
34: Deduplication works recursively. Impact varies by data type:
35: 
36: - `string[]`, `number[]`, `boolean[]`: **HIGH impact** - array + all primitives fully duplicated
37: - `object[]`: **LOW impact** - array duplicated, but nested objects deduplicated by reference
38: 
39: ```tsx
40: // string[] - duplicates everything
41: usernames={['a','b']} sorted={usernames.toSorted()} // sends 4 strings
42: 
43: // object[] - duplicates array structure only
44: users={[{id:1},{id:2}]} sorted={users.toSorted()} // sends 2 arrays + 2 unique objects (not 4)
45: ```
46: 
47: **Operations breaking deduplication (create new references):**
48: 
49: - Arrays: `.toSorted()`, `.filter()`, `.map()`, `.slice()`, `[...arr]`
50: - Objects: `{...obj}`, `Object.assign()`, `structuredClone()`, `JSON.parse(JSON.stringify())`
51: 
52: **More examples:**
53: 
54: ```tsx
55: // ‚ùå Bad
56: <C users={users} active={users.filter(u => u.active)} />
57: <C product={product} productName={product.name} />
58: 
59: // ‚úÖ Good
60: <C users={users} />
61: <C product={product} />
62: // Do filtering/destructuring in client
63: ```
64: 
65: **Exception:** Pass derived data when transformation is expensive or client doesn't need original.
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-parallel-fetching.md">
 1: ---
 2: title: Parallel Data Fetching with Component Composition
 3: impact: CRITICAL
 4: impactDescription: eliminates server-side waterfalls
 5: tags: server, rsc, parallel-fetching, composition
 6: ---
 7: 
 8: ## Parallel Data Fetching with Component Composition
 9: 
10: React Server Components execute sequentially within a tree. Restructure with composition to parallelize data fetching.
11: 
12: **Incorrect (Sidebar waits for Page's fetch to complete):**
13: 
14: ```tsx
15: export default async function Page() {
16:   const header = await fetchHeader()
17:   return (
18:     <div>
19:       <div>{header}</div>
20:       <Sidebar />
21:     </div>
22:   )
23: }
24: 
25: async function Sidebar() {
26:   const items = await fetchSidebarItems()
27:   return <nav>{items.map(renderItem)}</nav>
28: }
29: ```
30: 
31: **Correct (both fetch simultaneously):**
32: 
33: ```tsx
34: async function Header() {
35:   const data = await fetchHeader()
36:   return <div>{data}</div>
37: }
38: 
39: async function Sidebar() {
40:   const items = await fetchSidebarItems()
41:   return <nav>{items.map(renderItem)}</nav>
42: }
43: 
44: export default function Page() {
45:   return (
46:     <div>
47:       <Header />
48:       <Sidebar />
49:     </div>
50:   )
51: }
52: ```
53: 
54: **Alternative with children prop:**
55: 
56: ```tsx
57: async function Header() {
58:   const data = await fetchHeader()
59:   return <div>{data}</div>
60: }
61: 
62: async function Sidebar() {
63:   const items = await fetchSidebarItems()
64:   return <nav>{items.map(renderItem)}</nav>
65: }
66: 
67: function Layout({ children }: { children: ReactNode }) {
68:   return (
69:     <div>
70:       <Header />
71:       {children}
72:     </div>
73:   )
74: }
75: 
76: export default function Page() {
77:   return (
78:     <Layout>
79:       <Sidebar />
80:     </Layout>
81:   )
82: }
83: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/rules/server-serialization.md">
 1: ---
 2: title: Minimize Serialization at RSC Boundaries
 3: impact: HIGH
 4: impactDescription: reduces data transfer size
 5: tags: server, rsc, serialization, props
 6: ---
 7: 
 8: ## Minimize Serialization at RSC Boundaries
 9: 
10: The React Server/Client boundary serializes all object properties into strings and embeds them in the HTML response and subsequent RSC requests. This serialized data directly impacts page weight and load time, so **size matters a lot**. Only pass fields that the client actually uses.
11: 
12: **Incorrect (serializes all 50 fields):**
13: 
14: ```tsx
15: async function Page() {
16:   const user = await fetchUser()  // 50 fields
17:   return <Profile user={user} />
18: }
19: 
20: 'use client'
21: function Profile({ user }: { user: User }) {
22:   return <div>{user.name}</div>  // uses 1 field
23: }
24: ```
25: 
26: **Correct (serializes only 1 field):**
27: 
28: ```tsx
29: async function Page() {
30:   const user = await fetchUser()
31:   return <Profile name={user.name} />
32: }
33: 
34: 'use client'
35: function Profile({ name }: { name: string }) {
36:   return <div>{name}</div>
37: }
38: ```
</file>

<file path=".agents/skills/vercel-react-best-practices/AGENTS.md">
   1: # React Best Practices
   2: 
   3: **Version 1.0.0**  
   4: Vercel Engineering  
   5: January 2026
   6: 
   7: > **Note:**  
   8: > This document is mainly for agents and LLMs to follow when maintaining,  
   9: > generating, or refactoring React and Next.js codebases. Humans  
  10: > may also find it useful, but guidance here is optimized for automation  
  11: > and consistency by AI-assisted workflows.
  12: 
  13: ---
  14: 
  15: ## Abstract
  16: 
  17: Comprehensive performance optimization guide for React and Next.js applications, designed for AI agents and LLMs. Contains 40+ rules across 8 categories, prioritized by impact from critical (eliminating waterfalls, reducing bundle size) to incremental (advanced patterns). Each rule includes detailed explanations, real-world examples comparing incorrect vs. correct implementations, and specific impact metrics to guide automated refactoring and code generation.
  18: 
  19: ---
  20: 
  21: ## Table of Contents
  22: 
  23: 1. [Eliminating Waterfalls](#1-eliminating-waterfalls) ‚Äî **CRITICAL**
  24:    - 1.1 [Defer Await Until Needed](#11-defer-await-until-needed)
  25:    - 1.2 [Dependency-Based Parallelization](#12-dependency-based-parallelization)
  26:    - 1.3 [Prevent Waterfall Chains in API Routes](#13-prevent-waterfall-chains-in-api-routes)
  27:    - 1.4 [Promise.all() for Independent Operations](#14-promiseall-for-independent-operations)
  28:    - 1.5 [Strategic Suspense Boundaries](#15-strategic-suspense-boundaries)
  29: 2. [Bundle Size Optimization](#2-bundle-size-optimization) ‚Äî **CRITICAL**
  30:    - 2.1 [Avoid Barrel File Imports](#21-avoid-barrel-file-imports)
  31:    - 2.2 [Conditional Module Loading](#22-conditional-module-loading)
  32:    - 2.3 [Defer Non-Critical Third-Party Libraries](#23-defer-non-critical-third-party-libraries)
  33:    - 2.4 [Dynamic Imports for Heavy Components](#24-dynamic-imports-for-heavy-components)
  34:    - 2.5 [Preload Based on User Intent](#25-preload-based-on-user-intent)
  35: 3. [Server-Side Performance](#3-server-side-performance) ‚Äî **HIGH**
  36:    - 3.1 [Authenticate Server Actions Like API Routes](#31-authenticate-server-actions-like-api-routes)
  37:    - 3.2 [Avoid Duplicate Serialization in RSC Props](#32-avoid-duplicate-serialization-in-rsc-props)
  38:    - 3.3 [Cross-Request LRU Caching](#33-cross-request-lru-caching)
  39:    - 3.4 [Minimize Serialization at RSC Boundaries](#34-minimize-serialization-at-rsc-boundaries)
  40:    - 3.5 [Parallel Data Fetching with Component Composition](#35-parallel-data-fetching-with-component-composition)
  41:    - 3.6 [Per-Request Deduplication with React.cache()](#36-per-request-deduplication-with-reactcache)
  42:    - 3.7 [Use after() for Non-Blocking Operations](#37-use-after-for-non-blocking-operations)
  43: 4. [Client-Side Data Fetching](#4-client-side-data-fetching) ‚Äî **MEDIUM-HIGH**
  44:    - 4.1 [Deduplicate Global Event Listeners](#41-deduplicate-global-event-listeners)
  45:    - 4.2 [Use Passive Event Listeners for Scrolling Performance](#42-use-passive-event-listeners-for-scrolling-performance)
  46:    - 4.3 [Use SWR for Automatic Deduplication](#43-use-swr-for-automatic-deduplication)
  47:    - 4.4 [Version and Minimize localStorage Data](#44-version-and-minimize-localstorage-data)
  48: 5. [Re-render Optimization](#5-re-render-optimization) ‚Äî **MEDIUM**
  49:    - 5.1 [Calculate Derived State During Rendering](#51-calculate-derived-state-during-rendering)
  50:    - 5.2 [Defer State Reads to Usage Point](#52-defer-state-reads-to-usage-point)
  51:    - 5.3 [Do not wrap a simple expression with a primitive result type in useMemo](#53-do-not-wrap-a-simple-expression-with-a-primitive-result-type-in-usememo)
  52:    - 5.4 [Extract Default Non-primitive Parameter Value from Memoized Component to Constant](#54-extract-default-non-primitive-parameter-value-from-memoized-component-to-constant)
  53:    - 5.5 [Extract to Memoized Components](#55-extract-to-memoized-components)
  54:    - 5.6 [Narrow Effect Dependencies](#56-narrow-effect-dependencies)
  55:    - 5.7 [Put Interaction Logic in Event Handlers](#57-put-interaction-logic-in-event-handlers)
  56:    - 5.8 [Subscribe to Derived State](#58-subscribe-to-derived-state)
  57:    - 5.9 [Use Functional setState Updates](#59-use-functional-setstate-updates)
  58:    - 5.10 [Use Lazy State Initialization](#510-use-lazy-state-initialization)
  59:    - 5.11 [Use Transitions for Non-Urgent Updates](#511-use-transitions-for-non-urgent-updates)
  60:    - 5.12 [Use useRef for Transient Values](#512-use-useref-for-transient-values)
  61: 6. [Rendering Performance](#6-rendering-performance) ‚Äî **MEDIUM**
  62:    - 6.1 [Animate SVG Wrapper Instead of SVG Element](#61-animate-svg-wrapper-instead-of-svg-element)
  63:    - 6.2 [CSS content-visibility for Long Lists](#62-css-content-visibility-for-long-lists)
  64:    - 6.3 [Hoist Static JSX Elements](#63-hoist-static-jsx-elements)
  65:    - 6.4 [Optimize SVG Precision](#64-optimize-svg-precision)
  66:    - 6.5 [Prevent Hydration Mismatch Without Flickering](#65-prevent-hydration-mismatch-without-flickering)
  67:    - 6.6 [Suppress Expected Hydration Mismatches](#66-suppress-expected-hydration-mismatches)
  68:    - 6.7 [Use Activity Component for Show/Hide](#67-use-activity-component-for-showhide)
  69:    - 6.8 [Use Explicit Conditional Rendering](#68-use-explicit-conditional-rendering)
  70:    - 6.9 [Use useTransition Over Manual Loading States](#69-use-usetransition-over-manual-loading-states)
  71: 7. [JavaScript Performance](#7-javascript-performance) ‚Äî **LOW-MEDIUM**
  72:    - 7.1 [Avoid Layout Thrashing](#71-avoid-layout-thrashing)
  73:    - 7.2 [Build Index Maps for Repeated Lookups](#72-build-index-maps-for-repeated-lookups)
  74:    - 7.3 [Cache Property Access in Loops](#73-cache-property-access-in-loops)
  75:    - 7.4 [Cache Repeated Function Calls](#74-cache-repeated-function-calls)
  76:    - 7.5 [Cache Storage API Calls](#75-cache-storage-api-calls)
  77:    - 7.6 [Combine Multiple Array Iterations](#76-combine-multiple-array-iterations)
  78:    - 7.7 [Early Length Check for Array Comparisons](#77-early-length-check-for-array-comparisons)
  79:    - 7.8 [Early Return from Functions](#78-early-return-from-functions)
  80:    - 7.9 [Hoist RegExp Creation](#79-hoist-regexp-creation)
  81:    - 7.10 [Use Loop for Min/Max Instead of Sort](#710-use-loop-for-minmax-instead-of-sort)
  82:    - 7.11 [Use Set/Map for O(1) Lookups](#711-use-setmap-for-o1-lookups)
  83:    - 7.12 [Use toSorted() Instead of sort() for Immutability](#712-use-tosorted-instead-of-sort-for-immutability)
  84: 8. [Advanced Patterns](#8-advanced-patterns) ‚Äî **LOW**
  85:    - 8.1 [Initialize App Once, Not Per Mount](#81-initialize-app-once-not-per-mount)
  86:    - 8.2 [Store Event Handlers in Refs](#82-store-event-handlers-in-refs)
  87:    - 8.3 [useEffectEvent for Stable Callback Refs](#83-useeffectevent-for-stable-callback-refs)
  88: 
  89: ---
  90: 
  91: ## 1. Eliminating Waterfalls
  92: 
  93: **Impact: CRITICAL**
  94: 
  95: Waterfalls are the #1 performance killer. Each sequential await adds full network latency. Eliminating them yields the largest gains.
  96: 
  97: ### 1.1 Defer Await Until Needed
  98: 
  99: **Impact: HIGH (avoids blocking unused code paths)**
 100: 
 101: Move `await` operations into the branches where they're actually used to avoid blocking code paths that don't need them.
 102: 
 103: **Incorrect: blocks both branches**
 104: 
 105: ```typescript
 106: async function handleRequest(userId: string, skipProcessing: boolean) {
 107:   const userData = await fetchUserData(userId)
 108:   
 109:   if (skipProcessing) {
 110:     // Returns immediately but still waited for userData
 111:     return { skipped: true }
 112:   }
 113:   
 114:   // Only this branch uses userData
 115:   return processUserData(userData)
 116: }
 117: ```
 118: 
 119: **Correct: only blocks when needed**
 120: 
 121: ```typescript
 122: async function handleRequest(userId: string, skipProcessing: boolean) {
 123:   if (skipProcessing) {
 124:     // Returns immediately without waiting
 125:     return { skipped: true }
 126:   }
 127:   
 128:   // Fetch only when needed
 129:   const userData = await fetchUserData(userId)
 130:   return processUserData(userData)
 131: }
 132: ```
 133: 
 134: **Another example: early return optimization**
 135: 
 136: ```typescript
 137: // Incorrect: always fetches permissions
 138: async function updateResource(resourceId: string, userId: string) {
 139:   const permissions = await fetchPermissions(userId)
 140:   const resource = await getResource(resourceId)
 141:   
 142:   if (!resource) {
 143:     return { error: 'Not found' }
 144:   }
 145:   
 146:   if (!permissions.canEdit) {
 147:     return { error: 'Forbidden' }
 148:   }
 149:   
 150:   return await updateResourceData(resource, permissions)
 151: }
 152: 
 153: // Correct: fetches only when needed
 154: async function updateResource(resourceId: string, userId: string) {
 155:   const resource = await getResource(resourceId)
 156:   
 157:   if (!resource) {
 158:     return { error: 'Not found' }
 159:   }
 160:   
 161:   const permissions = await fetchPermissions(userId)
 162:   
 163:   if (!permissions.canEdit) {
 164:     return { error: 'Forbidden' }
 165:   }
 166:   
 167:   return await updateResourceData(resource, permissions)
 168: }
 169: ```
 170: 
 171: This optimization is especially valuable when the skipped branch is frequently taken, or when the deferred operation is expensive.
 172: 
 173: ### 1.2 Dependency-Based Parallelization
 174: 
 175: **Impact: CRITICAL (2-10√ó improvement)**
 176: 
 177: For operations with partial dependencies, use `better-all` to maximize parallelism. It automatically starts each task at the earliest possible moment.
 178: 
 179: **Incorrect: profile waits for config unnecessarily**
 180: 
 181: ```typescript
 182: const [user, config] = await Promise.all([
 183:   fetchUser(),
 184:   fetchConfig()
 185: ])
 186: const profile = await fetchProfile(user.id)
 187: ```
 188: 
 189: **Correct: config and profile run in parallel**
 190: 
 191: ```typescript
 192: import { all } from 'better-all'
 193: 
 194: const { user, config, profile } = await all({
 195:   async user() { return fetchUser() },
 196:   async config() { return fetchConfig() },
 197:   async profile() {
 198:     return fetchProfile((await this.$.user).id)
 199:   }
 200: })
 201: ```
 202: 
 203: **Alternative without extra dependencies:**
 204: 
 205: ```typescript
 206: const userPromise = fetchUser()
 207: const profilePromise = userPromise.then(user => fetchProfile(user.id))
 208: 
 209: const [user, config, profile] = await Promise.all([
 210:   userPromise,
 211:   fetchConfig(),
 212:   profilePromise
 213: ])
 214: ```
 215: 
 216: We can also create all the promises first, and do `Promise.all()` at the end.
 217: 
 218: Reference: [https://github.com/shuding/better-all](https://github.com/shuding/better-all)
 219: 
 220: ### 1.3 Prevent Waterfall Chains in API Routes
 221: 
 222: **Impact: CRITICAL (2-10√ó improvement)**
 223: 
 224: In API routes and Server Actions, start independent operations immediately, even if you don't await them yet.
 225: 
 226: **Incorrect: config waits for auth, data waits for both**
 227: 
 228: ```typescript
 229: export async function GET(request: Request) {
 230:   const session = await auth()
 231:   const config = await fetchConfig()
 232:   const data = await fetchData(session.user.id)
 233:   return Response.json({ data, config })
 234: }
 235: ```
 236: 
 237: **Correct: auth and config start immediately**
 238: 
 239: ```typescript
 240: export async function GET(request: Request) {
 241:   const sessionPromise = auth()
 242:   const configPromise = fetchConfig()
 243:   const session = await sessionPromise
 244:   const [config, data] = await Promise.all([
 245:     configPromise,
 246:     fetchData(session.user.id)
 247:   ])
 248:   return Response.json({ data, config })
 249: }
 250: ```
 251: 
 252: For operations with more complex dependency chains, use `better-all` to automatically maximize parallelism (see Dependency-Based Parallelization).
 253: 
 254: ### 1.4 Promise.all() for Independent Operations
 255: 
 256: **Impact: CRITICAL (2-10√ó improvement)**
 257: 
 258: When async operations have no interdependencies, execute them concurrently using `Promise.all()`.
 259: 
 260: **Incorrect: sequential execution, 3 round trips**
 261: 
 262: ```typescript
 263: const user = await fetchUser()
 264: const posts = await fetchPosts()
 265: const comments = await fetchComments()
 266: ```
 267: 
 268: **Correct: parallel execution, 1 round trip**
 269: 
 270: ```typescript
 271: const [user, posts, comments] = await Promise.all([
 272:   fetchUser(),
 273:   fetchPosts(),
 274:   fetchComments()
 275: ])
 276: ```
 277: 
 278: ### 1.5 Strategic Suspense Boundaries
 279: 
 280: **Impact: HIGH (faster initial paint)**
 281: 
 282: Instead of awaiting data in async components before returning JSX, use Suspense boundaries to show the wrapper UI faster while data loads.
 283: 
 284: **Incorrect: wrapper blocked by data fetching**
 285: 
 286: ```tsx
 287: async function Page() {
 288:   const data = await fetchData() // Blocks entire page
 289:   
 290:   return (
 291:     <div>
 292:       <div>Sidebar</div>
 293:       <div>Header</div>
 294:       <div>
 295:         <DataDisplay data={data} />
 296:       </div>
 297:       <div>Footer</div>
 298:     </div>
 299:   )
 300: }
 301: ```
 302: 
 303: The entire layout waits for data even though only the middle section needs it.
 304: 
 305: **Correct: wrapper shows immediately, data streams in**
 306: 
 307: ```tsx
 308: function Page() {
 309:   return (
 310:     <div>
 311:       <div>Sidebar</div>
 312:       <div>Header</div>
 313:       <div>
 314:         <Suspense fallback={<Skeleton />}>
 315:           <DataDisplay />
 316:         </Suspense>
 317:       </div>
 318:       <div>Footer</div>
 319:     </div>
 320:   )
 321: }
 322: 
 323: async function DataDisplay() {
 324:   const data = await fetchData() // Only blocks this component
 325:   return <div>{data.content}</div>
 326: }
 327: ```
 328: 
 329: Sidebar, Header, and Footer render immediately. Only DataDisplay waits for data.
 330: 
 331: **Alternative: share promise across components**
 332: 
 333: ```tsx
 334: function Page() {
 335:   // Start fetch immediately, but don't await
 336:   const dataPromise = fetchData()
 337:   
 338:   return (
 339:     <div>
 340:       <div>Sidebar</div>
 341:       <div>Header</div>
 342:       <Suspense fallback={<Skeleton />}>
 343:         <DataDisplay dataPromise={dataPromise} />
 344:         <DataSummary dataPromise={dataPromise} />
 345:       </Suspense>
 346:       <div>Footer</div>
 347:     </div>
 348:   )
 349: }
 350: 
 351: function DataDisplay({ dataPromise }: { dataPromise: Promise<Data> }) {
 352:   const data = use(dataPromise) // Unwraps the promise
 353:   return <div>{data.content}</div>
 354: }
 355: 
 356: function DataSummary({ dataPromise }: { dataPromise: Promise<Data> }) {
 357:   const data = use(dataPromise) // Reuses the same promise
 358:   return <div>{data.summary}</div>
 359: }
 360: ```
 361: 
 362: Both components share the same promise, so only one fetch occurs. Layout renders immediately while both components wait together.
 363: 
 364: **When NOT to use this pattern:**
 365: 
 366: - Critical data needed for layout decisions (affects positioning)
 367: 
 368: - SEO-critical content above the fold
 369: 
 370: - Small, fast queries where suspense overhead isn't worth it
 371: 
 372: - When you want to avoid layout shift (loading ‚Üí content jump)
 373: 
 374: **Trade-off:** Faster initial paint vs potential layout shift. Choose based on your UX priorities.
 375: 
 376: ---
 377: 
 378: ## 2. Bundle Size Optimization
 379: 
 380: **Impact: CRITICAL**
 381: 
 382: Reducing initial bundle size improves Time to Interactive and Largest Contentful Paint.
 383: 
 384: ### 2.1 Avoid Barrel File Imports
 385: 
 386: **Impact: CRITICAL (200-800ms import cost, slow builds)**
 387: 
 388: Import directly from source files instead of barrel files to avoid loading thousands of unused modules. **Barrel files** are entry points that re-export multiple modules (e.g., `index.js` that does `export * from './module'`).
 389: 
 390: Popular icon and component libraries can have **up to 10,000 re-exports** in their entry file. For many React packages, **it takes 200-800ms just to import them**, affecting both development speed and production cold starts.
 391: 
 392: **Why tree-shaking doesn't help:** When a library is marked as external (not bundled), the bundler can't optimize it. If you bundle it to enable tree-shaking, builds become substantially slower analyzing the entire module graph.
 393: 
 394: **Incorrect: imports entire library**
 395: 
 396: ```tsx
 397: import { Check, X, Menu } from 'lucide-react'
 398: // Loads 1,583 modules, takes ~2.8s extra in dev
 399: // Runtime cost: 200-800ms on every cold start
 400: 
 401: import { Button, TextField } from '@mui/material'
 402: // Loads 2,225 modules, takes ~4.2s extra in dev
 403: ```
 404: 
 405: **Correct: imports only what you need**
 406: 
 407: ```tsx
 408: import Check from 'lucide-react/dist/esm/icons/check'
 409: import X from 'lucide-react/dist/esm/icons/x'
 410: import Menu from 'lucide-react/dist/esm/icons/menu'
 411: // Loads only 3 modules (~2KB vs ~1MB)
 412: 
 413: import Button from '@mui/material/Button'
 414: import TextField from '@mui/material/TextField'
 415: // Loads only what you use
 416: ```
 417: 
 418: **Alternative: Next.js 13.5+**
 419: 
 420: ```js
 421: // next.config.js - use optimizePackageImports
 422: module.exports = {
 423:   experimental: {
 424:     optimizePackageImports: ['lucide-react', '@mui/material']
 425:   }
 426: }
 427: 
 428: // Then you can keep the ergonomic barrel imports:
 429: import { Check, X, Menu } from 'lucide-react'
 430: // Automatically transformed to direct imports at build time
 431: ```
 432: 
 433: Direct imports provide 15-70% faster dev boot, 28% faster builds, 40% faster cold starts, and significantly faster HMR.
 434: 
 435: Libraries commonly affected: `lucide-react`, `@mui/material`, `@mui/icons-material`, `@tabler/icons-react`, `react-icons`, `@headlessui/react`, `@radix-ui/react-*`, `lodash`, `ramda`, `date-fns`, `rxjs`, `react-use`.
 436: 
 437: Reference: [https://vercel.com/blog/how-we-optimized-package-imports-in-next-js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)
 438: 
 439: ### 2.2 Conditional Module Loading
 440: 
 441: **Impact: HIGH (loads large data only when needed)**
 442: 
 443: Load large data or modules only when a feature is activated.
 444: 
 445: **Example: lazy-load animation frames**
 446: 
 447: ```tsx
 448: function AnimationPlayer({ enabled, setEnabled }: { enabled: boolean; setEnabled: React.Dispatch<React.SetStateAction<boolean>> }) {
 449:   const [frames, setFrames] = useState<Frame[] | null>(null)
 450: 
 451:   useEffect(() => {
 452:     if (enabled && !frames && typeof window !== 'undefined') {
 453:       import('./animation-frames.js')
 454:         .then(mod => setFrames(mod.frames))
 455:         .catch(() => setEnabled(false))
 456:     }
 457:   }, [enabled, frames, setEnabled])
 458: 
 459:   if (!frames) return <Skeleton />
 460:   return <Canvas frames={frames} />
 461: }
 462: ```
 463: 
 464: The `typeof window !== 'undefined'` check prevents bundling this module for SSR, optimizing server bundle size and build speed.
 465: 
 466: ### 2.3 Defer Non-Critical Third-Party Libraries
 467: 
 468: **Impact: MEDIUM (loads after hydration)**
 469: 
 470: Analytics, logging, and error tracking don't block user interaction. Load them after hydration.
 471: 
 472: **Incorrect: blocks initial bundle**
 473: 
 474: ```tsx
 475: import { Analytics } from '@vercel/analytics/react'
 476: 
 477: export default function RootLayout({ children }) {
 478:   return (
 479:     <html>
 480:       <body>
 481:         {children}
 482:         <Analytics />
 483:       </body>
 484:     </html>
 485:   )
 486: }
 487: ```
 488: 
 489: **Correct: loads after hydration**
 490: 
 491: ```tsx
 492: import dynamic from 'next/dynamic'
 493: 
 494: const Analytics = dynamic(
 495:   () => import('@vercel/analytics/react').then(m => m.Analytics),
 496:   { ssr: false }
 497: )
 498: 
 499: export default function RootLayout({ children }) {
 500:   return (
 501:     <html>
 502:       <body>
 503:         {children}
 504:         <Analytics />
 505:       </body>
 506:     </html>
 507:   )
 508: }
 509: ```
 510: 
 511: ### 2.4 Dynamic Imports for Heavy Components
 512: 
 513: **Impact: CRITICAL (directly affects TTI and LCP)**
 514: 
 515: Use `next/dynamic` to lazy-load large components not needed on initial render.
 516: 
 517: **Incorrect: Monaco bundles with main chunk ~300KB**
 518: 
 519: ```tsx
 520: import { MonacoEditor } from './monaco-editor'
 521: 
 522: function CodePanel({ code }: { code: string }) {
 523:   return <MonacoEditor value={code} />
 524: }
 525: ```
 526: 
 527: **Correct: Monaco loads on demand**
 528: 
 529: ```tsx
 530: import dynamic from 'next/dynamic'
 531: 
 532: const MonacoEditor = dynamic(
 533:   () => import('./monaco-editor').then(m => m.MonacoEditor),
 534:   { ssr: false }
 535: )
 536: 
 537: function CodePanel({ code }: { code: string }) {
 538:   return <MonacoEditor value={code} />
 539: }
 540: ```
 541: 
 542: ### 2.5 Preload Based on User Intent
 543: 
 544: **Impact: MEDIUM (reduces perceived latency)**
 545: 
 546: Preload heavy bundles before they're needed to reduce perceived latency.
 547: 
 548: **Example: preload on hover/focus**
 549: 
 550: ```tsx
 551: function EditorButton({ onClick }: { onClick: () => void }) {
 552:   const preload = () => {
 553:     if (typeof window !== 'undefined') {
 554:       void import('./monaco-editor')
 555:     }
 556:   }
 557: 
 558:   return (
 559:     <button
 560:       onMouseEnter={preload}
 561:       onFocus={preload}
 562:       onClick={onClick}
 563:     >
 564:       Open Editor
 565:     </button>
 566:   )
 567: }
 568: ```
 569: 
 570: **Example: preload when feature flag is enabled**
 571: 
 572: ```tsx
 573: function FlagsProvider({ children, flags }: Props) {
 574:   useEffect(() => {
 575:     if (flags.editorEnabled && typeof window !== 'undefined') {
 576:       void import('./monaco-editor').then(mod => mod.init())
 577:     }
 578:   }, [flags.editorEnabled])
 579: 
 580:   return <FlagsContext.Provider value={flags}>
 581:     {children}
 582:   </FlagsContext.Provider>
 583: }
 584: ```
 585: 
 586: The `typeof window !== 'undefined'` check prevents bundling preloaded modules for SSR, optimizing server bundle size and build speed.
 587: 
 588: ---
 589: 
 590: ## 3. Server-Side Performance
 591: 
 592: **Impact: HIGH**
 593: 
 594: Optimizing server-side rendering and data fetching eliminates server-side waterfalls and reduces response times.
 595: 
 596: ### 3.1 Authenticate Server Actions Like API Routes
 597: 
 598: **Impact: CRITICAL (prevents unauthorized access to server mutations)**
 599: 
 600: Server Actions (functions with `"use server"`) are exposed as public endpoints, just like API routes. Always verify authentication and authorization **inside** each Server Action‚Äîdo not rely solely on middleware, layout guards, or page-level checks, as Server Actions can be invoked directly.
 601: 
 602: Next.js documentation explicitly states: "Treat Server Actions with the same security considerations as public-facing API endpoints, and verify if the user is allowed to perform a mutation."
 603: 
 604: **Incorrect: no authentication check**
 605: 
 606: ```typescript
 607: 'use server'
 608: 
 609: export async function deleteUser(userId: string) {
 610:   // Anyone can call this! No auth check
 611:   await db.user.delete({ where: { id: userId } })
 612:   return { success: true }
 613: }
 614: ```
 615: 
 616: **Correct: authentication inside the action**
 617: 
 618: ```typescript
 619: 'use server'
 620: 
 621: import { verifySession } from '@/lib/auth'
 622: import { unauthorized } from '@/lib/errors'
 623: 
 624: export async function deleteUser(userId: string) {
 625:   // Always check auth inside the action
 626:   const session = await verifySession()
 627:   
 628:   if (!session) {
 629:     throw unauthorized('Must be logged in')
 630:   }
 631:   
 632:   // Check authorization too
 633:   if (session.user.role !== 'admin' && session.user.id !== userId) {
 634:     throw unauthorized('Cannot delete other users')
 635:   }
 636:   
 637:   await db.user.delete({ where: { id: userId } })
 638:   return { success: true }
 639: }
 640: ```
 641: 
 642: **With input validation:**
 643: 
 644: ```typescript
 645: 'use server'
 646: 
 647: import { verifySession } from '@/lib/auth'
 648: import { z } from 'zod'
 649: 
 650: const updateProfileSchema = z.object({
 651:   userId: z.string().uuid(),
 652:   name: z.string().min(1).max(100),
 653:   email: z.string().email()
 654: })
 655: 
 656: export async function updateProfile(data: unknown) {
 657:   // Validate input first
 658:   const validated = updateProfileSchema.parse(data)
 659:   
 660:   // Then authenticate
 661:   const session = await verifySession()
 662:   if (!session) {
 663:     throw new Error('Unauthorized')
 664:   }
 665:   
 666:   // Then authorize
 667:   if (session.user.id !== validated.userId) {
 668:     throw new Error('Can only update own profile')
 669:   }
 670:   
 671:   // Finally perform the mutation
 672:   await db.user.update({
 673:     where: { id: validated.userId },
 674:     data: {
 675:       name: validated.name,
 676:       email: validated.email
 677:     }
 678:   })
 679:   
 680:   return { success: true }
 681: }
 682: ```
 683: 
 684: Reference: [https://nextjs.org/docs/app/guides/authentication](https://nextjs.org/docs/app/guides/authentication)
 685: 
 686: ### 3.2 Avoid Duplicate Serialization in RSC Props
 687: 
 688: **Impact: LOW (reduces network payload by avoiding duplicate serialization)**
 689: 
 690: RSC‚Üíclient serialization deduplicates by object reference, not value. Same reference = serialized once; new reference = serialized again. Do transformations (`.toSorted()`, `.filter()`, `.map()`) in client, not server.
 691: 
 692: **Incorrect: duplicates array**
 693: 
 694: ```tsx
 695: // RSC: sends 6 strings (2 arrays √ó 3 items)
 696: <ClientList usernames={usernames} usernamesOrdered={usernames.toSorted()} />
 697: ```
 698: 
 699: **Correct: sends 3 strings**
 700: 
 701: ```tsx
 702: // RSC: send once
 703: <ClientList usernames={usernames} />
 704: 
 705: // Client: transform there
 706: 'use client'
 707: const sorted = useMemo(() => [...usernames].sort(), [usernames])
 708: ```
 709: 
 710: **Nested deduplication behavior:**
 711: 
 712: ```tsx
 713: // string[] - duplicates everything
 714: usernames={['a','b']} sorted={usernames.toSorted()} // sends 4 strings
 715: 
 716: // object[] - duplicates array structure only
 717: users={[{id:1},{id:2}]} sorted={users.toSorted()} // sends 2 arrays + 2 unique objects (not 4)
 718: ```
 719: 
 720: Deduplication works recursively. Impact varies by data type:
 721: 
 722: - `string[]`, `number[]`, `boolean[]`: **HIGH impact** - array + all primitives fully duplicated
 723: 
 724: - `object[]`: **LOW impact** - array duplicated, but nested objects deduplicated by reference
 725: 
 726: **Operations breaking deduplication: create new references**
 727: 
 728: - Arrays: `.toSorted()`, `.filter()`, `.map()`, `.slice()`, `[...arr]`
 729: 
 730: - Objects: `{...obj}`, `Object.assign()`, `structuredClone()`, `JSON.parse(JSON.stringify())`
 731: 
 732: **More examples:**
 733: 
 734: ```tsx
 735: // ‚ùå Bad
 736: <C users={users} active={users.filter(u => u.active)} />
 737: <C product={product} productName={product.name} />
 738: 
 739: // ‚úÖ Good
 740: <C users={users} />
 741: <C product={product} />
 742: // Do filtering/destructuring in client
 743: ```
 744: 
 745: **Exception:** Pass derived data when transformation is expensive or client doesn't need original.
 746: 
 747: ### 3.3 Cross-Request LRU Caching
 748: 
 749: **Impact: HIGH (caches across requests)**
 750: 
 751: `React.cache()` only works within one request. For data shared across sequential requests (user clicks button A then button B), use an LRU cache.
 752: 
 753: **Implementation:**
 754: 
 755: ```typescript
 756: import { LRUCache } from 'lru-cache'
 757: 
 758: const cache = new LRUCache<string, any>({
 759:   max: 1000,
 760:   ttl: 5 * 60 * 1000  // 5 minutes
 761: })
 762: 
 763: export async function getUser(id: string) {
 764:   const cached = cache.get(id)
 765:   if (cached) return cached
 766: 
 767:   const user = await db.user.findUnique({ where: { id } })
 768:   cache.set(id, user)
 769:   return user
 770: }
 771: 
 772: // Request 1: DB query, result cached
 773: // Request 2: cache hit, no DB query
 774: ```
 775: 
 776: Use when sequential user actions hit multiple endpoints needing the same data within seconds.
 777: 
 778: **With Vercel's [Fluid Compute](https://vercel.com/docs/fluid-compute):** LRU caching is especially effective because multiple concurrent requests can share the same function instance and cache. This means the cache persists across requests without needing external storage like Redis.
 779: 
 780: **In traditional serverless:** Each invocation runs in isolation, so consider Redis for cross-process caching.
 781: 
 782: Reference: [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)
 783: 
 784: ### 3.4 Minimize Serialization at RSC Boundaries
 785: 
 786: **Impact: HIGH (reduces data transfer size)**
 787: 
 788: The React Server/Client boundary serializes all object properties into strings and embeds them in the HTML response and subsequent RSC requests. This serialized data directly impacts page weight and load time, so **size matters a lot**. Only pass fields that the client actually uses.
 789: 
 790: **Incorrect: serializes all 50 fields**
 791: 
 792: ```tsx
 793: async function Page() {
 794:   const user = await fetchUser()  // 50 fields
 795:   return <Profile user={user} />
 796: }
 797: 
 798: 'use client'
 799: function Profile({ user }: { user: User }) {
 800:   return <div>{user.name}</div>  // uses 1 field
 801: }
 802: ```
 803: 
 804: **Correct: serializes only 1 field**
 805: 
 806: ```tsx
 807: async function Page() {
 808:   const user = await fetchUser()
 809:   return <Profile name={user.name} />
 810: }
 811: 
 812: 'use client'
 813: function Profile({ name }: { name: string }) {
 814:   return <div>{name}</div>
 815: }
 816: ```
 817: 
 818: ### 3.5 Parallel Data Fetching with Component Composition
 819: 
 820: **Impact: CRITICAL (eliminates server-side waterfalls)**
 821: 
 822: React Server Components execute sequentially within a tree. Restructure with composition to parallelize data fetching.
 823: 
 824: **Incorrect: Sidebar waits for Page's fetch to complete**
 825: 
 826: ```tsx
 827: export default async function Page() {
 828:   const header = await fetchHeader()
 829:   return (
 830:     <div>
 831:       <div>{header}</div>
 832:       <Sidebar />
 833:     </div>
 834:   )
 835: }
 836: 
 837: async function Sidebar() {
 838:   const items = await fetchSidebarItems()
 839:   return <nav>{items.map(renderItem)}</nav>
 840: }
 841: ```
 842: 
 843: **Correct: both fetch simultaneously**
 844: 
 845: ```tsx
 846: async function Header() {
 847:   const data = await fetchHeader()
 848:   return <div>{data}</div>
 849: }
 850: 
 851: async function Sidebar() {
 852:   const items = await fetchSidebarItems()
 853:   return <nav>{items.map(renderItem)}</nav>
 854: }
 855: 
 856: export default function Page() {
 857:   return (
 858:     <div>
 859:       <Header />
 860:       <Sidebar />
 861:     </div>
 862:   )
 863: }
 864: ```
 865: 
 866: **Alternative with children prop:**
 867: 
 868: ```tsx
 869: async function Header() {
 870:   const data = await fetchHeader()
 871:   return <div>{data}</div>
 872: }
 873: 
 874: async function Sidebar() {
 875:   const items = await fetchSidebarItems()
 876:   return <nav>{items.map(renderItem)}</nav>
 877: }
 878: 
 879: function Layout({ children }: { children: ReactNode }) {
 880:   return (
 881:     <div>
 882:       <Header />
 883:       {children}
 884:     </div>
 885:   )
 886: }
 887: 
 888: export default function Page() {
 889:   return (
 890:     <Layout>
 891:       <Sidebar />
 892:     </Layout>
 893:   )
 894: }
 895: ```
 896: 
 897: ### 3.6 Per-Request Deduplication with React.cache()
 898: 
 899: **Impact: MEDIUM (deduplicates within request)**
 900: 
 901: Use `React.cache()` for server-side request deduplication. Authentication and database queries benefit most.
 902: 
 903: **Usage:**
 904: 
 905: ```typescript
 906: import { cache } from 'react'
 907: 
 908: export const getCurrentUser = cache(async () => {
 909:   const session = await auth()
 910:   if (!session?.user?.id) return null
 911:   return await db.user.findUnique({
 912:     where: { id: session.user.id }
 913:   })
 914: })
 915: ```
 916: 
 917: Within a single request, multiple calls to `getCurrentUser()` execute the query only once.
 918: 
 919: **Avoid inline objects as arguments:**
 920: 
 921: `React.cache()` uses shallow equality (`Object.is`) to determine cache hits. Inline objects create new references each call, preventing cache hits.
 922: 
 923: **Incorrect: always cache miss**
 924: 
 925: ```typescript
 926: const getUser = cache(async (params: { uid: number }) => {
 927:   return await db.user.findUnique({ where: { id: params.uid } })
 928: })
 929: 
 930: // Each call creates new object, never hits cache
 931: getUser({ uid: 1 })
 932: getUser({ uid: 1 })  // Cache miss, runs query again
 933: ```
 934: 
 935: **Correct: cache hit**
 936: 
 937: ```typescript
 938: const params = { uid: 1 }
 939: getUser(params)  // Query runs
 940: getUser(params)  // Cache hit (same reference)
 941: ```
 942: 
 943: If you must pass objects, pass the same reference:
 944: 
 945: **Next.js-Specific Note:**
 946: 
 947: In Next.js, the `fetch` API is automatically extended with request memoization. Requests with the same URL and options are automatically deduplicated within a single request, so you don't need `React.cache()` for `fetch` calls. However, `React.cache()` is still essential for other async tasks:
 948: 
 949: - Database queries (Prisma, Drizzle, etc.)
 950: 
 951: - Heavy computations
 952: 
 953: - Authentication checks
 954: 
 955: - File system operations
 956: 
 957: - Any non-fetch async work
 958: 
 959: Use `React.cache()` to deduplicate these operations across your component tree.
 960: 
 961: Reference: [https://react.dev/reference/react/cache](https://react.dev/reference/react/cache)
 962: 
 963: ### 3.7 Use after() for Non-Blocking Operations
 964: 
 965: **Impact: MEDIUM (faster response times)**
 966: 
 967: Use Next.js's `after()` to schedule work that should execute after a response is sent. This prevents logging, analytics, and other side effects from blocking the response.
 968: 
 969: **Incorrect: blocks response**
 970: 
 971: ```tsx
 972: import { logUserAction } from '@/app/utils'
 973: 
 974: export async function POST(request: Request) {
 975:   // Perform mutation
 976:   await updateDatabase(request)
 977:   
 978:   // Logging blocks the response
 979:   const userAgent = request.headers.get('user-agent') || 'unknown'
 980:   await logUserAction({ userAgent })
 981:   
 982:   return new Response(JSON.stringify({ status: 'success' }), {
 983:     status: 200,
 984:     headers: { 'Content-Type': 'application/json' }
 985:   })
 986: }
 987: ```
 988: 
 989: **Correct: non-blocking**
 990: 
 991: ```tsx
 992: import { after } from 'next/server'
 993: import { headers, cookies } from 'next/headers'
 994: import { logUserAction } from '@/app/utils'
 995: 
 996: export async function POST(request: Request) {
 997:   // Perform mutation
 998:   await updateDatabase(request)
 999:   
1000:   // Log after response is sent
1001:   after(async () => {
1002:     const userAgent = (await headers()).get('user-agent') || 'unknown'
1003:     const sessionCookie = (await cookies()).get('session-id')?.value || 'anonymous'
1004:     
1005:     logUserAction({ sessionCookie, userAgent })
1006:   })
1007:   
1008:   return new Response(JSON.stringify({ status: 'success' }), {
1009:     status: 200,
1010:     headers: { 'Content-Type': 'application/json' }
1011:   })
1012: }
1013: ```
1014: 
1015: The response is sent immediately while logging happens in the background.
1016: 
1017: **Common use cases:**
1018: 
1019: - Analytics tracking
1020: 
1021: - Audit logging
1022: 
1023: - Sending notifications
1024: 
1025: - Cache invalidation
1026: 
1027: - Cleanup tasks
1028: 
1029: **Important notes:**
1030: 
1031: - `after()` runs even if the response fails or redirects
1032: 
1033: - Works in Server Actions, Route Handlers, and Server Components
1034: 
1035: Reference: [https://nextjs.org/docs/app/api-reference/functions/after](https://nextjs.org/docs/app/api-reference/functions/after)
1036: 
1037: ---
1038: 
1039: ## 4. Client-Side Data Fetching
1040: 
1041: **Impact: MEDIUM-HIGH**
1042: 
1043: Automatic deduplication and efficient data fetching patterns reduce redundant network requests.
1044: 
1045: ### 4.1 Deduplicate Global Event Listeners
1046: 
1047: **Impact: LOW (single listener for N components)**
1048: 
1049: Use `useSWRSubscription()` to share global event listeners across component instances.
1050: 
1051: **Incorrect: N instances = N listeners**
1052: 
1053: ```tsx
1054: function useKeyboardShortcut(key: string, callback: () => void) {
1055:   useEffect(() => {
1056:     const handler = (e: KeyboardEvent) => {
1057:       if (e.metaKey && e.key === key) {
1058:         callback()
1059:       }
1060:     }
1061:     window.addEventListener('keydown', handler)
1062:     return () => window.removeEventListener('keydown', handler)
1063:   }, [key, callback])
1064: }
1065: ```
1066: 
1067: When using the `useKeyboardShortcut` hook multiple times, each instance will register a new listener.
1068: 
1069: **Correct: N instances = 1 listener**
1070: 
1071: ```tsx
1072: import useSWRSubscription from 'swr/subscription'
1073: 
1074: // Module-level Map to track callbacks per key
1075: const keyCallbacks = new Map<string, Set<() => void>>()
1076: 
1077: function useKeyboardShortcut(key: string, callback: () => void) {
1078:   // Register this callback in the Map
1079:   useEffect(() => {
1080:     if (!keyCallbacks.has(key)) {
1081:       keyCallbacks.set(key, new Set())
1082:     }
1083:     keyCallbacks.get(key)!.add(callback)
1084: 
1085:     return () => {
1086:       const set = keyCallbacks.get(key)
1087:       if (set) {
1088:         set.delete(callback)
1089:         if (set.size === 0) {
1090:           keyCallbacks.delete(key)
1091:         }
1092:       }
1093:     }
1094:   }, [key, callback])
1095: 
1096:   useSWRSubscription('global-keydown', () => {
1097:     const handler = (e: KeyboardEvent) => {
1098:       if (e.metaKey && keyCallbacks.has(e.key)) {
1099:         keyCallbacks.get(e.key)!.forEach(cb => cb())
1100:       }
1101:     }
1102:     window.addEventListener('keydown', handler)
1103:     return () => window.removeEventListener('keydown', handler)
1104:   })
1105: }
1106: 
1107: function Profile() {
1108:   // Multiple shortcuts will share the same listener
1109:   useKeyboardShortcut('p', () => { /* ... */ }) 
1110:   useKeyboardShortcut('k', () => { /* ... */ })
1111:   // ...
1112: }
1113: ```
1114: 
1115: ### 4.2 Use Passive Event Listeners for Scrolling Performance
1116: 
1117: **Impact: MEDIUM (eliminates scroll delay caused by event listeners)**
1118: 
1119: Add `{ passive: true }` to touch and wheel event listeners to enable immediate scrolling. Browsers normally wait for listeners to finish to check if `preventDefault()` is called, causing scroll delay.
1120: 
1121: **Incorrect:**
1122: 
1123: ```typescript
1124: useEffect(() => {
1125:   const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)
1126:   const handleWheel = (e: WheelEvent) => console.log(e.deltaY)
1127:   
1128:   document.addEventListener('touchstart', handleTouch)
1129:   document.addEventListener('wheel', handleWheel)
1130:   
1131:   return () => {
1132:     document.removeEventListener('touchstart', handleTouch)
1133:     document.removeEventListener('wheel', handleWheel)
1134:   }
1135: }, [])
1136: ```
1137: 
1138: **Correct:**
1139: 
1140: ```typescript
1141: useEffect(() => {
1142:   const handleTouch = (e: TouchEvent) => console.log(e.touches[0].clientX)
1143:   const handleWheel = (e: WheelEvent) => console.log(e.deltaY)
1144:   
1145:   document.addEventListener('touchstart', handleTouch, { passive: true })
1146:   document.addEventListener('wheel', handleWheel, { passive: true })
1147:   
1148:   return () => {
1149:     document.removeEventListener('touchstart', handleTouch)
1150:     document.removeEventListener('wheel', handleWheel)
1151:   }
1152: }, [])
1153: ```
1154: 
1155: **Use passive when:** tracking/analytics, logging, any listener that doesn't call `preventDefault()`.
1156: 
1157: **Don't use passive when:** implementing custom swipe gestures, custom zoom controls, or any listener that needs `preventDefault()`.
1158: 
1159: ### 4.3 Use SWR for Automatic Deduplication
1160: 
1161: **Impact: MEDIUM-HIGH (automatic deduplication)**
1162: 
1163: SWR enables request deduplication, caching, and revalidation across component instances.
1164: 
1165: **Incorrect: no deduplication, each instance fetches**
1166: 
1167: ```tsx
1168: function UserList() {
1169:   const [users, setUsers] = useState([])
1170:   useEffect(() => {
1171:     fetch('/api/users')
1172:       .then(r => r.json())
1173:       .then(setUsers)
1174:   }, [])
1175: }
1176: ```
1177: 
1178: **Correct: multiple instances share one request**
1179: 
1180: ```tsx
1181: import useSWR from 'swr'
1182: 
1183: function UserList() {
1184:   const { data: users } = useSWR('/api/users', fetcher)
1185: }
1186: ```
1187: 
1188: **For immutable data:**
1189: 
1190: ```tsx
1191: import { useImmutableSWR } from '@/lib/swr'
1192: 
1193: function StaticContent() {
1194:   const { data } = useImmutableSWR('/api/config', fetcher)
1195: }
1196: ```
1197: 
1198: **For mutations:**
1199: 
1200: ```tsx
1201: import { useSWRMutation } from 'swr/mutation'
1202: 
1203: function UpdateButton() {
1204:   const { trigger } = useSWRMutation('/api/user', updateUser)
1205:   return <button onClick={() => trigger()}>Update</button>
1206: }
1207: ```
1208: 
1209: Reference: [https://swr.vercel.app](https://swr.vercel.app)
1210: 
1211: ### 4.4 Version and Minimize localStorage Data
1212: 
1213: **Impact: MEDIUM (prevents schema conflicts, reduces storage size)**
1214: 
1215: Add version prefix to keys and store only needed fields. Prevents schema conflicts and accidental storage of sensitive data.
1216: 
1217: **Incorrect:**
1218: 
1219: ```typescript
1220: // No version, stores everything, no error handling
1221: localStorage.setItem('userConfig', JSON.stringify(fullUserObject))
1222: const data = localStorage.getItem('userConfig')
1223: ```
1224: 
1225: **Correct:**
1226: 
1227: ```typescript
1228: const VERSION = 'v2'
1229: 
1230: function saveConfig(config: { theme: string; language: string }) {
1231:   try {
1232:     localStorage.setItem(`userConfig:${VERSION}`, JSON.stringify(config))
1233:   } catch {
1234:     // Throws in incognito/private browsing, quota exceeded, or disabled
1235:   }
1236: }
1237: 
1238: function loadConfig() {
1239:   try {
1240:     const data = localStorage.getItem(`userConfig:${VERSION}`)
1241:     return data ? JSON.parse(data) : null
1242:   } catch {
1243:     return null
1244:   }
1245: }
1246: 
1247: // Migration from v1 to v2
1248: function migrate() {
1249:   try {
1250:     const v1 = localStorage.getItem('userConfig:v1')
1251:     if (v1) {
1252:       const old = JSON.parse(v1)
1253:       saveConfig({ theme: old.darkMode ? 'dark' : 'light', language: old.lang })
1254:       localStorage.removeItem('userConfig:v1')
1255:     }
1256:   } catch {}
1257: }
1258: ```
1259: 
1260: **Store minimal fields from server responses:**
1261: 
1262: ```typescript
1263: // User object has 20+ fields, only store what UI needs
1264: function cachePrefs(user: FullUser) {
1265:   try {
1266:     localStorage.setItem('prefs:v1', JSON.stringify({
1267:       theme: user.preferences.theme,
1268:       notifications: user.preferences.notifications
1269:     }))
1270:   } catch {}
1271: }
1272: ```
1273: 
1274: **Always wrap in try-catch:** `getItem()` and `setItem()` throw in incognito/private browsing (Safari, Firefox), when quota exceeded, or when disabled.
1275: 
1276: **Benefits:** Schema evolution via versioning, reduced storage size, prevents storing tokens/PII/internal flags.
1277: 
1278: ---
1279: 
1280: ## 5. Re-render Optimization
1281: 
1282: **Impact: MEDIUM**
1283: 
1284: Reducing unnecessary re-renders minimizes wasted computation and improves UI responsiveness.
1285: 
1286: ### 5.1 Calculate Derived State During Rendering
1287: 
1288: **Impact: MEDIUM (avoids redundant renders and state drift)**
1289: 
1290: If a value can be computed from current props/state, do not store it in state or update it in an effect. Derive it during render to avoid extra renders and state drift. Do not set state in effects solely in response to prop changes; prefer derived values or keyed resets instead.
1291: 
1292: **Incorrect: redundant state and effect**
1293: 
1294: ```tsx
1295: function Form() {
1296:   const [firstName, setFirstName] = useState('First')
1297:   const [lastName, setLastName] = useState('Last')
1298:   const [fullName, setFullName] = useState('')
1299: 
1300:   useEffect(() => {
1301:     setFullName(firstName + ' ' + lastName)
1302:   }, [firstName, lastName])
1303: 
1304:   return <p>{fullName}</p>
1305: }
1306: ```
1307: 
1308: **Correct: derive during render**
1309: 
1310: ```tsx
1311: function Form() {
1312:   const [firstName, setFirstName] = useState('First')
1313:   const [lastName, setLastName] = useState('Last')
1314:   const fullName = firstName + ' ' + lastName
1315: 
1316:   return <p>{fullName}</p>
1317: }
1318: ```
1319: 
1320: Reference: [https://react.dev/learn/you-might-not-need-an-effect](https://react.dev/learn/you-might-not-need-an-effect)
1321: 
1322: ### 5.2 Defer State Reads to Usage Point
1323: 
1324: **Impact: MEDIUM (avoids unnecessary subscriptions)**
1325: 
1326: Don't subscribe to dynamic state (searchParams, localStorage) if you only read it inside callbacks.
1327: 
1328: **Incorrect: subscribes to all searchParams changes**
1329: 
1330: ```tsx
1331: function ShareButton({ chatId }: { chatId: string }) {
1332:   const searchParams = useSearchParams()
1333: 
1334:   const handleShare = () => {
1335:     const ref = searchParams.get('ref')
1336:     shareChat(chatId, { ref })
1337:   }
1338: 
1339:   return <button onClick={handleShare}>Share</button>
1340: }
1341: ```
1342: 
1343: **Correct: reads on demand, no subscription**
1344: 
1345: ```tsx
1346: function ShareButton({ chatId }: { chatId: string }) {
1347:   const handleShare = () => {
1348:     const params = new URLSearchParams(window.location.search)
1349:     const ref = params.get('ref')
1350:     shareChat(chatId, { ref })
1351:   }
1352: 
1353:   return <button onClick={handleShare}>Share</button>
1354: }
1355: ```
1356: 
1357: ### 5.3 Do not wrap a simple expression with a primitive result type in useMemo
1358: 
1359: **Impact: LOW-MEDIUM (wasted computation on every render)**
1360: 
1361: When an expression is simple (few logical or arithmetical operators) and has a primitive result type (boolean, number, string), do not wrap it in `useMemo`.
1362: 
1363: Calling `useMemo` and comparing hook dependencies may consume more resources than the expression itself.
1364: 
1365: **Incorrect:**
1366: 
1367: ```tsx
1368: function Header({ user, notifications }: Props) {
1369:   const isLoading = useMemo(() => {
1370:     return user.isLoading || notifications.isLoading
1371:   }, [user.isLoading, notifications.isLoading])
1372: 
1373:   if (isLoading) return <Skeleton />
1374:   // return some markup
1375: }
1376: ```
1377: 
1378: **Correct:**
1379: 
1380: ```tsx
1381: function Header({ user, notifications }: Props) {
1382:   const isLoading = user.isLoading || notifications.isLoading
1383: 
1384:   if (isLoading) return <Skeleton />
1385:   // return some markup
1386: }
1387: ```
1388: 
1389: ### 5.4 Extract Default Non-primitive Parameter Value from Memoized Component to Constant
1390: 
1391: **Impact: MEDIUM (restores memoization by using a constant for default value)**
1392: 
1393: When memoized component has a default value for some non-primitive optional parameter, such as an array, function, or object, calling the component without that parameter results in broken memoization. This is because new value instances are created on every rerender, and they do not pass strict equality comparison in `memo()`.
1394: 
1395: To address this issue, extract the default value into a constant.
1396: 
1397: **Incorrect: `onClick` has different values on every rerender**
1398: 
1399: ```tsx
1400: const UserAvatar = memo(function UserAvatar({ onClick = () => {} }: { onClick?: () => void }) {
1401:   // ...
1402: })
1403: 
1404: // Used without optional onClick
1405: <UserAvatar />
1406: ```
1407: 
1408: **Correct: stable default value**
1409: 
1410: ```tsx
1411: const NOOP = () => {};
1412: 
1413: const UserAvatar = memo(function UserAvatar({ onClick = NOOP }: { onClick?: () => void }) {
1414:   // ...
1415: })
1416: 
1417: // Used without optional onClick
1418: <UserAvatar />
1419: ```
1420: 
1421: ### 5.5 Extract to Memoized Components
1422: 
1423: **Impact: MEDIUM (enables early returns)**
1424: 
1425: Extract expensive work into memoized components to enable early returns before computation.
1426: 
1427: **Incorrect: computes avatar even when loading**
1428: 
1429: ```tsx
1430: function Profile({ user, loading }: Props) {
1431:   const avatar = useMemo(() => {
1432:     const id = computeAvatarId(user)
1433:     return <Avatar id={id} />
1434:   }, [user])
1435: 
1436:   if (loading) return <Skeleton />
1437:   return <div>{avatar}</div>
1438: }
1439: ```
1440: 
1441: **Correct: skips computation when loading**
1442: 
1443: ```tsx
1444: const UserAvatar = memo(function UserAvatar({ user }: { user: User }) {
1445:   const id = useMemo(() => computeAvatarId(user), [user])
1446:   return <Avatar id={id} />
1447: })
1448: 
1449: function Profile({ user, loading }: Props) {
1450:   if (loading) return <Skeleton />
1451:   return (
1452:     <div>
1453:       <UserAvatar user={user} />
1454:     </div>
1455:   )
1456: }
1457: ```
1458: 
1459: **Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, manual memoization with `memo()` and `useMemo()` is not necessary. The compiler automatically optimizes re-renders.
1460: 
1461: ### 5.6 Narrow Effect Dependencies
1462: 
1463: **Impact: LOW (minimizes effect re-runs)**
1464: 
1465: Specify primitive dependencies instead of objects to minimize effect re-runs.
1466: 
1467: **Incorrect: re-runs on any user field change**
1468: 
1469: ```tsx
1470: useEffect(() => {
1471:   console.log(user.id)
1472: }, [user])
1473: ```
1474: 
1475: **Correct: re-runs only when id changes**
1476: 
1477: ```tsx
1478: useEffect(() => {
1479:   console.log(user.id)
1480: }, [user.id])
1481: ```
1482: 
1483: **For derived state, compute outside effect:**
1484: 
1485: ```tsx
1486: // Incorrect: runs on width=767, 766, 765...
1487: useEffect(() => {
1488:   if (width < 768) {
1489:     enableMobileMode()
1490:   }
1491: }, [width])
1492: 
1493: // Correct: runs only on boolean transition
1494: const isMobile = width < 768
1495: useEffect(() => {
1496:   if (isMobile) {
1497:     enableMobileMode()
1498:   }
1499: }, [isMobile])
1500: ```
1501: 
1502: ### 5.7 Put Interaction Logic in Event Handlers
1503: 
1504: **Impact: MEDIUM (avoids effect re-runs and duplicate side effects)**
1505: 
1506: If a side effect is triggered by a specific user action (submit, click, drag), run it in that event handler. Do not model the action as state + effect; it makes effects re-run on unrelated changes and can duplicate the action.
1507: 
1508: **Incorrect: event modeled as state + effect**
1509: 
1510: ```tsx
1511: function Form() {
1512:   const [submitted, setSubmitted] = useState(false)
1513:   const theme = useContext(ThemeContext)
1514: 
1515:   useEffect(() => {
1516:     if (submitted) {
1517:       post('/api/register')
1518:       showToast('Registered', theme)
1519:     }
1520:   }, [submitted, theme])
1521: 
1522:   return <button onClick={() => setSubmitted(true)}>Submit</button>
1523: }
1524: ```
1525: 
1526: **Correct: do it in the handler**
1527: 
1528: ```tsx
1529: function Form() {
1530:   const theme = useContext(ThemeContext)
1531: 
1532:   function handleSubmit() {
1533:     post('/api/register')
1534:     showToast('Registered', theme)
1535:   }
1536: 
1537:   return <button onClick={handleSubmit}>Submit</button>
1538: }
1539: ```
1540: 
1541: Reference: [https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler](https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler)
1542: 
1543: ### 5.8 Subscribe to Derived State
1544: 
1545: **Impact: MEDIUM (reduces re-render frequency)**
1546: 
1547: Subscribe to derived boolean state instead of continuous values to reduce re-render frequency.
1548: 
1549: **Incorrect: re-renders on every pixel change**
1550: 
1551: ```tsx
1552: function Sidebar() {
1553:   const width = useWindowWidth()  // updates continuously
1554:   const isMobile = width < 768
1555:   return <nav className={isMobile ? 'mobile' : 'desktop'} />
1556: }
1557: ```
1558: 
1559: **Correct: re-renders only when boolean changes**
1560: 
1561: ```tsx
1562: function Sidebar() {
1563:   const isMobile = useMediaQuery('(max-width: 767px)')
1564:   return <nav className={isMobile ? 'mobile' : 'desktop'} />
1565: }
1566: ```
1567: 
1568: ### 5.9 Use Functional setState Updates
1569: 
1570: **Impact: MEDIUM (prevents stale closures and unnecessary callback recreations)**
1571: 
1572: When updating state based on the current state value, use the functional update form of setState instead of directly referencing the state variable. This prevents stale closures, eliminates unnecessary dependencies, and creates stable callback references.
1573: 
1574: **Incorrect: requires state as dependency**
1575: 
1576: ```tsx
1577: function TodoList() {
1578:   const [items, setItems] = useState(initialItems)
1579:   
1580:   // Callback must depend on items, recreated on every items change
1581:   const addItems = useCallback((newItems: Item[]) => {
1582:     setItems([...items, ...newItems])
1583:   }, [items])  // ‚ùå items dependency causes recreations
1584:   
1585:   // Risk of stale closure if dependency is forgotten
1586:   const removeItem = useCallback((id: string) => {
1587:     setItems(items.filter(item => item.id !== id))
1588:   }, [])  // ‚ùå Missing items dependency - will use stale items!
1589:   
1590:   return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />
1591: }
1592: ```
1593: 
1594: The first callback is recreated every time `items` changes, which can cause child components to re-render unnecessarily. The second callback has a stale closure bug‚Äîit will always reference the initial `items` value.
1595: 
1596: **Correct: stable callbacks, no stale closures**
1597: 
1598: ```tsx
1599: function TodoList() {
1600:   const [items, setItems] = useState(initialItems)
1601:   
1602:   // Stable callback, never recreated
1603:   const addItems = useCallback((newItems: Item[]) => {
1604:     setItems(curr => [...curr, ...newItems])
1605:   }, [])  // ‚úÖ No dependencies needed
1606:   
1607:   // Always uses latest state, no stale closure risk
1608:   const removeItem = useCallback((id: string) => {
1609:     setItems(curr => curr.filter(item => item.id !== id))
1610:   }, [])  // ‚úÖ Safe and stable
1611:   
1612:   return <ItemsEditor items={items} onAdd={addItems} onRemove={removeItem} />
1613: }
1614: ```
1615: 
1616: **Benefits:**
1617: 
1618: 1. **Stable callback references** - Callbacks don't need to be recreated when state changes
1619: 
1620: 2. **No stale closures** - Always operates on the latest state value
1621: 
1622: 3. **Fewer dependencies** - Simplifies dependency arrays and reduces memory leaks
1623: 
1624: 4. **Prevents bugs** - Eliminates the most common source of React closure bugs
1625: 
1626: **When to use functional updates:**
1627: 
1628: - Any setState that depends on the current state value
1629: 
1630: - Inside useCallback/useMemo when state is needed
1631: 
1632: - Event handlers that reference state
1633: 
1634: - Async operations that update state
1635: 
1636: **When direct updates are fine:**
1637: 
1638: - Setting state to a static value: `setCount(0)`
1639: 
1640: - Setting state from props/arguments only: `setName(newName)`
1641: 
1642: - State doesn't depend on previous value
1643: 
1644: **Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler can automatically optimize some cases, but functional updates are still recommended for correctness and to prevent stale closure bugs.
1645: 
1646: ### 5.10 Use Lazy State Initialization
1647: 
1648: **Impact: MEDIUM (wasted computation on every render)**
1649: 
1650: Pass a function to `useState` for expensive initial values. Without the function form, the initializer runs on every render even though the value is only used once.
1651: 
1652: **Incorrect: runs on every render**
1653: 
1654: ```tsx
1655: function FilteredList({ items }: { items: Item[] }) {
1656:   // buildSearchIndex() runs on EVERY render, even after initialization
1657:   const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))
1658:   const [query, setQuery] = useState('')
1659:   
1660:   // When query changes, buildSearchIndex runs again unnecessarily
1661:   return <SearchResults index={searchIndex} query={query} />
1662: }
1663: 
1664: function UserProfile() {
1665:   // JSON.parse runs on every render
1666:   const [settings, setSettings] = useState(
1667:     JSON.parse(localStorage.getItem('settings') || '{}')
1668:   )
1669:   
1670:   return <SettingsForm settings={settings} onChange={setSettings} />
1671: }
1672: ```
1673: 
1674: **Correct: runs only once**
1675: 
1676: ```tsx
1677: function FilteredList({ items }: { items: Item[] }) {
1678:   // buildSearchIndex() runs ONLY on initial render
1679:   const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))
1680:   const [query, setQuery] = useState('')
1681:   
1682:   return <SearchResults index={searchIndex} query={query} />
1683: }
1684: 
1685: function UserProfile() {
1686:   // JSON.parse runs only on initial render
1687:   const [settings, setSettings] = useState(() => {
1688:     const stored = localStorage.getItem('settings')
1689:     return stored ? JSON.parse(stored) : {}
1690:   })
1691:   
1692:   return <SettingsForm settings={settings} onChange={setSettings} />
1693: }
1694: ```
1695: 
1696: Use lazy initialization when computing initial values from localStorage/sessionStorage, building data structures (indexes, maps), reading from the DOM, or performing heavy transformations.
1697: 
1698: For simple primitives (`useState(0)`), direct references (`useState(props.value)`), or cheap literals (`useState({})`), the function form is unnecessary.
1699: 
1700: ### 5.11 Use Transitions for Non-Urgent Updates
1701: 
1702: **Impact: MEDIUM (maintains UI responsiveness)**
1703: 
1704: Mark frequent, non-urgent state updates as transitions to maintain UI responsiveness.
1705: 
1706: **Incorrect: blocks UI on every scroll**
1707: 
1708: ```tsx
1709: function ScrollTracker() {
1710:   const [scrollY, setScrollY] = useState(0)
1711:   useEffect(() => {
1712:     const handler = () => setScrollY(window.scrollY)
1713:     window.addEventListener('scroll', handler, { passive: true })
1714:     return () => window.removeEventListener('scroll', handler)
1715:   }, [])
1716: }
1717: ```
1718: 
1719: **Correct: non-blocking updates**
1720: 
1721: ```tsx
1722: import { startTransition } from 'react'
1723: 
1724: function ScrollTracker() {
1725:   const [scrollY, setScrollY] = useState(0)
1726:   useEffect(() => {
1727:     const handler = () => {
1728:       startTransition(() => setScrollY(window.scrollY))
1729:     }
1730:     window.addEventListener('scroll', handler, { passive: true })
1731:     return () => window.removeEventListener('scroll', handler)
1732:   }, [])
1733: }
1734: ```
1735: 
1736: ### 5.12 Use useRef for Transient Values
1737: 
1738: **Impact: MEDIUM (avoids unnecessary re-renders on frequent updates)**
1739: 
1740: When a value changes frequently and you don't want a re-render on every update (e.g., mouse trackers, intervals, transient flags), store it in `useRef` instead of `useState`. Keep component state for UI; use refs for temporary DOM-adjacent values. Updating a ref does not trigger a re-render.
1741: 
1742: **Incorrect: renders every update**
1743: 
1744: ```tsx
1745: function Tracker() {
1746:   const [lastX, setLastX] = useState(0)
1747: 
1748:   useEffect(() => {
1749:     const onMove = (e: MouseEvent) => setLastX(e.clientX)
1750:     window.addEventListener('mousemove', onMove)
1751:     return () => window.removeEventListener('mousemove', onMove)
1752:   }, [])
1753: 
1754:   return (
1755:     <div
1756:       style={{
1757:         position: 'fixed',
1758:         top: 0,
1759:         left: lastX,
1760:         width: 8,
1761:         height: 8,
1762:         background: 'black',
1763:       }}
1764:     />
1765:   )
1766: }
1767: ```
1768: 
1769: **Correct: no re-render for tracking**
1770: 
1771: ```tsx
1772: function Tracker() {
1773:   const lastXRef = useRef(0)
1774:   const dotRef = useRef<HTMLDivElement>(null)
1775: 
1776:   useEffect(() => {
1777:     const onMove = (e: MouseEvent) => {
1778:       lastXRef.current = e.clientX
1779:       const node = dotRef.current
1780:       if (node) {
1781:         node.style.transform = `translateX(${e.clientX}px)`
1782:       }
1783:     }
1784:     window.addEventListener('mousemove', onMove)
1785:     return () => window.removeEventListener('mousemove', onMove)
1786:   }, [])
1787: 
1788:   return (
1789:     <div
1790:       ref={dotRef}
1791:       style={{
1792:         position: 'fixed',
1793:         top: 0,
1794:         left: 0,
1795:         width: 8,
1796:         height: 8,
1797:         background: 'black',
1798:         transform: 'translateX(0px)',
1799:       }}
1800:     />
1801:   )
1802: }
1803: ```
1804: 
1805: ---
1806: 
1807: ## 6. Rendering Performance
1808: 
1809: **Impact: MEDIUM**
1810: 
1811: Optimizing the rendering process reduces the work the browser needs to do.
1812: 
1813: ### 6.1 Animate SVG Wrapper Instead of SVG Element
1814: 
1815: **Impact: LOW (enables hardware acceleration)**
1816: 
1817: Many browsers don't have hardware acceleration for CSS3 animations on SVG elements. Wrap SVG in a `<div>` and animate the wrapper instead.
1818: 
1819: **Incorrect: animating SVG directly - no hardware acceleration**
1820: 
1821: ```tsx
1822: function LoadingSpinner() {
1823:   return (
1824:     <svg 
1825:       className="animate-spin"
1826:       width="24" 
1827:       height="24" 
1828:       viewBox="0 0 24 24"
1829:     >
1830:       <circle cx="12" cy="12" r="10" stroke="currentColor" />
1831:     </svg>
1832:   )
1833: }
1834: ```
1835: 
1836: **Correct: animating wrapper div - hardware accelerated**
1837: 
1838: ```tsx
1839: function LoadingSpinner() {
1840:   return (
1841:     <div className="animate-spin">
1842:       <svg 
1843:         width="24" 
1844:         height="24" 
1845:         viewBox="0 0 24 24"
1846:       >
1847:         <circle cx="12" cy="12" r="10" stroke="currentColor" />
1848:       </svg>
1849:     </div>
1850:   )
1851: }
1852: ```
1853: 
1854: This applies to all CSS transforms and transitions (`transform`, `opacity`, `translate`, `scale`, `rotate`). The wrapper div allows browsers to use GPU acceleration for smoother animations.
1855: 
1856: ### 6.2 CSS content-visibility for Long Lists
1857: 
1858: **Impact: HIGH (faster initial render)**
1859: 
1860: Apply `content-visibility: auto` to defer off-screen rendering.
1861: 
1862: **CSS:**
1863: 
1864: ```css
1865: .message-item {
1866:   content-visibility: auto;
1867:   contain-intrinsic-size: 0 80px;
1868: }
1869: ```
1870: 
1871: **Example:**
1872: 
1873: ```tsx
1874: function MessageList({ messages }: { messages: Message[] }) {
1875:   return (
1876:     <div className="overflow-y-auto h-screen">
1877:       {messages.map(msg => (
1878:         <div key={msg.id} className="message-item">
1879:           <Avatar user={msg.author} />
1880:           <div>{msg.content}</div>
1881:         </div>
1882:       ))}
1883:     </div>
1884:   )
1885: }
1886: ```
1887: 
1888: For 1000 messages, browser skips layout/paint for ~990 off-screen items (10√ó faster initial render).
1889: 
1890: ### 6.3 Hoist Static JSX Elements
1891: 
1892: **Impact: LOW (avoids re-creation)**
1893: 
1894: Extract static JSX outside components to avoid re-creation.
1895: 
1896: **Incorrect: recreates element every render**
1897: 
1898: ```tsx
1899: function LoadingSkeleton() {
1900:   return <div className="animate-pulse h-20 bg-gray-200" />
1901: }
1902: 
1903: function Container() {
1904:   return (
1905:     <div>
1906:       {loading && <LoadingSkeleton />}
1907:     </div>
1908:   )
1909: }
1910: ```
1911: 
1912: **Correct: reuses same element**
1913: 
1914: ```tsx
1915: const loadingSkeleton = (
1916:   <div className="animate-pulse h-20 bg-gray-200" />
1917: )
1918: 
1919: function Container() {
1920:   return (
1921:     <div>
1922:       {loading && loadingSkeleton}
1923:     </div>
1924:   )
1925: }
1926: ```
1927: 
1928: This is especially helpful for large and static SVG nodes, which can be expensive to recreate on every render.
1929: 
1930: **Note:** If your project has [React Compiler](https://react.dev/learn/react-compiler) enabled, the compiler automatically hoists static JSX elements and optimizes component re-renders, making manual hoisting unnecessary.
1931: 
1932: ### 6.4 Optimize SVG Precision
1933: 
1934: **Impact: LOW (reduces file size)**
1935: 
1936: Reduce SVG coordinate precision to decrease file size. The optimal precision depends on the viewBox size, but in general reducing precision should be considered.
1937: 
1938: **Incorrect: excessive precision**
1939: 
1940: ```svg
1941: <path d="M 10.293847 20.847362 L 30.938472 40.192837" />
1942: ```
1943: 
1944: **Correct: 1 decimal place**
1945: 
1946: ```svg
1947: <path d="M 10.3 20.8 L 30.9 40.2" />
1948: ```
1949: 
1950: **Automate with SVGO:**
1951: 
1952: ```bash
1953: npx svgo --precision=1 --multipass icon.svg
1954: ```
1955: 
1956: ### 6.5 Prevent Hydration Mismatch Without Flickering
1957: 
1958: **Impact: MEDIUM (avoids visual flicker and hydration errors)**
1959: 
1960: When rendering content that depends on client-side storage (localStorage, cookies), avoid both SSR breakage and post-hydration flickering by injecting a synchronous script that updates the DOM before React hydrates.
1961: 
1962: **Incorrect: breaks SSR**
1963: 
1964: ```tsx
1965: function ThemeWrapper({ children }: { children: ReactNode }) {
1966:   // localStorage is not available on server - throws error
1967:   const theme = localStorage.getItem('theme') || 'light'
1968:   
1969:   return (
1970:     <div className={theme}>
1971:       {children}
1972:     </div>
1973:   )
1974: }
1975: ```
1976: 
1977: Server-side rendering will fail because `localStorage` is undefined.
1978: 
1979: **Incorrect: visual flickering**
1980: 
1981: ```tsx
1982: function ThemeWrapper({ children }: { children: ReactNode }) {
1983:   const [theme, setTheme] = useState('light')
1984:   
1985:   useEffect(() => {
1986:     // Runs after hydration - causes visible flash
1987:     const stored = localStorage.getItem('theme')
1988:     if (stored) {
1989:       setTheme(stored)
1990:     }
1991:   }, [])
1992:   
1993:   return (
1994:     <div className={theme}>
1995:       {children}
1996:     </div>
1997:   )
1998: }
1999: ```
2000: 
2001: Component first renders with default value (`light`), then updates after hydration, causing a visible flash of incorrect content.
2002: 
2003: **Correct: no flicker, no hydration mismatch**
2004: 
2005: ```tsx
2006: function ThemeWrapper({ children }: { children: ReactNode }) {
2007:   return (
2008:     <>
2009:       <div id="theme-wrapper">
2010:         {children}
2011:       </div>
2012:       <script
2013:         dangerouslySetInnerHTML={{
2014:           __html: `
2015:             (function() {
2016:               try {
2017:                 var theme = localStorage.getItem('theme') || 'light';
2018:                 var el = document.getElementById('theme-wrapper');
2019:                 if (el) el.className = theme;
2020:               } catch (e) {}
2021:             })();
2022:           `,
2023:         }}
2024:       />
2025:     </>
2026:   )
2027: }
2028: ```
2029: 
2030: The inline script executes synchronously before showing the element, ensuring the DOM already has the correct value. No flickering, no hydration mismatch.
2031: 
2032: This pattern is especially useful for theme toggles, user preferences, authentication states, and any client-only data that should render immediately without flashing default values.
2033: 
2034: ### 6.6 Suppress Expected Hydration Mismatches
2035: 
2036: **Impact: LOW-MEDIUM (avoids noisy hydration warnings for known differences)**
2037: 
2038: In SSR frameworks (e.g., Next.js), some values are intentionally different on server vs client (random IDs, dates, locale/timezone formatting). For these *expected* mismatches, wrap the dynamic text in an element with `suppressHydrationWarning` to prevent noisy warnings. Do not use this to hide real bugs. Don‚Äôt overuse it.
2039: 
2040: **Incorrect: known mismatch warnings**
2041: 
2042: ```tsx
2043: function Timestamp() {
2044:   return <span>{new Date().toLocaleString()}</span>
2045: }
2046: ```
2047: 
2048: **Correct: suppress expected mismatch only**
2049: 
2050: ```tsx
2051: function Timestamp() {
2052:   return (
2053:     <span suppressHydrationWarning>
2054:       {new Date().toLocaleString()}
2055:     </span>
2056:   )
2057: }
2058: ```
2059: 
2060: ### 6.7 Use Activity Component for Show/Hide
2061: 
2062: **Impact: MEDIUM (preserves state/DOM)**
2063: 
2064: Use React's `<Activity>` to preserve state/DOM for expensive components that frequently toggle visibility.
2065: 
2066: **Usage:**
2067: 
2068: ```tsx
2069: import { Activity } from 'react'
2070: 
2071: function Dropdown({ isOpen }: Props) {
2072:   return (
2073:     <Activity mode={isOpen ? 'visible' : 'hidden'}>
2074:       <ExpensiveMenu />
2075:     </Activity>
2076:   )
2077: }
2078: ```
2079: 
2080: Avoids expensive re-renders and state loss.
2081: 
2082: ### 6.8 Use Explicit Conditional Rendering
2083: 
2084: **Impact: LOW (prevents rendering 0 or NaN)**
2085: 
2086: Use explicit ternary operators (`? :`) instead of `&&` for conditional rendering when the condition can be `0`, `NaN`, or other falsy values that render.
2087: 
2088: **Incorrect: renders "0" when count is 0**
2089: 
2090: ```tsx
2091: function Badge({ count }: { count: number }) {
2092:   return (
2093:     <div>
2094:       {count && <span className="badge">{count}</span>}
2095:     </div>
2096:   )
2097: }
2098: 
2099: // When count = 0, renders: <div>0</div>
2100: // When count = 5, renders: <div><span class="badge">5</span></div>
2101: ```
2102: 
2103: **Correct: renders nothing when count is 0**
2104: 
2105: ```tsx
2106: function Badge({ count }: { count: number }) {
2107:   return (
2108:     <div>
2109:       {count > 0 ? <span className="badge">{count}</span> : null}
2110:     </div>
2111:   )
2112: }
2113: 
2114: // When count = 0, renders: <div></div>
2115: // When count = 5, renders: <div><span class="badge">5</span></div>
2116: ```
2117: 
2118: ### 6.9 Use useTransition Over Manual Loading States
2119: 
2120: **Impact: LOW (reduces re-renders and improves code clarity)**
2121: 
2122: Use `useTransition` instead of manual `useState` for loading states. This provides built-in `isPending` state and automatically manages transitions.
2123: 
2124: **Incorrect: manual loading state**
2125: 
2126: ```tsx
2127: function SearchResults() {
2128:   const [query, setQuery] = useState('')
2129:   const [results, setResults] = useState([])
2130:   const [isLoading, setIsLoading] = useState(false)
2131: 
2132:   const handleSearch = async (value: string) => {
2133:     setIsLoading(true)
2134:     setQuery(value)
2135:     const data = await fetchResults(value)
2136:     setResults(data)
2137:     setIsLoading(false)
2138:   }
2139: 
2140:   return (
2141:     <>
2142:       <input onChange={(e) => handleSearch(e.target.value)} />
2143:       {isLoading && <Spinner />}
2144:       <ResultsList results={results} />
2145:     </>
2146:   )
2147: }
2148: ```
2149: 
2150: **Correct: useTransition with built-in pending state**
2151: 
2152: ```tsx
2153: import { useTransition, useState } from 'react'
2154: 
2155: function SearchResults() {
2156:   const [query, setQuery] = useState('')
2157:   const [results, setResults] = useState([])
2158:   const [isPending, startTransition] = useTransition()
2159: 
2160:   const handleSearch = (value: string) => {
2161:     setQuery(value) // Update input immediately
2162:     
2163:     startTransition(async () => {
2164:       // Fetch and update results
2165:       const data = await fetchResults(value)
2166:       setResults(data)
2167:     })
2168:   }
2169: 
2170:   return (
2171:     <>
2172:       <input onChange={(e) => handleSearch(e.target.value)} />
2173:       {isPending && <Spinner />}
2174:       <ResultsList results={results} />
2175:     </>
2176:   )
2177: }
2178: ```
2179: 
2180: **Benefits:**
2181: 
2182: - **Automatic pending state**: No need to manually manage `setIsLoading(true/false)`
2183: 
2184: - **Error resilience**: Pending state correctly resets even if the transition throws
2185: 
2186: - **Better responsiveness**: Keeps the UI responsive during updates
2187: 
2188: - **Interrupt handling**: New transitions automatically cancel pending ones
2189: 
2190: Reference: [https://react.dev/reference/react/useTransition](https://react.dev/reference/react/useTransition)
2191: 
2192: ---
2193: 
2194: ## 7. JavaScript Performance
2195: 
2196: **Impact: LOW-MEDIUM**
2197: 
2198: Micro-optimizations for hot paths can add up to meaningful improvements.
2199: 
2200: ### 7.1 Avoid Layout Thrashing
2201: 
2202: **Impact: MEDIUM (prevents forced synchronous layouts and reduces performance bottlenecks)**
2203: 
2204: Avoid interleaving style writes with layout reads. When you read a layout property (like `offsetWidth`, `getBoundingClientRect()`, or `getComputedStyle()`) between style changes, the browser is forced to trigger a synchronous reflow.
2205: 
2206: **This is OK: browser batches style changes**
2207: 
2208: ```typescript
2209: function updateElementStyles(element: HTMLElement) {
2210:   // Each line invalidates style, but browser batches the recalculation
2211:   element.style.width = '100px'
2212:   element.style.height = '200px'
2213:   element.style.backgroundColor = 'blue'
2214:   element.style.border = '1px solid black'
2215: }
2216: ```
2217: 
2218: **Incorrect: interleaved reads and writes force reflows**
2219: 
2220: ```typescript
2221: function layoutThrashing(element: HTMLElement) {
2222:   element.style.width = '100px'
2223:   const width = element.offsetWidth  // Forces reflow
2224:   element.style.height = '200px'
2225:   const height = element.offsetHeight  // Forces another reflow
2226: }
2227: ```
2228: 
2229: **Correct: batch writes, then read once**
2230: 
2231: ```typescript
2232: function updateElementStyles(element: HTMLElement) {
2233:   // Batch all writes together
2234:   element.style.width = '100px'
2235:   element.style.height = '200px'
2236:   element.style.backgroundColor = 'blue'
2237:   element.style.border = '1px solid black'
2238:   
2239:   // Read after all writes are done (single reflow)
2240:   const { width, height } = element.getBoundingClientRect()
2241: }
2242: ```
2243: 
2244: **Correct: batch reads, then writes**
2245: 
2246: ```typescript
2247: function updateElementStyles(element: HTMLElement) {
2248:   element.classList.add('highlighted-box')
2249:   
2250:   const { width, height } = element.getBoundingClientRect()
2251: }
2252: ```
2253: 
2254: **Better: use CSS classes**
2255: 
2256: **React example:**
2257: 
2258: ```tsx
2259: // Incorrect: interleaving style changes with layout queries
2260: function Box({ isHighlighted }: { isHighlighted: boolean }) {
2261:   const ref = useRef<HTMLDivElement>(null)
2262:   
2263:   useEffect(() => {
2264:     if (ref.current && isHighlighted) {
2265:       ref.current.style.width = '100px'
2266:       const width = ref.current.offsetWidth // Forces layout
2267:       ref.current.style.height = '200px'
2268:     }
2269:   }, [isHighlighted])
2270:   
2271:   return <div ref={ref}>Content</div>
2272: }
2273: 
2274: // Correct: toggle class
2275: function Box({ isHighlighted }: { isHighlighted: boolean }) {
2276:   return (
2277:     <div className={isHighlighted ? 'highlighted-box' : ''}>
2278:       Content
2279:     </div>
2280:   )
2281: }
2282: ```
2283: 
2284: Prefer CSS classes over inline styles when possible. CSS files are cached by the browser, and classes provide better separation of concerns and are easier to maintain.
2285: 
2286: See [this gist](https://gist.github.com/paulirish/5d52fb081b3570c81e3a) and [CSS Triggers](https://csstriggers.com/) for more information on layout-forcing operations.
2287: 
2288: ### 7.2 Build Index Maps for Repeated Lookups
2289: 
2290: **Impact: LOW-MEDIUM (1M ops to 2K ops)**
2291: 
2292: Multiple `.find()` calls by the same key should use a Map.
2293: 
2294: **Incorrect (O(n) per lookup):**
2295: 
2296: ```typescript
2297: function processOrders(orders: Order[], users: User[]) {
2298:   return orders.map(order => ({
2299:     ...order,
2300:     user: users.find(u => u.id === order.userId)
2301:   }))
2302: }
2303: ```
2304: 
2305: **Correct (O(1) per lookup):**
2306: 
2307: ```typescript
2308: function processOrders(orders: Order[], users: User[]) {
2309:   const userById = new Map(users.map(u => [u.id, u]))
2310: 
2311:   return orders.map(order => ({
2312:     ...order,
2313:     user: userById.get(order.userId)
2314:   }))
2315: }
2316: ```
2317: 
2318: Build map once (O(n)), then all lookups are O(1).
2319: 
2320: For 1000 orders √ó 1000 users: 1M ops ‚Üí 2K ops.
2321: 
2322: ### 7.3 Cache Property Access in Loops
2323: 
2324: **Impact: LOW-MEDIUM (reduces lookups)**
2325: 
2326: Cache object property lookups in hot paths.
2327: 
2328: **Incorrect: 3 lookups √ó N iterations**
2329: 
2330: ```typescript
2331: for (let i = 0; i < arr.length; i++) {
2332:   process(obj.config.settings.value)
2333: }
2334: ```
2335: 
2336: **Correct: 1 lookup total**
2337: 
2338: ```typescript
2339: const value = obj.config.settings.value
2340: const len = arr.length
2341: for (let i = 0; i < len; i++) {
2342:   process(value)
2343: }
2344: ```
2345: 
2346: ### 7.4 Cache Repeated Function Calls
2347: 
2348: **Impact: MEDIUM (avoid redundant computation)**
2349: 
2350: Use a module-level Map to cache function results when the same function is called repeatedly with the same inputs during render.
2351: 
2352: **Incorrect: redundant computation**
2353: 
2354: ```typescript
2355: function ProjectList({ projects }: { projects: Project[] }) {
2356:   return (
2357:     <div>
2358:       {projects.map(project => {
2359:         // slugify() called 100+ times for same project names
2360:         const slug = slugify(project.name)
2361:         
2362:         return <ProjectCard key={project.id} slug={slug} />
2363:       })}
2364:     </div>
2365:   )
2366: }
2367: ```
2368: 
2369: **Correct: cached results**
2370: 
2371: ```typescript
2372: // Module-level cache
2373: const slugifyCache = new Map<string, string>()
2374: 
2375: function cachedSlugify(text: string): string {
2376:   if (slugifyCache.has(text)) {
2377:     return slugifyCache.get(text)!
2378:   }
2379:   const result = slugify(text)
2380:   slugifyCache.set(text, result)
2381:   return result
2382: }
2383: 
2384: function ProjectList({ projects }: { projects: Project[] }) {
2385:   return (
2386:     <div>
2387:       {projects.map(project => {
2388:         // Computed only once per unique project name
2389:         const slug = cachedSlugify(project.name)
2390:         
2391:         return <ProjectCard key={project.id} slug={slug} />
2392:       })}
2393:     </div>
2394:   )
2395: }
2396: ```
2397: 
2398: **Simpler pattern for single-value functions:**
2399: 
2400: ```typescript
2401: let isLoggedInCache: boolean | null = null
2402: 
2403: function isLoggedIn(): boolean {
2404:   if (isLoggedInCache !== null) {
2405:     return isLoggedInCache
2406:   }
2407:   
2408:   isLoggedInCache = document.cookie.includes('auth=')
2409:   return isLoggedInCache
2410: }
2411: 
2412: // Clear cache when auth changes
2413: function onAuthChange() {
2414:   isLoggedInCache = null
2415: }
2416: ```
2417: 
2418: Use a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.
2419: 
2420: Reference: [https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)
2421: 
2422: ### 7.5 Cache Storage API Calls
2423: 
2424: **Impact: LOW-MEDIUM (reduces expensive I/O)**
2425: 
2426: `localStorage`, `sessionStorage`, and `document.cookie` are synchronous and expensive. Cache reads in memory.
2427: 
2428: **Incorrect: reads storage on every call**
2429: 
2430: ```typescript
2431: function getTheme() {
2432:   return localStorage.getItem('theme') ?? 'light'
2433: }
2434: // Called 10 times = 10 storage reads
2435: ```
2436: 
2437: **Correct: Map cache**
2438: 
2439: ```typescript
2440: const storageCache = new Map<string, string | null>()
2441: 
2442: function getLocalStorage(key: string) {
2443:   if (!storageCache.has(key)) {
2444:     storageCache.set(key, localStorage.getItem(key))
2445:   }
2446:   return storageCache.get(key)
2447: }
2448: 
2449: function setLocalStorage(key: string, value: string) {
2450:   localStorage.setItem(key, value)
2451:   storageCache.set(key, value)  // keep cache in sync
2452: }
2453: ```
2454: 
2455: Use a Map (not a hook) so it works everywhere: utilities, event handlers, not just React components.
2456: 
2457: **Cookie caching:**
2458: 
2459: ```typescript
2460: let cookieCache: Record<string, string> | null = null
2461: 
2462: function getCookie(name: string) {
2463:   if (!cookieCache) {
2464:     cookieCache = Object.fromEntries(
2465:       document.cookie.split('; ').map(c => c.split('='))
2466:     )
2467:   }
2468:   return cookieCache[name]
2469: }
2470: ```
2471: 
2472: **Important: invalidate on external changes**
2473: 
2474: ```typescript
2475: window.addEventListener('storage', (e) => {
2476:   if (e.key) storageCache.delete(e.key)
2477: })
2478: 
2479: document.addEventListener('visibilitychange', () => {
2480:   if (document.visibilityState === 'visible') {
2481:     storageCache.clear()
2482:   }
2483: })
2484: ```
2485: 
2486: If storage can change externally (another tab, server-set cookies), invalidate cache:
2487: 
2488: ### 7.6 Combine Multiple Array Iterations
2489: 
2490: **Impact: LOW-MEDIUM (reduces iterations)**
2491: 
2492: Multiple `.filter()` or `.map()` calls iterate the array multiple times. Combine into one loop.
2493: 
2494: **Incorrect: 3 iterations**
2495: 
2496: ```typescript
2497: const admins = users.filter(u => u.isAdmin)
2498: const testers = users.filter(u => u.isTester)
2499: const inactive = users.filter(u => !u.isActive)
2500: ```
2501: 
2502: **Correct: 1 iteration**
2503: 
2504: ```typescript
2505: const admins: User[] = []
2506: const testers: User[] = []
2507: const inactive: User[] = []
2508: 
2509: for (const user of users) {
2510:   if (user.isAdmin) admins.push(user)
2511:   if (user.isTester) testers.push(user)
2512:   if (!user.isActive) inactive.push(user)
2513: }
2514: ```
2515: 
2516: ### 7.7 Early Length Check for Array Comparisons
2517: 
2518: **Impact: MEDIUM-HIGH (avoids expensive operations when lengths differ)**
2519: 
2520: When comparing arrays with expensive operations (sorting, deep equality, serialization), check lengths first. If lengths differ, the arrays cannot be equal.
2521: 
2522: In real-world applications, this optimization is especially valuable when the comparison runs in hot paths (event handlers, render loops).
2523: 
2524: **Incorrect: always runs expensive comparison**
2525: 
2526: ```typescript
2527: function hasChanges(current: string[], original: string[]) {
2528:   // Always sorts and joins, even when lengths differ
2529:   return current.sort().join() !== original.sort().join()
2530: }
2531: ```
2532: 
2533: Two O(n log n) sorts run even when `current.length` is 5 and `original.length` is 100. There is also overhead of joining the arrays and comparing the strings.
2534: 
2535: **Correct (O(1) length check first):**
2536: 
2537: ```typescript
2538: function hasChanges(current: string[], original: string[]) {
2539:   // Early return if lengths differ
2540:   if (current.length !== original.length) {
2541:     return true
2542:   }
2543:   // Only sort when lengths match
2544:   const currentSorted = current.toSorted()
2545:   const originalSorted = original.toSorted()
2546:   for (let i = 0; i < currentSorted.length; i++) {
2547:     if (currentSorted[i] !== originalSorted[i]) {
2548:       return true
2549:     }
2550:   }
2551:   return false
2552: }
2553: ```
2554: 
2555: This new approach is more efficient because:
2556: 
2557: - It avoids the overhead of sorting and joining the arrays when lengths differ
2558: 
2559: - It avoids consuming memory for the joined strings (especially important for large arrays)
2560: 
2561: - It avoids mutating the original arrays
2562: 
2563: - It returns early when a difference is found
2564: 
2565: ### 7.8 Early Return from Functions
2566: 
2567: **Impact: LOW-MEDIUM (avoids unnecessary computation)**
2568: 
2569: Return early when result is determined to skip unnecessary processing.
2570: 
2571: **Incorrect: processes all items even after finding answer**
2572: 
2573: ```typescript
2574: function validateUsers(users: User[]) {
2575:   let hasError = false
2576:   let errorMessage = ''
2577:   
2578:   for (const user of users) {
2579:     if (!user.email) {
2580:       hasError = true
2581:       errorMessage = 'Email required'
2582:     }
2583:     if (!user.name) {
2584:       hasError = true
2585:       errorMessage = 'Name required'
2586:     }
2587:     // Continues checking all users even after error found
2588:   }
2589:   
2590:   return hasError ? { valid: false, error: errorMessage } : { valid: true }
2591: }
2592: ```
2593: 
2594: **Correct: returns immediately on first error**
2595: 
2596: ```typescript
2597: function validateUsers(users: User[]) {
2598:   for (const user of users) {
2599:     if (!user.email) {
2600:       return { valid: false, error: 'Email required' }
2601:     }
2602:     if (!user.name) {
2603:       return { valid: false, error: 'Name required' }
2604:     }
2605:   }
2606: 
2607:   return { valid: true }
2608: }
2609: ```
2610: 
2611: ### 7.9 Hoist RegExp Creation
2612: 
2613: **Impact: LOW-MEDIUM (avoids recreation)**
2614: 
2615: Don't create RegExp inside render. Hoist to module scope or memoize with `useMemo()`.
2616: 
2617: **Incorrect: new RegExp every render**
2618: 
2619: ```tsx
2620: function Highlighter({ text, query }: Props) {
2621:   const regex = new RegExp(`(${query})`, 'gi')
2622:   const parts = text.split(regex)
2623:   return <>{parts.map((part, i) => ...)}</>
2624: }
2625: ```
2626: 
2627: **Correct: memoize or hoist**
2628: 
2629: ```tsx
2630: const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
2631: 
2632: function Highlighter({ text, query }: Props) {
2633:   const regex = useMemo(
2634:     () => new RegExp(`(${escapeRegex(query)})`, 'gi'),
2635:     [query]
2636:   )
2637:   const parts = text.split(regex)
2638:   return <>{parts.map((part, i) => ...)}</>
2639: }
2640: ```
2641: 
2642: **Warning: global regex has mutable state**
2643: 
2644: ```typescript
2645: const regex = /foo/g
2646: regex.test('foo')  // true, lastIndex = 3
2647: regex.test('foo')  // false, lastIndex = 0
2648: ```
2649: 
2650: Global regex (`/g`) has mutable `lastIndex` state:
2651: 
2652: ### 7.10 Use Loop for Min/Max Instead of Sort
2653: 
2654: **Impact: LOW (O(n) instead of O(n log n))**
2655: 
2656: Finding the smallest or largest element only requires a single pass through the array. Sorting is wasteful and slower.
2657: 
2658: **Incorrect (O(n log n) - sort to find latest):**
2659: 
2660: ```typescript
2661: interface Project {
2662:   id: string
2663:   name: string
2664:   updatedAt: number
2665: }
2666: 
2667: function getLatestProject(projects: Project[]) {
2668:   const sorted = [...projects].sort((a, b) => b.updatedAt - a.updatedAt)
2669:   return sorted[0]
2670: }
2671: ```
2672: 
2673: Sorts the entire array just to find the maximum value.
2674: 
2675: **Incorrect (O(n log n) - sort for oldest and newest):**
2676: 
2677: ```typescript
2678: function getOldestAndNewest(projects: Project[]) {
2679:   const sorted = [...projects].sort((a, b) => a.updatedAt - b.updatedAt)
2680:   return { oldest: sorted[0], newest: sorted[sorted.length - 1] }
2681: }
2682: ```
2683: 
2684: Still sorts unnecessarily when only min/max are needed.
2685: 
2686: **Correct (O(n) - single loop):**
2687: 
2688: ```typescript
2689: function getLatestProject(projects: Project[]) {
2690:   if (projects.length === 0) return null
2691:   
2692:   let latest = projects[0]
2693:   
2694:   for (let i = 1; i < projects.length; i++) {
2695:     if (projects[i].updatedAt > latest.updatedAt) {
2696:       latest = projects[i]
2697:     }
2698:   }
2699:   
2700:   return latest
2701: }
2702: 
2703: function getOldestAndNewest(projects: Project[]) {
2704:   if (projects.length === 0) return { oldest: null, newest: null }
2705:   
2706:   let oldest = projects[0]
2707:   let newest = projects[0]
2708:   
2709:   for (let i = 1; i < projects.length; i++) {
2710:     if (projects[i].updatedAt < oldest.updatedAt) oldest = projects[i]
2711:     if (projects[i].updatedAt > newest.updatedAt) newest = projects[i]
2712:   }
2713:   
2714:   return { oldest, newest }
2715: }
2716: ```
2717: 
2718: Single pass through the array, no copying, no sorting.
2719: 
2720: **Alternative: Math.min/Math.max for small arrays**
2721: 
2722: ```typescript
2723: const numbers = [5, 2, 8, 1, 9]
2724: const min = Math.min(...numbers)
2725: const max = Math.max(...numbers)
2726: ```
2727: 
2728: This works for small arrays, but can be slower or just throw an error for very large arrays due to spread operator limitations. Maximal array length is approximately 124000 in Chrome 143 and 638000 in Safari 18; exact numbers may vary - see [the fiddle](https://jsfiddle.net/qw1jabsx/4/). Use the loop approach for reliability.
2729: 
2730: ### 7.11 Use Set/Map for O(1) Lookups
2731: 
2732: **Impact: LOW-MEDIUM (O(n) to O(1))**
2733: 
2734: Convert arrays to Set/Map for repeated membership checks.
2735: 
2736: **Incorrect (O(n) per check):**
2737: 
2738: ```typescript
2739: const allowedIds = ['a', 'b', 'c', ...]
2740: items.filter(item => allowedIds.includes(item.id))
2741: ```
2742: 
2743: **Correct (O(1) per check):**
2744: 
2745: ```typescript
2746: const allowedIds = new Set(['a', 'b', 'c', ...])
2747: items.filter(item => allowedIds.has(item.id))
2748: ```
2749: 
2750: ### 7.12 Use toSorted() Instead of sort() for Immutability
2751: 
2752: **Impact: MEDIUM-HIGH (prevents mutation bugs in React state)**
2753: 
2754: `.sort()` mutates the array in place, which can cause bugs with React state and props. Use `.toSorted()` to create a new sorted array without mutation.
2755: 
2756: **Incorrect: mutates original array**
2757: 
2758: ```typescript
2759: function UserList({ users }: { users: User[] }) {
2760:   // Mutates the users prop array!
2761:   const sorted = useMemo(
2762:     () => users.sort((a, b) => a.name.localeCompare(b.name)),
2763:     [users]
2764:   )
2765:   return <div>{sorted.map(renderUser)}</div>
2766: }
2767: ```
2768: 
2769: **Correct: creates new array**
2770: 
2771: ```typescript
2772: function UserList({ users }: { users: User[] }) {
2773:   // Creates new sorted array, original unchanged
2774:   const sorted = useMemo(
2775:     () => users.toSorted((a, b) => a.name.localeCompare(b.name)),
2776:     [users]
2777:   )
2778:   return <div>{sorted.map(renderUser)}</div>
2779: }
2780: ```
2781: 
2782: **Why this matters in React:**
2783: 
2784: 1. Props/state mutations break React's immutability model - React expects props and state to be treated as read-only
2785: 
2786: 2. Causes stale closure bugs - Mutating arrays inside closures (callbacks, effects) can lead to unexpected behavior
2787: 
2788: **Browser support: fallback for older browsers**
2789: 
2790: ```typescript
2791: // Fallback for older browsers
2792: const sorted = [...items].sort((a, b) => a.value - b.value)
2793: ```
2794: 
2795: `.toSorted()` is available in all modern browsers (Chrome 110+, Safari 16+, Firefox 115+, Node.js 20+). For older environments, use spread operator:
2796: 
2797: **Other immutable array methods:**
2798: 
2799: - `.toSorted()` - immutable sort
2800: 
2801: - `.toReversed()` - immutable reverse
2802: 
2803: - `.toSpliced()` - immutable splice
2804: 
2805: - `.with()` - immutable element replacement
2806: 
2807: ---
2808: 
2809: ## 8. Advanced Patterns
2810: 
2811: **Impact: LOW**
2812: 
2813: Advanced patterns for specific cases that require careful implementation.
2814: 
2815: ### 8.1 Initialize App Once, Not Per Mount
2816: 
2817: **Impact: LOW-MEDIUM (avoids duplicate init in development)**
2818: 
2819: Do not put app-wide initialization that must run once per app load inside `useEffect([])` of a component. Components can remount and effects will re-run. Use a module-level guard or top-level init in the entry module instead.
2820: 
2821: **Incorrect: runs twice in dev, re-runs on remount**
2822: 
2823: ```tsx
2824: function Comp() {
2825:   useEffect(() => {
2826:     loadFromStorage()
2827:     checkAuthToken()
2828:   }, [])
2829: 
2830:   // ...
2831: }
2832: ```
2833: 
2834: **Correct: once per app load**
2835: 
2836: ```tsx
2837: let didInit = false
2838: 
2839: function Comp() {
2840:   useEffect(() => {
2841:     if (didInit) return
2842:     didInit = true
2843:     loadFromStorage()
2844:     checkAuthToken()
2845:   }, [])
2846: 
2847:   // ...
2848: }
2849: ```
2850: 
2851: Reference: [https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application](https://react.dev/learn/you-might-not-need-an-effect#initializing-the-application)
2852: 
2853: ### 8.2 Store Event Handlers in Refs
2854: 
2855: **Impact: LOW (stable subscriptions)**
2856: 
2857: Store callbacks in refs when used in effects that shouldn't re-subscribe on callback changes.
2858: 
2859: **Incorrect: re-subscribes on every render**
2860: 
2861: ```tsx
2862: function useWindowEvent(event: string, handler: (e) => void) {
2863:   useEffect(() => {
2864:     window.addEventListener(event, handler)
2865:     return () => window.removeEventListener(event, handler)
2866:   }, [event, handler])
2867: }
2868: ```
2869: 
2870: **Correct: stable subscription**
2871: 
2872: ```tsx
2873: import { useEffectEvent } from 'react'
2874: 
2875: function useWindowEvent(event: string, handler: (e) => void) {
2876:   const onEvent = useEffectEvent(handler)
2877: 
2878:   useEffect(() => {
2879:     window.addEventListener(event, onEvent)
2880:     return () => window.removeEventListener(event, onEvent)
2881:   }, [event])
2882: }
2883: ```
2884: 
2885: **Alternative: use `useEffectEvent` if you're on latest React:**
2886: 
2887: `useEffectEvent` provides a cleaner API for the same pattern: it creates a stable function reference that always calls the latest version of the handler.
2888: 
2889: ### 8.3 useEffectEvent for Stable Callback Refs
2890: 
2891: **Impact: LOW (prevents effect re-runs)**
2892: 
2893: Access latest values in callbacks without adding them to dependency arrays. Prevents effect re-runs while avoiding stale closures.
2894: 
2895: **Incorrect: effect re-runs on every callback change**
2896: 
2897: ```tsx
2898: function SearchInput({ onSearch }: { onSearch: (q: string) => void }) {
2899:   const [query, setQuery] = useState('')
2900: 
2901:   useEffect(() => {
2902:     const timeout = setTimeout(() => onSearch(query), 300)
2903:     return () => clearTimeout(timeout)
2904:   }, [query, onSearch])
2905: }
2906: ```
2907: 
2908: **Correct: using React's useEffectEvent**
2909: 
2910: ```tsx
2911: import { useEffectEvent } from 'react';
2912: 
2913: function SearchInput({ onSearch }: { onSearch: (q: string) => void }) {
2914:   const [query, setQuery] = useState('')
2915:   const onSearchEvent = useEffectEvent(onSearch)
2916: 
2917:   useEffect(() => {
2918:     const timeout = setTimeout(() => onSearchEvent(query), 300)
2919:     return () => clearTimeout(timeout)
2920:   }, [query])
2921: }
2922: ```
2923: 
2924: ---
2925: 
2926: ## References
2927: 
2928: 1. [https://react.dev](https://react.dev)
2929: 2. [https://nextjs.org](https://nextjs.org)
2930: 3. [https://swr.vercel.app](https://swr.vercel.app)
2931: 4. [https://github.com/shuding/better-all](https://github.com/shuding/better-all)
2932: 5. [https://github.com/isaacs/node-lru-cache](https://github.com/isaacs/node-lru-cache)
2933: 6. [https://vercel.com/blog/how-we-optimized-package-imports-in-next-js](https://vercel.com/blog/how-we-optimized-package-imports-in-next-js)
2934: 7. [https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast](https://vercel.com/blog/how-we-made-the-vercel-dashboard-twice-as-fast)
</file>

<file path=".agents/skills/vercel-react-best-practices/SKILL.md">
  1: ---
  2: name: vercel-react-best-practices
  3: description: React and Next.js performance optimization guidelines from Vercel Engineering. This skill should be used when writing, reviewing, or refactoring React/Next.js code to ensure optimal performance patterns. Triggers on tasks involving React components, Next.js pages, data fetching, bundle optimization, or performance improvements.
  4: license: MIT
  5: metadata:
  6:   author: vercel
  7:   version: "1.0.0"
  8: ---
  9: 
 10: # Vercel React Best Practices
 11: 
 12: Comprehensive performance optimization guide for React and Next.js applications, maintained by Vercel. Contains 57 rules across 8 categories, prioritized by impact to guide automated refactoring and code generation.
 13: 
 14: ## When to Apply
 15: 
 16: Reference these guidelines when:
 17: - Writing new React components or Next.js pages
 18: - Implementing data fetching (client or server-side)
 19: - Reviewing code for performance issues
 20: - Refactoring existing React/Next.js code
 21: - Optimizing bundle size or load times
 22: 
 23: ## Rule Categories by Priority
 24: 
 25: | Priority | Category | Impact | Prefix |
 26: |----------|----------|--------|--------|
 27: | 1 | Eliminating Waterfalls | CRITICAL | `async-` |
 28: | 2 | Bundle Size Optimization | CRITICAL | `bundle-` |
 29: | 3 | Server-Side Performance | HIGH | `server-` |
 30: | 4 | Client-Side Data Fetching | MEDIUM-HIGH | `client-` |
 31: | 5 | Re-render Optimization | MEDIUM | `rerender-` |
 32: | 6 | Rendering Performance | MEDIUM | `rendering-` |
 33: | 7 | JavaScript Performance | LOW-MEDIUM | `js-` |
 34: | 8 | Advanced Patterns | LOW | `advanced-` |
 35: 
 36: ## Quick Reference
 37: 
 38: ### 1. Eliminating Waterfalls (CRITICAL)
 39: 
 40: - `async-defer-await` - Move await into branches where actually used
 41: - `async-parallel` - Use Promise.all() for independent operations
 42: - `async-dependencies` - Use better-all for partial dependencies
 43: - `async-api-routes` - Start promises early, await late in API routes
 44: - `async-suspense-boundaries` - Use Suspense to stream content
 45: 
 46: ### 2. Bundle Size Optimization (CRITICAL)
 47: 
 48: - `bundle-barrel-imports` - Import directly, avoid barrel files
 49: - `bundle-dynamic-imports` - Use next/dynamic for heavy components
 50: - `bundle-defer-third-party` - Load analytics/logging after hydration
 51: - `bundle-conditional` - Load modules only when feature is activated
 52: - `bundle-preload` - Preload on hover/focus for perceived speed
 53: 
 54: ### 3. Server-Side Performance (HIGH)
 55: 
 56: - `server-auth-actions` - Authenticate server actions like API routes
 57: - `server-cache-react` - Use React.cache() for per-request deduplication
 58: - `server-cache-lru` - Use LRU cache for cross-request caching
 59: - `server-dedup-props` - Avoid duplicate serialization in RSC props
 60: - `server-serialization` - Minimize data passed to client components
 61: - `server-parallel-fetching` - Restructure components to parallelize fetches
 62: - `server-after-nonblocking` - Use after() for non-blocking operations
 63: 
 64: ### 4. Client-Side Data Fetching (MEDIUM-HIGH)
 65: 
 66: - `client-swr-dedup` - Use SWR for automatic request deduplication
 67: - `client-event-listeners` - Deduplicate global event listeners
 68: - `client-passive-event-listeners` - Use passive listeners for scroll
 69: - `client-localstorage-schema` - Version and minimize localStorage data
 70: 
 71: ### 5. Re-render Optimization (MEDIUM)
 72: 
 73: - `rerender-defer-reads` - Don't subscribe to state only used in callbacks
 74: - `rerender-memo` - Extract expensive work into memoized components
 75: - `rerender-memo-with-default-value` - Hoist default non-primitive props
 76: - `rerender-dependencies` - Use primitive dependencies in effects
 77: - `rerender-derived-state` - Subscribe to derived booleans, not raw values
 78: - `rerender-derived-state-no-effect` - Derive state during render, not effects
 79: - `rerender-functional-setstate` - Use functional setState for stable callbacks
 80: - `rerender-lazy-state-init` - Pass function to useState for expensive values
 81: - `rerender-simple-expression-in-memo` - Avoid memo for simple primitives
 82: - `rerender-move-effect-to-event` - Put interaction logic in event handlers
 83: - `rerender-transitions` - Use startTransition for non-urgent updates
 84: - `rerender-use-ref-transient-values` - Use refs for transient frequent values
 85: 
 86: ### 6. Rendering Performance (MEDIUM)
 87: 
 88: - `rendering-animate-svg-wrapper` - Animate div wrapper, not SVG element
 89: - `rendering-content-visibility` - Use content-visibility for long lists
 90: - `rendering-hoist-jsx` - Extract static JSX outside components
 91: - `rendering-svg-precision` - Reduce SVG coordinate precision
 92: - `rendering-hydration-no-flicker` - Use inline script for client-only data
 93: - `rendering-hydration-suppress-warning` - Suppress expected mismatches
 94: - `rendering-activity` - Use Activity component for show/hide
 95: - `rendering-conditional-render` - Use ternary, not && for conditionals
 96: - `rendering-usetransition-loading` - Prefer useTransition for loading state
 97: 
 98: ### 7. JavaScript Performance (LOW-MEDIUM)
 99: 
100: - `js-batch-dom-css` - Group CSS changes via classes or cssText
101: - `js-index-maps` - Build Map for repeated lookups
102: - `js-cache-property-access` - Cache object properties in loops
103: - `js-cache-function-results` - Cache function results in module-level Map
104: - `js-cache-storage` - Cache localStorage/sessionStorage reads
105: - `js-combine-iterations` - Combine multiple filter/map into one loop
106: - `js-length-check-first` - Check array length before expensive comparison
107: - `js-early-exit` - Return early from functions
108: - `js-hoist-regexp` - Hoist RegExp creation outside loops
109: - `js-min-max-loop` - Use loop for min/max instead of sort
110: - `js-set-map-lookups` - Use Set/Map for O(1) lookups
111: - `js-tosorted-immutable` - Use toSorted() for immutability
112: 
113: ### 8. Advanced Patterns (LOW)
114: 
115: - `advanced-event-handler-refs` - Store event handlers in refs
116: - `advanced-init-once` - Initialize app once per app load
117: - `advanced-use-latest` - useLatest for stable callback refs
118: 
119: ## How to Use
120: 
121: Read individual rule files for detailed explanations and code examples:
122: 
123: ```
124: rules/async-parallel.md
125: rules/bundle-barrel-imports.md
126: ```
127: 
128: Each rule file contains:
129: - Brief explanation of why it matters
130: - Incorrect code example with explanation
131: - Correct code example with explanation
132: - Additional context and references
133: 
134: ## Full Compiled Document
135: 
136: For the complete guide with all rules expanded: `AGENTS.md`
</file>

<file path=".agents/skills/web-performance-optimization/SKILL.md">
  1: ---
  2: name: web-performance-optimization
  3: description: "Optimize website and web application performance including loading speed, Core Web Vitals, bundle size, caching strategies, and runtime performance"
  4: ---
  5: 
  6: # Web Performance Optimization
  7: 
  8: ## Overview
  9: 
 10: Help developers optimize website and web application performance to improve user experience, SEO rankings, and conversion rates. This skill provides systematic approaches to measure, analyze, and improve loading speed, runtime performance, and Core Web Vitals metrics.
 11: 
 12: ## When to Use This Skill
 13: 
 14: - Use when website or app is loading slowly
 15: - Use when optimizing for Core Web Vitals (LCP, FID, CLS)
 16: - Use when reducing JavaScript bundle size
 17: - Use when improving Time to Interactive (TTI)
 18: - Use when optimizing images and assets
 19: - Use when implementing caching strategies
 20: - Use when debugging performance bottlenecks
 21: - Use when preparing for performance audits
 22: 
 23: ## How It Works
 24: 
 25: ### Step 1: Measure Current Performance
 26: 
 27: I'll help you establish baseline metrics:
 28: - Run Lighthouse audits
 29: - Measure Core Web Vitals (LCP, FID, CLS)
 30: - Check bundle sizes
 31: - Analyze network waterfall
 32: - Identify performance bottlenecks
 33: 
 34: ### Step 2: Identify Issues
 35: 
 36: Analyze performance problems:
 37: - Large JavaScript bundles
 38: - Unoptimized images
 39: - Render-blocking resources
 40: - Slow server response times
 41: - Missing caching headers
 42: - Layout shifts
 43: - Long tasks blocking main thread
 44: 
 45: ### Step 3: Prioritize Optimizations
 46: 
 47: Focus on high-impact improvements:
 48: - Critical rendering path optimization
 49: - Code splitting and lazy loading
 50: - Image optimization
 51: - Caching strategies
 52: - Third-party script optimization
 53: 
 54: ### Step 4: Implement Optimizations
 55: 
 56: Apply performance improvements:
 57: - Optimize assets (images, fonts, CSS, JS)
 58: - Implement code splitting
 59: - Add caching headers
 60: - Lazy load non-critical resources
 61: - Optimize critical rendering path
 62: 
 63: ### Step 5: Verify Improvements
 64: 
 65: Measure impact of changes:
 66: - Re-run Lighthouse audits
 67: - Compare before/after metrics
 68: - Monitor real user metrics (RUM)
 69: - Test on different devices and networks
 70: 
 71: ## Examples
 72: 
 73: ### Example 1: Optimizing Core Web Vitals
 74: 
 75: ```markdown
 76: ## Performance Audit Results
 77: 
 78: ### Current Metrics (Before Optimization)
 79: - **LCP (Largest Contentful Paint):** 4.2s ‚ùå (should be < 2.5s)
 80: - **FID (First Input Delay):** 180ms ‚ùå (should be < 100ms)
 81: - **CLS (Cumulative Layout Shift):** 0.25 ‚ùå (should be < 0.1)
 82: - **Lighthouse Score:** 62/100
 83: 
 84: ### Issues Identified
 85: 
 86: 1. **LCP Issue:** Hero image (2.5MB) loads slowly
 87: 2. **FID Issue:** Large JavaScript bundle (850KB) blocks main thread
 88: 3. **CLS Issue:** Images without dimensions cause layout shifts
 89: 
 90: ### Optimization Plan
 91: 
 92: #### Fix LCP (Largest Contentful Paint)
 93: 
 94: **Problem:** Hero image is 2.5MB and loads slowly
 95: 
 96: **Solutions:**
 97: \`\`\`html
 98: <!-- Before: Unoptimized image -->
 99: <img src="/hero.jpg" alt="Hero">
100: 
101: <!-- After: Optimized with modern formats -->
102: <picture>
103:   <source srcset="/hero.avif" type="image/avif">
104:   <source srcset="/hero.webp" type="image/webp">
105:   <img 
106:     src="/hero.jpg" 
107:     alt="Hero"
108:     width="1200" 
109:     height="600"
110:     loading="eager"
111:     fetchpriority="high"
112:   >
113: </picture>
114: \`\`\`
115: 
116: **Additional optimizations:**
117: - Compress image to < 200KB
118: - Use CDN for faster delivery
119: - Preload hero image: `<link rel="preload" as="image" href="/hero.avif">`
120: 
121: #### Fix FID (First Input Delay)
122: 
123: **Problem:** 850KB JavaScript bundle blocks main thread
124: 
125: **Solutions:**
126: 
127: 1. **Code Splitting:**
128: \`\`\`javascript
129: // Before: Everything in one bundle
130: import { HeavyComponent } from './HeavyComponent';
131: import { Analytics } from './analytics';
132: import { ChatWidget } from './chat';
133: 
134: // After: Lazy load non-critical code
135: const HeavyComponent = lazy(() => import('./HeavyComponent'));
136: const ChatWidget = lazy(() => import('./chat'));
137: 
138: // Load analytics after page interactive
139: if (typeof window !== 'undefined') {
140:   window.addEventListener('load', () => {
141:     import('./analytics').then(({ Analytics }) => {
142:       Analytics.init();
143:     });
144:   });
145: }
146: \`\`\`
147: 
148: 2. **Remove Unused Dependencies:**
149: \`\`\`bash
150: # Analyze bundle
151: npx webpack-bundle-analyzer
152: 
153: # Remove unused packages
154: npm uninstall moment  # Use date-fns instead (smaller)
155: npm install date-fns
156: \`\`\`
157: 
158: 3. **Defer Non-Critical Scripts:**
159: \`\`\`html
160: <!-- Before: Blocks rendering -->
161: <script src="/analytics.js"></script>
162: 
163: <!-- After: Deferred -->
164: <script src="/analytics.js" defer></script>
165: \`\`\`
166: 
167: #### Fix CLS (Cumulative Layout Shift)
168: 
169: **Problem:** Images without dimensions cause layout shifts
170: 
171: **Solutions:**
172: \`\`\`html
173: <!-- Before: No dimensions -->
174: <img src="/product.jpg" alt="Product">
175: 
176: <!-- After: With dimensions -->
177: <img 
178:   src="/product.jpg" 
179:   alt="Product"
180:   width="400" 
181:   height="300"
182:   style="aspect-ratio: 4/3;"
183: >
184: \`\`\`
185: 
186: **For dynamic content:**
187: \`\`\`css
188: /* Reserve space for content that loads later */
189: .skeleton-loader {
190:   min-height: 200px;
191:   background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
192:   background-size: 200% 100%;
193:   animation: loading 1.5s infinite;
194: }
195: 
196: @keyframes loading {
197:   0% { background-position: 200% 0; }
198:   100% { background-position: -200% 0; }
199: }
200: \`\`\`
201: 
202: ### Results After Optimization
203: 
204: - **LCP:** 1.8s ‚úÖ (improved by 57%)
205: - **FID:** 45ms ‚úÖ (improved by 75%)
206: - **CLS:** 0.05 ‚úÖ (improved by 80%)
207: - **Lighthouse Score:** 94/100 ‚úÖ
208: ```
209: 
210: ### Example 2: Reducing JavaScript Bundle Size
211: 
212: ```markdown
213: ## Bundle Size Optimization
214: 
215: ### Current State
216: - **Total Bundle:** 850KB (gzipped: 280KB)
217: - **Main Bundle:** 650KB
218: - **Vendor Bundle:** 200KB
219: - **Load Time (3G):** 8.2s
220: 
221: ### Analysis
222: 
223: \`\`\`bash
224: # Analyze bundle composition
225: npx webpack-bundle-analyzer dist/stats.json
226: \`\`\`
227: 
228: **Findings:**
229: 1. Moment.js: 67KB (can replace with date-fns: 12KB)
230: 2. Lodash: 72KB (using entire library, only need 5 functions)
231: 3. Unused code: ~150KB of dead code
232: 4. No code splitting: Everything in one bundle
233: 
234: ### Optimization Steps
235: 
236: #### 1. Replace Heavy Dependencies
237: 
238: \`\`\`bash
239: # Remove moment.js (67KB) ‚Üí Use date-fns (12KB)
240: npm uninstall moment
241: npm install date-fns
242: 
243: # Before
244: import moment from 'moment';
245: const formatted = moment(date).format('YYYY-MM-DD');
246: 
247: # After
248: import { format } from 'date-fns';
249: const formatted = format(date, 'yyyy-MM-dd');
250: \`\`\`
251: 
252: **Savings:** 55KB
253: 
254: #### 2. Use Lodash Selectively
255: 
256: \`\`\`javascript
257: // Before: Import entire library (72KB)
258: import _ from 'lodash';
259: const unique = _.uniq(array);
260: 
261: // After: Import only what you need (5KB)
262: import uniq from 'lodash/uniq';
263: const unique = uniq(array);
264: 
265: // Or use native methods
266: const unique = [...new Set(array)];
267: \`\`\`
268: 
269: **Savings:** 67KB
270: 
271: #### 3. Implement Code Splitting
272: 
273: \`\`\`javascript
274: // Next.js example
275: import dynamic from 'next/dynamic';
276: 
277: // Lazy load heavy components
278: const Chart = dynamic(() => import('./Chart'), {
279:   loading: () => <div>Loading chart...</div>,
280:   ssr: false
281: });
282: 
283: const AdminPanel = dynamic(() => import('./AdminPanel'), {
284:   loading: () => <div>Loading...</div>
285: });
286: 
287: // Route-based code splitting (automatic in Next.js)
288: // pages/admin.js - Only loaded when visiting /admin
289: // pages/dashboard.js - Only loaded when visiting /dashboard
290: \`\`\`
291: 
292: #### 4. Remove Dead Code
293: 
294: \`\`\`javascript
295: // Enable tree shaking in webpack.config.js
296: module.exports = {
297:   mode: 'production',
298:   optimization: {
299:     usedExports: true,
300:     sideEffects: false
301:   }
302: };
303: 
304: // In package.json
305: {
306:   "sideEffects": false
307: }
308: \`\`\`
309: 
310: #### 5. Optimize Third-Party Scripts
311: 
312: \`\`\`html
313: <!-- Before: Loads immediately -->
314: <script src="https://analytics.com/script.js"></script>
315: 
316: <!-- After: Load after page interactive -->
317: <script>
318:   window.addEventListener('load', () => {
319:     const script = document.createElement('script');
320:     script.src = 'https://analytics.com/script.js';
321:     script.async = true;
322:     document.body.appendChild(script);
323:   });
324: </script>
325: \`\`\`
326: 
327: ### Results
328: 
329: - **Total Bundle:** 380KB ‚úÖ (reduced by 55%)
330: - **Main Bundle:** 180KB ‚úÖ
331: - **Vendor Bundle:** 80KB ‚úÖ
332: - **Load Time (3G):** 3.1s ‚úÖ (improved by 62%)
333: ```
334: 
335: ### Example 3: Image Optimization Strategy
336: 
337: ```markdown
338: ## Image Optimization
339: 
340: ### Current Issues
341: - 15 images totaling 12MB
342: - No modern formats (WebP, AVIF)
343: - No responsive images
344: - No lazy loading
345: 
346: ### Optimization Strategy
347: 
348: #### 1. Convert to Modern Formats
349: 
350: \`\`\`bash
351: # Install image optimization tools
352: npm install sharp
353: 
354: # Conversion script (optimize-images.js)
355: const sharp = require('sharp');
356: const fs = require('fs');
357: const path = require('path');
358: 
359: async function optimizeImage(inputPath, outputDir) {
360:   const filename = path.basename(inputPath, path.extname(inputPath));
361:   
362:   // Generate WebP
363:   await sharp(inputPath)
364:     .webp({ quality: 80 })
365:     .toFile(path.join(outputDir, \`\${filename}.webp\`));
366:   
367:   // Generate AVIF (best compression)
368:   await sharp(inputPath)
369:     .avif({ quality: 70 })
370:     .toFile(path.join(outputDir, \`\${filename}.avif\`));
371:   
372:   // Generate optimized JPEG fallback
373:   await sharp(inputPath)
374:     .jpeg({ quality: 80, progressive: true })
375:     .toFile(path.join(outputDir, \`\${filename}.jpg\`));
376: }
377: 
378: // Process all images
379: const images = fs.readdirSync('./images');
380: images.forEach(img => {
381:   optimizeImage(\`./images/\${img}\`, './images/optimized');
382: });
383: \`\`\`
384: 
385: #### 2. Implement Responsive Images
386: 
387: \`\`\`html
388: <!-- Responsive images with modern formats -->
389: <picture>
390:   <!-- AVIF for browsers that support it (best compression) -->
391:   <source 
392:     srcset="
393:       /images/hero-400.avif 400w,
394:       /images/hero-800.avif 800w,
395:       /images/hero-1200.avif 1200w
396:     "
397:     type="image/avif"
398:     sizes="(max-width: 768px) 100vw, 50vw"
399:   >
400:   
401:   <!-- WebP for browsers that support it -->
402:   <source 
403:     srcset="
404:       /images/hero-400.webp 400w,
405:       /images/hero-800.webp 800w,
406:       /images/hero-1200.webp 1200w
407:     "
408:     type="image/webp"
409:     sizes="(max-width: 768px) 100vw, 50vw"
410:   >
411:   
412:   <!-- JPEG fallback -->
413:   <img 
414:     src="/images/hero-800.jpg"
415:     srcset="
416:       /images/hero-400.jpg 400w,
417:       /images/hero-800.jpg 800w,
418:       /images/hero-1200.jpg 1200w
419:     "
420:     sizes="(max-width: 768px) 100vw, 50vw"
421:     alt="Hero image"
422:     width="1200"
423:     height="600"
424:     loading="lazy"
425:   >
426: </picture>
427: \`\`\`
428: 
429: #### 3. Lazy Loading
430: 
431: \`\`\`html
432: <!-- Native lazy loading -->
433: <img 
434:   src="/image.jpg" 
435:   alt="Description"
436:   loading="lazy"
437:   width="800"
438:   height="600"
439: >
440: 
441: <!-- Eager loading for above-the-fold images -->
442: <img 
443:   src="/hero.jpg" 
444:   alt="Hero"
445:   loading="eager"
446:   fetchpriority="high"
447: >
448: \`\`\`
449: 
450: #### 4. Next.js Image Component
451: 
452: \`\`\`javascript
453: import Image from 'next/image';
454: 
455: // Automatic optimization
456: <Image
457:   src="/hero.jpg"
458:   alt="Hero"
459:   width={1200}
460:   height={600}
461:   priority  // For above-the-fold images
462:   quality={80}
463: />
464: 
465: // Lazy loaded
466: <Image
467:   src="/product.jpg"
468:   alt="Product"
469:   width={400}
470:   height={300}
471:   loading="lazy"
472: />
473: \`\`\`
474: 
475: ### Results
476: 
477: | Metric | Before | After | Improvement |
478: |--------|--------|-------|-------------|
479: | Total Image Size | 12MB | 1.8MB | 85% reduction |
480: | LCP | 4.5s | 1.6s | 64% faster |
481: | Page Load (3G) | 18s | 4.2s | 77% faster |
482: ```
483: 
484: ## Best Practices
485: 
486: ### ‚úÖ Do This
487: 
488: - **Measure First** - Always establish baseline metrics before optimizing
489: - **Use Lighthouse** - Run audits regularly to track progress
490: - **Optimize Images** - Use modern formats (WebP, AVIF) and responsive images
491: - **Code Split** - Break large bundles into smaller chunks
492: - **Lazy Load** - Defer non-critical resources
493: - **Cache Aggressively** - Set proper cache headers for static assets
494: - **Minimize Main Thread Work** - Keep JavaScript execution under 50ms chunks
495: - **Preload Critical Resources** - Use `<link rel="preload">` for critical assets
496: - **Use CDN** - Serve static assets from CDN for faster delivery
497: - **Monitor Real Users** - Track Core Web Vitals from real users
498: 
499: ### ‚ùå Don't Do This
500: 
501: - **Don't Optimize Blindly** - Measure first, then optimize
502: - **Don't Ignore Mobile** - Test on real mobile devices and slow networks
503: - **Don't Block Rendering** - Avoid render-blocking CSS and JavaScript
504: - **Don't Load Everything Upfront** - Lazy load non-critical resources
505: - **Don't Forget Dimensions** - Always specify image width/height
506: - **Don't Use Synchronous Scripts** - Use async or defer attributes
507: - **Don't Ignore Third-Party Scripts** - They often cause performance issues
508: - **Don't Skip Compression** - Always compress and minify assets
509: 
510: ## Common Pitfalls
511: 
512: ### Problem: Optimized for Desktop but Slow on Mobile
513: **Symptoms:** Good Lighthouse score on desktop, poor on mobile
514: **Solution:**
515: - Test on real mobile devices
516: - Use Chrome DevTools mobile throttling
517: - Optimize for 3G/4G networks
518: - Reduce JavaScript execution time
519: ```bash
520: # Test with throttling
521: lighthouse https://yoursite.com --throttling.cpuSlowdownMultiplier=4
522: ```
523: 
524: ### Problem: Large JavaScript Bundle
525: **Symptoms:** Long Time to Interactive (TTI), high FID
526: **Solution:**
527: - Analyze bundle with webpack-bundle-analyzer
528: - Remove unused dependencies
529: - Implement code splitting
530: - Lazy load non-critical code
531: ```bash
532: # Analyze bundle
533: npx webpack-bundle-analyzer dist/stats.json
534: ```
535: 
536: ### Problem: Images Causing Layout Shifts
537: **Symptoms:** High CLS score, content jumping
538: **Solution:**
539: - Always specify width and height
540: - Use aspect-ratio CSS property
541: - Reserve space with skeleton loaders
542: ```css
543: img {
544:   aspect-ratio: 16 / 9;
545:   width: 100%;
546:   height: auto;
547: }
548: ```
549: 
550: ### Problem: Slow Server Response Time
551: **Symptoms:** High TTFB (Time to First Byte)
552: **Solution:**
553: - Implement server-side caching
554: - Use CDN for static assets
555: - Optimize database queries
556: - Consider static site generation (SSG)
557: ```javascript
558: // Next.js: Static generation
559: export async function getStaticProps() {
560:   const data = await fetchData();
561:   return {
562:     props: { data },
563:     revalidate: 60 // Regenerate every 60 seconds
564:   };
565: }
566: ```
567: 
568: ## Performance Checklist
569: 
570: ### Images
571: - [ ] Convert to modern formats (WebP, AVIF)
572: - [ ] Implement responsive images
573: - [ ] Add lazy loading
574: - [ ] Specify dimensions (width/height)
575: - [ ] Compress images (< 200KB each)
576: - [ ] Use CDN for delivery
577: 
578: ### JavaScript
579: - [ ] Bundle size < 200KB (gzipped)
580: - [ ] Implement code splitting
581: - [ ] Lazy load non-critical code
582: - [ ] Remove unused dependencies
583: - [ ] Minify and compress
584: - [ ] Use async/defer for scripts
585: 
586: ### CSS
587: - [ ] Inline critical CSS
588: - [ ] Defer non-critical CSS
589: - [ ] Remove unused CSS
590: - [ ] Minify CSS files
591: - [ ] Use CSS containment
592: 
593: ### Caching
594: - [ ] Set cache headers for static assets
595: - [ ] Implement service worker
596: - [ ] Use CDN caching
597: - [ ] Cache API responses
598: - [ ] Version static assets
599: 
600: ### Core Web Vitals
601: - [ ] LCP < 2.5s
602: - [ ] FID < 100ms
603: - [ ] CLS < 0.1
604: - [ ] TTFB < 600ms
605: - [ ] TTI < 3.8s
606: 
607: ## Performance Tools
608: 
609: ### Measurement Tools
610: - **Lighthouse** - Comprehensive performance audit
611: - **WebPageTest** - Detailed waterfall analysis
612: - **Chrome DevTools** - Performance profiling
613: - **PageSpeed Insights** - Real user metrics
614: - **Web Vitals Extension** - Monitor Core Web Vitals
615: 
616: ### Analysis Tools
617: - **webpack-bundle-analyzer** - Visualize bundle composition
618: - **source-map-explorer** - Analyze bundle size
619: - **Bundlephobia** - Check package sizes before installing
620: - **ImageOptim** - Image compression tool
621: 
622: ### Monitoring Tools
623: - **Google Analytics** - Track Core Web Vitals
624: - **Sentry** - Performance monitoring
625: - **New Relic** - Application performance monitoring
626: - **Datadog** - Real user monitoring
627: 
628: ## Related Skills
629: 
630: - `@react-best-practices` - React performance patterns
631: - `@frontend-dev-guidelines` - Frontend development standards
632: - `@systematic-debugging` - Debug performance issues
633: - `@senior-architect` - Architecture for performance
634: 
635: ## Additional Resources
636: 
637: - [Web.dev Performance](https://web.dev/performance/)
638: - [Core Web Vitals](https://web.dev/vitals/)
639: - [Lighthouse Documentation](https://developers.google.com/web/tools/lighthouse)
640: - [MDN Performance Guide](https://developer.mozilla.org/en-US/docs/Web/Performance)
641: - [Next.js Performance](https://nextjs.org/docs/advanced-features/measuring-performance)
642: - [Image Optimization Guide](https://web.dev/fast/#optimize-your-images)
643: 
644: ---
645: 
646: **Pro Tip:** Focus on Core Web Vitals (LCP, FID, CLS) first - they have the biggest impact on user experience and SEO rankings!
</file>

<file path=".gemini/commands/speckit.analyze.toml">
  1: description = "Perform a non-destructive cross-artifact consistency and quality analysis across spec.md, plan.md, and tasks.md after task generation."
  2: 
  3: prompt = """
  4: ---
  5: description: Perform a non-destructive cross-artifact consistency and quality analysis across spec.md, plan.md, and tasks.md after task generation.
  6: ---
  7: 
  8: ## User Input
  9: 
 10: ```text
 11: $ARGUMENTS
 12: ```
 13: 
 14: You **MUST** consider the user input before proceeding (if not empty).
 15: 
 16: ## Goal
 17: 
 18: Identify inconsistencies, duplications, ambiguities, and underspecified items across the three core artifacts (`spec.md`, `plan.md`, `tasks.md`) before implementation. This command MUST run only after `/speckit.tasks` has successfully produced a complete `tasks.md`.
 19: 
 20: ## Operating Constraints
 21: 
 22: **STRICTLY READ-ONLY**: Do **not** modify any files. Output a structured analysis report. Offer an optional remediation plan (user must explicitly approve before any follow-up editing commands would be invoked manually).
 23: 
 24: **Constitution Authority**: The project constitution (`.specify/memory/constitution.md`) is **non-negotiable** within this analysis scope. Constitution conflicts are automatically CRITICAL and require adjustment of the spec, plan, or tasks‚Äînot dilution, reinterpretation, or silent ignoring of the principle. If a principle itself needs to change, that must occur in a separate, explicit constitution update outside `/speckit.analyze`.
 25: 
 26: ## Execution Steps
 27: 
 28: ### 1. Initialize Analysis Context
 29: 
 30: Run `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` once from repo root and parse JSON for FEATURE_DIR and AVAILABLE_DOCS. Derive absolute paths:
 31: 
 32: - SPEC = FEATURE_DIR/spec.md
 33: - PLAN = FEATURE_DIR/plan.md
 34: - TASKS = FEATURE_DIR/tasks.md
 35: 
 36: Abort with an error message if any required file is missing (instruct the user to run missing prerequisite command).
 37: For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
 38: 
 39: ### 2. Load Artifacts (Progressive Disclosure)
 40: 
 41: Load only the minimal necessary context from each artifact:
 42: 
 43: **From spec.md:**
 44: 
 45: - Overview/Context
 46: - Functional Requirements
 47: - Non-Functional Requirements
 48: - User Stories
 49: - Edge Cases (if present)
 50: 
 51: **From plan.md:**
 52: 
 53: - Architecture/stack choices
 54: - Data Model references
 55: - Phases
 56: - Technical constraints
 57: 
 58: **From tasks.md:**
 59: 
 60: - Task IDs
 61: - Descriptions
 62: - Phase grouping
 63: - Parallel markers [P]
 64: - Referenced file paths
 65: 
 66: **From constitution:**
 67: 
 68: - Load `.specify/memory/constitution.md` for principle validation
 69: 
 70: ### 3. Build Semantic Models
 71: 
 72: Create internal representations (do not include raw artifacts in output):
 73: 
 74: - **Requirements inventory**: Each functional + non-functional requirement with a stable key (derive slug based on imperative phrase; e.g., "User can upload file" ‚Üí `user-can-upload-file`)
 75: - **User story/action inventory**: Discrete user actions with acceptance criteria
 76: - **Task coverage mapping**: Map each task to one or more requirements or stories (inference by keyword / explicit reference patterns like IDs or key phrases)
 77: - **Constitution rule set**: Extract principle names and MUST/SHOULD normative statements
 78: 
 79: ### 4. Detection Passes (Token-Efficient Analysis)
 80: 
 81: Focus on high-signal findings. Limit to 50 findings total; aggregate remainder in overflow summary.
 82: 
 83: #### A. Duplication Detection
 84: 
 85: - Identify near-duplicate requirements
 86: - Mark lower-quality phrasing for consolidation
 87: 
 88: #### B. Ambiguity Detection
 89: 
 90: - Flag vague adjectives (fast, scalable, secure, intuitive, robust) lacking measurable criteria
 91: - Flag unresolved placeholders (TODO, TKTK, ???, `<placeholder>`, etc.)
 92: 
 93: #### C. Underspecification
 94: 
 95: - Requirements with verbs but missing object or measurable outcome
 96: - User stories missing acceptance criteria alignment
 97: - Tasks referencing files or components not defined in spec/plan
 98: 
 99: #### D. Constitution Alignment
100: 
101: - Any requirement or plan element conflicting with a MUST principle
102: - Missing mandated sections or quality gates from constitution
103: 
104: #### E. Coverage Gaps
105: 
106: - Requirements with zero associated tasks
107: - Tasks with no mapped requirement/story
108: - Non-functional requirements not reflected in tasks (e.g., performance, security)
109: 
110: #### F. Inconsistency
111: 
112: - Terminology drift (same concept named differently across files)
113: - Data entities referenced in plan but absent in spec (or vice versa)
114: - Task ordering contradictions (e.g., integration tasks before foundational setup tasks without dependency note)
115: - Conflicting requirements (e.g., one requires Next.js while other specifies Vue)
116: 
117: ### 5. Severity Assignment
118: 
119: Use this heuristic to prioritize findings:
120: 
121: - **CRITICAL**: Violates constitution MUST, missing core spec artifact, or requirement with zero coverage that blocks baseline functionality
122: - **HIGH**: Duplicate or conflicting requirement, ambiguous security/performance attribute, untestable acceptance criterion
123: - **MEDIUM**: Terminology drift, missing non-functional task coverage, underspecified edge case
124: - **LOW**: Style/wording improvements, minor redundancy not affecting execution order
125: 
126: ### 6. Produce Compact Analysis Report
127: 
128: Output a Markdown report (no file writes) with the following structure:
129: 
130: ## Specification Analysis Report
131: 
132: | ID | Category | Severity | Location(s) | Summary | Recommendation |
133: |----|----------|----------|-------------|---------|----------------|
134: | A1 | Duplication | HIGH | spec.md:L120-134 | Two similar requirements ... | Merge phrasing; keep clearer version |
135: 
136: (Add one row per finding; generate stable IDs prefixed by category initial.)
137: 
138: **Coverage Summary Table:**
139: 
140: | Requirement Key | Has Task? | Task IDs | Notes |
141: |-----------------|-----------|----------|-------|
142: 
143: **Constitution Alignment Issues:** (if any)
144: 
145: **Unmapped Tasks:** (if any)
146: 
147: **Metrics:**
148: 
149: - Total Requirements
150: - Total Tasks
151: - Coverage % (requirements with >=1 task)
152: - Ambiguity Count
153: - Duplication Count
154: - Critical Issues Count
155: 
156: ### 7. Provide Next Actions
157: 
158: At end of report, output a concise Next Actions block:
159: 
160: - If CRITICAL issues exist: Recommend resolving before `/speckit.implement`
161: - If only LOW/MEDIUM: User may proceed, but provide improvement suggestions
162: - Provide explicit command suggestions: e.g., "Run /speckit.specify with refinement", "Run /speckit.plan to adjust architecture", "Manually edit tasks.md to add coverage for 'performance-metrics'"
163: 
164: ### 8. Offer Remediation
165: 
166: Ask the user: "Would you like me to suggest concrete remediation edits for the top N issues?" (Do NOT apply them automatically.)
167: 
168: ## Operating Principles
169: 
170: ### Context Efficiency
171: 
172: - **Minimal high-signal tokens**: Focus on actionable findings, not exhaustive documentation
173: - **Progressive disclosure**: Load artifacts incrementally; don't dump all content into analysis
174: - **Token-efficient output**: Limit findings table to 50 rows; summarize overflow
175: - **Deterministic results**: Rerunning without changes should produce consistent IDs and counts
176: 
177: ### Analysis Guidelines
178: 
179: - **NEVER modify files** (this is read-only analysis)
180: - **NEVER hallucinate missing sections** (if absent, report them accurately)
181: - **Prioritize constitution violations** (these are always CRITICAL)
182: - **Use examples over exhaustive rules** (cite specific instances, not generic patterns)
183: - **Report zero issues gracefully** (emit success report with coverage statistics)
184: 
185: ## Context
186: 
187: {{args}}
188: """
</file>

<file path=".gemini/commands/speckit.checklist.toml">
  1: description = "Generate a custom checklist for the current feature based on user requirements."
  2: 
  3: prompt = """
  4: ---
  5: description: Generate a custom checklist for the current feature based on user requirements.
  6: ---
  7: 
  8: ## Checklist Purpose: "Unit Tests for English"
  9: 
 10: **CRITICAL CONCEPT**: Checklists are **UNIT TESTS FOR REQUIREMENTS WRITING** - they validate the quality, clarity, and completeness of requirements in a given domain.
 11: 
 12: **NOT for verification/testing**:
 13: 
 14: - ‚ùå NOT "Verify the button clicks correctly"
 15: - ‚ùå NOT "Test error handling works"
 16: - ‚ùå NOT "Confirm the API returns 200"
 17: - ‚ùå NOT checking if code/implementation matches the spec
 18: 
 19: **FOR requirements quality validation**:
 20: 
 21: - ‚úÖ "Are visual hierarchy requirements defined for all card types?" (completeness)
 22: - ‚úÖ "Is 'prominent display' quantified with specific sizing/positioning?" (clarity)
 23: - ‚úÖ "Are hover state requirements consistent across all interactive elements?" (consistency)
 24: - ‚úÖ "Are accessibility requirements defined for keyboard navigation?" (coverage)
 25: - ‚úÖ "Does the spec define what happens when logo image fails to load?" (edge cases)
 26: 
 27: **Metaphor**: If your spec is code written in English, the checklist is its unit test suite. You're testing whether the requirements are well-written, complete, unambiguous, and ready for implementation - NOT whether the implementation works.
 28: 
 29: ## User Input
 30: 
 31: ```text
 32: $ARGUMENTS
 33: ```
 34: 
 35: You **MUST** consider the user input before proceeding (if not empty).
 36: 
 37: ## Execution Steps
 38: 
 39: 1. **Setup**: Run `.specify/scripts/bash/check-prerequisites.sh --json` from repo root and parse JSON for FEATURE_DIR and AVAILABLE_DOCS list.
 40:    - All file paths must be absolute.
 41:    - For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
 42: 
 43: 2. **Clarify intent (dynamic)**: Derive up to THREE initial contextual clarifying questions (no pre-baked catalog). They MUST:
 44:    - Be generated from the user's phrasing + extracted signals from spec/plan/tasks
 45:    - Only ask about information that materially changes checklist content
 46:    - Be skipped individually if already unambiguous in `$ARGUMENTS`
 47:    - Prefer precision over breadth
 48: 
 49:    Generation algorithm:
 50:    1. Extract signals: feature domain keywords (e.g., auth, latency, UX, API), risk indicators ("critical", "must", "compliance"), stakeholder hints ("QA", "review", "security team"), and explicit deliverables ("a11y", "rollback", "contracts").
 51:    2. Cluster signals into candidate focus areas (max 4) ranked by relevance.
 52:    3. Identify probable audience & timing (author, reviewer, QA, release) if not explicit.
 53:    4. Detect missing dimensions: scope breadth, depth/rigor, risk emphasis, exclusion boundaries, measurable acceptance criteria.
 54:    5. Formulate questions chosen from these archetypes:
 55:       - Scope refinement (e.g., "Should this include integration touchpoints with X and Y or stay limited to local module correctness?")
 56:       - Risk prioritization (e.g., "Which of these potential risk areas should receive mandatory gating checks?")
 57:       - Depth calibration (e.g., "Is this a lightweight pre-commit sanity list or a formal release gate?")
 58:       - Audience framing (e.g., "Will this be used by the author only or peers during PR review?")
 59:       - Boundary exclusion (e.g., "Should we explicitly exclude performance tuning items this round?")
 60:       - Scenario class gap (e.g., "No recovery flows detected‚Äîare rollback / partial failure paths in scope?")
 61: 
 62:    Question formatting rules:
 63:    - If presenting options, generate a compact table with columns: Option | Candidate | Why It Matters
 64:    - Limit to A‚ÄìE options maximum; omit table if a free-form answer is clearer
 65:    - Never ask the user to restate what they already said
 66:    - Avoid speculative categories (no hallucination). If uncertain, ask explicitly: "Confirm whether X belongs in scope."
 67: 
 68:    Defaults when interaction impossible:
 69:    - Depth: Standard
 70:    - Audience: Reviewer (PR) if code-related; Author otherwise
 71:    - Focus: Top 2 relevance clusters
 72: 
 73:    Output the questions (label Q1/Q2/Q3). After answers: if ‚â•2 scenario classes (Alternate / Exception / Recovery / Non-Functional domain) remain unclear, you MAY ask up to TWO more targeted follow‚Äëups (Q4/Q5) with a one-line justification each (e.g., "Unresolved recovery path risk"). Do not exceed five total questions. Skip escalation if user explicitly declines more.
 74: 
 75: 3. **Understand user request**: Combine `$ARGUMENTS` + clarifying answers:
 76:    - Derive checklist theme (e.g., security, review, deploy, ux)
 77:    - Consolidate explicit must-have items mentioned by user
 78:    - Map focus selections to category scaffolding
 79:    - Infer any missing context from spec/plan/tasks (do NOT hallucinate)
 80: 
 81: 4. **Load feature context**: Read from FEATURE_DIR:
 82:    - spec.md: Feature requirements and scope
 83:    - plan.md (if exists): Technical details, dependencies
 84:    - tasks.md (if exists): Implementation tasks
 85: 
 86:    **Context Loading Strategy**:
 87:    - Load only necessary portions relevant to active focus areas (avoid full-file dumping)
 88:    - Prefer summarizing long sections into concise scenario/requirement bullets
 89:    - Use progressive disclosure: add follow-on retrieval only if gaps detected
 90:    - If source docs are large, generate interim summary items instead of embedding raw text
 91: 
 92: 5. **Generate checklist** - Create "Unit Tests for Requirements":
 93:    - Create `FEATURE_DIR/checklists/` directory if it doesn't exist
 94:    - Generate unique checklist filename:
 95:      - Use short, descriptive name based on domain (e.g., `ux.md`, `api.md`, `security.md`)
 96:      - Format: `[domain].md`
 97:      - If file exists, append to existing file
 98:    - Number items sequentially starting from CHK001
 99:    - Each `/speckit.checklist` run creates a NEW file (never overwrites existing checklists)
100: 
101:    **CORE PRINCIPLE - Test the Requirements, Not the Implementation**:
102:    Every checklist item MUST evaluate the REQUIREMENTS THEMSELVES for:
103:    - **Completeness**: Are all necessary requirements present?
104:    - **Clarity**: Are requirements unambiguous and specific?
105:    - **Consistency**: Do requirements align with each other?
106:    - **Measurability**: Can requirements be objectively verified?
107:    - **Coverage**: Are all scenarios/edge cases addressed?
108: 
109:    **Category Structure** - Group items by requirement quality dimensions:
110:    - **Requirement Completeness** (Are all necessary requirements documented?)
111:    - **Requirement Clarity** (Are requirements specific and unambiguous?)
112:    - **Requirement Consistency** (Do requirements align without conflicts?)
113:    - **Acceptance Criteria Quality** (Are success criteria measurable?)
114:    - **Scenario Coverage** (Are all flows/cases addressed?)
115:    - **Edge Case Coverage** (Are boundary conditions defined?)
116:    - **Non-Functional Requirements** (Performance, Security, Accessibility, etc. - are they specified?)
117:    - **Dependencies & Assumptions** (Are they documented and validated?)
118:    - **Ambiguities & Conflicts** (What needs clarification?)
119: 
120:    **HOW TO WRITE CHECKLIST ITEMS - "Unit Tests for English"**:
121: 
122:    ‚ùå **WRONG** (Testing implementation):
123:    - "Verify landing page displays 3 episode cards"
124:    - "Test hover states work on desktop"
125:    - "Confirm logo click navigates home"
126: 
127:    ‚úÖ **CORRECT** (Testing requirements quality):
128:    - "Are the exact number and layout of featured episodes specified?" [Completeness]
129:    - "Is 'prominent display' quantified with specific sizing/positioning?" [Clarity]
130:    - "Are hover state requirements consistent across all interactive elements?" [Consistency]
131:    - "Are keyboard navigation requirements defined for all interactive UI?" [Coverage]
132:    - "Is the fallback behavior specified when logo image fails to load?" [Edge Cases]
133:    - "Are loading states defined for asynchronous episode data?" [Completeness]
134:    - "Does the spec define visual hierarchy for competing UI elements?" [Clarity]
135: 
136:    **ITEM STRUCTURE**:
137:    Each item should follow this pattern:
138:    - Question format asking about requirement quality
139:    - Focus on what's WRITTEN (or not written) in the spec/plan
140:    - Include quality dimension in brackets [Completeness/Clarity/Consistency/etc.]
141:    - Reference spec section `[Spec ¬ßX.Y]` when checking existing requirements
142:    - Use `[Gap]` marker when checking for missing requirements
143: 
144:    **EXAMPLES BY QUALITY DIMENSION**:
145: 
146:    Completeness:
147:    - "Are error handling requirements defined for all API failure modes? [Gap]"
148:    - "Are accessibility requirements specified for all interactive elements? [Completeness]"
149:    - "Are mobile breakpoint requirements defined for responsive layouts? [Gap]"
150: 
151:    Clarity:
152:    - "Is 'fast loading' quantified with specific timing thresholds? [Clarity, Spec ¬ßNFR-2]"
153:    - "Are 'related episodes' selection criteria explicitly defined? [Clarity, Spec ¬ßFR-5]"
154:    - "Is 'prominent' defined with measurable visual properties? [Ambiguity, Spec ¬ßFR-4]"
155: 
156:    Consistency:
157:    - "Do navigation requirements align across all pages? [Consistency, Spec ¬ßFR-10]"
158:    - "Are card component requirements consistent between landing and detail pages? [Consistency]"
159: 
160:    Coverage:
161:    - "Are requirements defined for zero-state scenarios (no episodes)? [Coverage, Edge Case]"
162:    - "Are concurrent user interaction scenarios addressed? [Coverage, Gap]"
163:    - "Are requirements specified for partial data loading failures? [Coverage, Exception Flow]"
164: 
165:    Measurability:
166:    - "Are visual hierarchy requirements measurable/testable? [Acceptance Criteria, Spec ¬ßFR-1]"
167:    - "Can 'balanced visual weight' be objectively verified? [Measurability, Spec ¬ßFR-2]"
168: 
169:    **Scenario Classification & Coverage** (Requirements Quality Focus):
170:    - Check if requirements exist for: Primary, Alternate, Exception/Error, Recovery, Non-Functional scenarios
171:    - For each scenario class, ask: "Are [scenario type] requirements complete, clear, and consistent?"
172:    - If scenario class missing: "Are [scenario type] requirements intentionally excluded or missing? [Gap]"
173:    - Include resilience/rollback when state mutation occurs: "Are rollback requirements defined for migration failures? [Gap]"
174: 
175:    **Traceability Requirements**:
176:    - MINIMUM: ‚â•80% of items MUST include at least one traceability reference
177:    - Each item should reference: spec section `[Spec ¬ßX.Y]`, or use markers: `[Gap]`, `[Ambiguity]`, `[Conflict]`, `[Assumption]`
178:    - If no ID system exists: "Is a requirement & acceptance criteria ID scheme established? [Traceability]"
179: 
180:    **Surface & Resolve Issues** (Requirements Quality Problems):
181:    Ask questions about the requirements themselves:
182:    - Ambiguities: "Is the term 'fast' quantified with specific metrics? [Ambiguity, Spec ¬ßNFR-1]"
183:    - Conflicts: "Do navigation requirements conflict between ¬ßFR-10 and ¬ßFR-10a? [Conflict]"
184:    - Assumptions: "Is the assumption of 'always available podcast API' validated? [Assumption]"
185:    - Dependencies: "Are external podcast API requirements documented? [Dependency, Gap]"
186:    - Missing definitions: "Is 'visual hierarchy' defined with measurable criteria? [Gap]"
187: 
188:    **Content Consolidation**:
189:    - Soft cap: If raw candidate items > 40, prioritize by risk/impact
190:    - Merge near-duplicates checking the same requirement aspect
191:    - If >5 low-impact edge cases, create one item: "Are edge cases X, Y, Z addressed in requirements? [Coverage]"
192: 
193:    **üö´ ABSOLUTELY PROHIBITED** - These make it an implementation test, not a requirements test:
194:    - ‚ùå Any item starting with "Verify", "Test", "Confirm", "Check" + implementation behavior
195:    - ‚ùå References to code execution, user actions, system behavior
196:    - ‚ùå "Displays correctly", "works properly", "functions as expected"
197:    - ‚ùå "Click", "navigate", "render", "load", "execute"
198:    - ‚ùå Test cases, test plans, QA procedures
199:    - ‚ùå Implementation details (frameworks, APIs, algorithms)
200: 
201:    **‚úÖ REQUIRED PATTERNS** - These test requirements quality:
202:    - ‚úÖ "Are [requirement type] defined/specified/documented for [scenario]?"
203:    - ‚úÖ "Is [vague term] quantified/clarified with specific criteria?"
204:    - ‚úÖ "Are requirements consistent between [section A] and [section B]?"
205:    - ‚úÖ "Can [requirement] be objectively measured/verified?"
206:    - ‚úÖ "Are [edge cases/scenarios] addressed in requirements?"
207:    - ‚úÖ "Does the spec define [missing aspect]?"
208: 
209: 6. **Structure Reference**: Generate the checklist following the canonical template in `.specify/templates/checklist-template.md` for title, meta section, category headings, and ID formatting. If template is unavailable, use: H1 title, purpose/created meta lines, `##` category sections containing `- [ ] CHK### <requirement item>` lines with globally incrementing IDs starting at CHK001.
210: 
211: 7. **Report**: Output full path to created checklist, item count, and remind user that each run creates a new file. Summarize:
212:    - Focus areas selected
213:    - Depth level
214:    - Actor/timing
215:    - Any explicit user-specified must-have items incorporated
216: 
217: **Important**: Each `/speckit.checklist` command invocation creates a checklist file using short, descriptive names unless file already exists. This allows:
218: 
219: - Multiple checklists of different types (e.g., `ux.md`, `test.md`, `security.md`)
220: - Simple, memorable filenames that indicate checklist purpose
221: - Easy identification and navigation in the `checklists/` folder
222: 
223: To avoid clutter, use descriptive types and clean up obsolete checklists when done.
224: 
225: ## Example Checklist Types & Sample Items
226: 
227: **UX Requirements Quality:** `ux.md`
228: 
229: Sample items (testing the requirements, NOT the implementation):
230: 
231: - "Are visual hierarchy requirements defined with measurable criteria? [Clarity, Spec ¬ßFR-1]"
232: - "Is the number and positioning of UI elements explicitly specified? [Completeness, Spec ¬ßFR-1]"
233: - "Are interaction state requirements (hover, focus, active) consistently defined? [Consistency]"
234: - "Are accessibility requirements specified for all interactive elements? [Coverage, Gap]"
235: - "Is fallback behavior defined when images fail to load? [Edge Case, Gap]"
236: - "Can 'prominent display' be objectively measured? [Measurability, Spec ¬ßFR-4]"
237: 
238: **API Requirements Quality:** `api.md`
239: 
240: Sample items:
241: 
242: - "Are error response formats specified for all failure scenarios? [Completeness]"
243: - "Are rate limiting requirements quantified with specific thresholds? [Clarity]"
244: - "Are authentication requirements consistent across all endpoints? [Consistency]"
245: - "Are retry/timeout requirements defined for external dependencies? [Coverage, Gap]"
246: - "Is versioning strategy documented in requirements? [Gap]"
247: 
248: **Performance Requirements Quality:** `performance.md`
249: 
250: Sample items:
251: 
252: - "Are performance requirements quantified with specific metrics? [Clarity]"
253: - "Are performance targets defined for all critical user journeys? [Coverage]"
254: - "Are performance requirements under different load conditions specified? [Completeness]"
255: - "Can performance requirements be objectively measured? [Measurability]"
256: - "Are degradation requirements defined for high-load scenarios? [Edge Case, Gap]"
257: 
258: **Security Requirements Quality:** `security.md`
259: 
260: Sample items:
261: 
262: - "Are authentication requirements specified for all protected resources? [Coverage]"
263: - "Are data protection requirements defined for sensitive information? [Completeness]"
264: - "Is the threat model documented and requirements aligned to it? [Traceability]"
265: - "Are security requirements consistent with compliance obligations? [Consistency]"
266: - "Are security failure/breach response requirements defined? [Gap, Exception Flow]"
267: 
268: ## Anti-Examples: What NOT To Do
269: 
270: **‚ùå WRONG - These test implementation, not requirements:**
271: 
272: ```markdown
273: - [ ] CHK001 - Verify landing page displays 3 episode cards [Spec ¬ßFR-001]
274: - [ ] CHK002 - Test hover states work correctly on desktop [Spec ¬ßFR-003]
275: - [ ] CHK003 - Confirm logo click navigates to home page [Spec ¬ßFR-010]
276: - [ ] CHK004 - Check that related episodes section shows 3-5 items [Spec ¬ßFR-005]
277: ```
278: 
279: **‚úÖ CORRECT - These test requirements quality:**
280: 
281: ```markdown
282: - [ ] CHK001 - Are the number and layout of featured episodes explicitly specified? [Completeness, Spec ¬ßFR-001]
283: - [ ] CHK002 - Are hover state requirements consistently defined for all interactive elements? [Consistency, Spec ¬ßFR-003]
284: - [ ] CHK003 - Are navigation requirements clear for all clickable brand elements? [Clarity, Spec ¬ßFR-010]
285: - [ ] CHK004 - Is the selection criteria for related episodes documented? [Gap, Spec ¬ßFR-005]
286: - [ ] CHK005 - Are loading state requirements defined for asynchronous episode data? [Gap]
287: - [ ] CHK006 - Can "visual hierarchy" requirements be objectively measured? [Measurability, Spec ¬ßFR-001]
288: ```
289: 
290: **Key Differences:**
291: 
292: - Wrong: Tests if the system works correctly
293: - Correct: Tests if the requirements are written correctly
294: - Wrong: Verification of behavior
295: - Correct: Validation of requirement quality
296: - Wrong: "Does it do X?"
297: - Correct: "Is X clearly specified?"
298: """
</file>

<file path=".gemini/commands/speckit.clarify.toml">
  1: description = "Identify underspecified areas in the current feature spec by asking up to 5 highly targeted clarification questions and encoding answers back into the spec."
  2: 
  3: prompt = """
  4: ---
  5: description: Identify underspecified areas in the current feature spec by asking up to 5 highly targeted clarification questions and encoding answers back into the spec.
  6: handoffs: 
  7:   - label: Build Technical Plan
  8:     agent: speckit.plan
  9:     prompt: Create a plan for the spec. I am building with...
 10: ---
 11: 
 12: ## User Input
 13: 
 14: ```text
 15: $ARGUMENTS
 16: ```
 17: 
 18: You **MUST** consider the user input before proceeding (if not empty).
 19: 
 20: ## Outline
 21: 
 22: Goal: Detect and reduce ambiguity or missing decision points in the active feature specification and record the clarifications directly in the spec file.
 23: 
 24: Note: This clarification workflow is expected to run (and be completed) BEFORE invoking `/speckit.plan`. If the user explicitly states they are skipping clarification (e.g., exploratory spike), you may proceed, but must warn that downstream rework risk increases.
 25: 
 26: Execution steps:
 27: 
 28: 1. Run `.specify/scripts/bash/check-prerequisites.sh --json --paths-only` from repo root **once** (combined `--json --paths-only` mode / `-Json -PathsOnly`). Parse minimal JSON payload fields:
 29:    - `FEATURE_DIR`
 30:    - `FEATURE_SPEC`
 31:    - (Optionally capture `IMPL_PLAN`, `TASKS` for future chained flows.)
 32:    - If JSON parsing fails, abort and instruct user to re-run `/speckit.specify` or verify feature branch environment.
 33:    - For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
 34: 
 35: 2. Load the current spec file. Perform a structured ambiguity & coverage scan using this taxonomy. For each category, mark status: Clear / Partial / Missing. Produce an internal coverage map used for prioritization (do not output raw map unless no questions will be asked).
 36: 
 37:    Functional Scope & Behavior:
 38:    - Core user goals & success criteria
 39:    - Explicit out-of-scope declarations
 40:    - User roles / personas differentiation
 41: 
 42:    Domain & Data Model:
 43:    - Entities, attributes, relationships
 44:    - Identity & uniqueness rules
 45:    - Lifecycle/state transitions
 46:    - Data volume / scale assumptions
 47: 
 48:    Interaction & UX Flow:
 49:    - Critical user journeys / sequences
 50:    - Error/empty/loading states
 51:    - Accessibility or localization notes
 52: 
 53:    Non-Functional Quality Attributes:
 54:    - Performance (latency, throughput targets)
 55:    - Scalability (horizontal/vertical, limits)
 56:    - Reliability & availability (uptime, recovery expectations)
 57:    - Observability (logging, metrics, tracing signals)
 58:    - Security & privacy (authN/Z, data protection, threat assumptions)
 59:    - Compliance / regulatory constraints (if any)
 60: 
 61:    Integration & External Dependencies:
 62:    - External services/APIs and failure modes
 63:    - Data import/export formats
 64:    - Protocol/versioning assumptions
 65: 
 66:    Edge Cases & Failure Handling:
 67:    - Negative scenarios
 68:    - Rate limiting / throttling
 69:    - Conflict resolution (e.g., concurrent edits)
 70: 
 71:    Constraints & Tradeoffs:
 72:    - Technical constraints (language, storage, hosting)
 73:    - Explicit tradeoffs or rejected alternatives
 74: 
 75:    Terminology & Consistency:
 76:    - Canonical glossary terms
 77:    - Avoided synonyms / deprecated terms
 78: 
 79:    Completion Signals:
 80:    - Acceptance criteria testability
 81:    - Measurable Definition of Done style indicators
 82: 
 83:    Misc / Placeholders:
 84:    - TODO markers / unresolved decisions
 85:    - Ambiguous adjectives ("robust", "intuitive") lacking quantification
 86: 
 87:    For each category with Partial or Missing status, add a candidate question opportunity unless:
 88:    - Clarification would not materially change implementation or validation strategy
 89:    - Information is better deferred to planning phase (note internally)
 90: 
 91: 3. Generate (internally) a prioritized queue of candidate clarification questions (maximum 5). Do NOT output them all at once. Apply these constraints:
 92:     - Maximum of 10 total questions across the whole session.
 93:     - Each question must be answerable with EITHER:
 94:        - A short multiple‚Äëchoice selection (2‚Äì5 distinct, mutually exclusive options), OR
 95:        - A one-word / short‚Äëphrase answer (explicitly constrain: "Answer in <=5 words").
 96:     - Only include questions whose answers materially impact architecture, data modeling, task decomposition, test design, UX behavior, operational readiness, or compliance validation.
 97:     - Ensure category coverage balance: attempt to cover the highest impact unresolved categories first; avoid asking two low-impact questions when a single high-impact area (e.g., security posture) is unresolved.
 98:     - Exclude questions already answered, trivial stylistic preferences, or plan-level execution details (unless blocking correctness).
 99:     - Favor clarifications that reduce downstream rework risk or prevent misaligned acceptance tests.
100:     - If more than 5 categories remain unresolved, select the top 5 by (Impact * Uncertainty) heuristic.
101: 
102: 4. Sequential questioning loop (interactive):
103:     - Present EXACTLY ONE question at a time.
104:     - For multiple‚Äëchoice questions:
105:        - **Analyze all options** and determine the **most suitable option** based on:
106:           - Best practices for the project type
107:           - Common patterns in similar implementations
108:           - Risk reduction (security, performance, maintainability)
109:           - Alignment with any explicit project goals or constraints visible in the spec
110:        - Present your **recommended option prominently** at the top with clear reasoning (1-2 sentences explaining why this is the best choice).
111:        - Format as: `**Recommended:** Option [X] - <reasoning>`
112:        - Then render all options as a Markdown table:
113: 
114:        | Option | Description |
115:        |--------|-------------|
116:        | A | <Option A description> |
117:        | B | <Option B description> |
118:        | C | <Option C description> (add D/E as needed up to 5) |
119:        | Short | Provide a different short answer (<=5 words) (Include only if free-form alternative is appropriate) |
120: 
121:        - After the table, add: `You can reply with the option letter (e.g., "A"), accept the recommendation by saying "yes" or "recommended", or provide your own short answer.`
122:     - For short‚Äëanswer style (no meaningful discrete options):
123:        - Provide your **suggested answer** based on best practices and context.
124:        - Format as: `**Suggested:** <your proposed answer> - <brief reasoning>`
125:        - Then output: `Format: Short answer (<=5 words). You can accept the suggestion by saying "yes" or "suggested", or provide your own answer.`
126:     - After the user answers:
127:        - If the user replies with "yes", "recommended", or "suggested", use your previously stated recommendation/suggestion as the answer.
128:        - Otherwise, validate the answer maps to one option or fits the <=5 word constraint.
129:        - If ambiguous, ask for a quick disambiguation (count still belongs to same question; do not advance).
130:        - Once satisfactory, record it in working memory (do not yet write to disk) and move to the next queued question.
131:     - Stop asking further questions when:
132:        - All critical ambiguities resolved early (remaining queued items become unnecessary), OR
133:        - User signals completion ("done", "good", "no more"), OR
134:        - You reach 5 asked questions.
135:     - Never reveal future queued questions in advance.
136:     - If no valid questions exist at start, immediately report no critical ambiguities.
137: 
138: 5. Integration after EACH accepted answer (incremental update approach):
139:     - Maintain in-memory representation of the spec (loaded once at start) plus the raw file contents.
140:     - For the first integrated answer in this session:
141:        - Ensure a `## Clarifications` section exists (create it just after the highest-level contextual/overview section per the spec template if missing).
142:        - Under it, create (if not present) a `### Session YYYY-MM-DD` subheading for today.
143:     - Append a bullet line immediately after acceptance: `- Q: <question> ‚Üí A: <final answer>`.
144:     - Then immediately apply the clarification to the most appropriate section(s):
145:        - Functional ambiguity ‚Üí Update or add a bullet in Functional Requirements.
146:        - User interaction / actor distinction ‚Üí Update User Stories or Actors subsection (if present) with clarified role, constraint, or scenario.
147:        - Data shape / entities ‚Üí Update Data Model (add fields, types, relationships) preserving ordering; note added constraints succinctly.
148:        - Non-functional constraint ‚Üí Add/modify measurable criteria in Non-Functional / Quality Attributes section (convert vague adjective to metric or explicit target).
149:        - Edge case / negative flow ‚Üí Add a new bullet under Edge Cases / Error Handling (or create such subsection if template provides placeholder for it).
150:        - Terminology conflict ‚Üí Normalize term across spec; retain original only if necessary by adding `(formerly referred to as "X")` once.
151:     - If the clarification invalidates an earlier ambiguous statement, replace that statement instead of duplicating; leave no obsolete contradictory text.
152:     - Save the spec file AFTER each integration to minimize risk of context loss (atomic overwrite).
153:     - Preserve formatting: do not reorder unrelated sections; keep heading hierarchy intact.
154:     - Keep each inserted clarification minimal and testable (avoid narrative drift).
155: 
156: 6. Validation (performed after EACH write plus final pass):
157:    - Clarifications session contains exactly one bullet per accepted answer (no duplicates).
158:    - Total asked (accepted) questions ‚â§ 5.
159:    - Updated sections contain no lingering vague placeholders the new answer was meant to resolve.
160:    - No contradictory earlier statement remains (scan for now-invalid alternative choices removed).
161:    - Markdown structure valid; only allowed new headings: `## Clarifications`, `### Session YYYY-MM-DD`.
162:    - Terminology consistency: same canonical term used across all updated sections.
163: 
164: 7. Write the updated spec back to `FEATURE_SPEC`.
165: 
166: 8. Report completion (after questioning loop ends or early termination):
167:    - Number of questions asked & answered.
168:    - Path to updated spec.
169:    - Sections touched (list names).
170:    - Coverage summary table listing each taxonomy category with Status: Resolved (was Partial/Missing and addressed), Deferred (exceeds question quota or better suited for planning), Clear (already sufficient), Outstanding (still Partial/Missing but low impact).
171:    - If any Outstanding or Deferred remain, recommend whether to proceed to `/speckit.plan` or run `/speckit.clarify` again later post-plan.
172:    - Suggested next command.
173: 
174: Behavior rules:
175: 
176: - If no meaningful ambiguities found (or all potential questions would be low-impact), respond: "No critical ambiguities detected worth formal clarification." and suggest proceeding.
177: - If spec file missing, instruct user to run `/speckit.specify` first (do not create a new spec here).
178: - Never exceed 5 total asked questions (clarification retries for a single question do not count as new questions).
179: - Avoid speculative tech stack questions unless the absence blocks functional clarity.
180: - Respect user early termination signals ("stop", "done", "proceed").
181: - If no questions asked due to full coverage, output a compact coverage summary (all categories Clear) then suggest advancing.
182: - If quota reached with unresolved high-impact categories remaining, explicitly flag them under Deferred with rationale.
183: 
184: Context for prioritization: {{args}}
185: """
</file>

<file path=".gemini/commands/speckit.constitution.toml">
 1: description = "Create or update the project constitution from interactive or provided principle inputs, ensuring all dependent templates stay in sync."
 2: 
 3: prompt = """
 4: ---
 5: description: Create or update the project constitution from interactive or provided principle inputs, ensuring all dependent templates stay in sync.
 6: handoffs: 
 7:   - label: Build Specification
 8:     agent: speckit.specify
 9:     prompt: Implement the feature specification based on the updated constitution. I want to build...
10: ---
11: 
12: ## User Input
13: 
14: ```text
15: $ARGUMENTS
16: ```
17: 
18: You **MUST** consider the user input before proceeding (if not empty).
19: 
20: ## Outline
21: 
22: You are updating the project constitution at `.specify/memory/constitution.md`. This file is a TEMPLATE containing placeholder tokens in square brackets (e.g. `[PROJECT_NAME]`, `[PRINCIPLE_1_NAME]`). Your job is to (a) collect/derive concrete values, (b) fill the template precisely, and (c) propagate any amendments across dependent artifacts.
23: 
24: Follow this execution flow:
25: 
26: 1. Load the existing constitution template at `.specify/memory/constitution.md`.
27:    - Identify every placeholder token of the form `[ALL_CAPS_IDENTIFIER]`.
28:    **IMPORTANT**: The user might require less or more principles than the ones used in the template. If a number is specified, respect that - follow the general template. You will update the doc accordingly.
29: 
30: 2. Collect/derive values for placeholders:
31:    - If user input (conversation) supplies a value, use it.
32:    - Otherwise infer from existing repo context (README, docs, prior constitution versions if embedded).
33:    - For governance dates: `RATIFICATION_DATE` is the original adoption date (if unknown ask or mark TODO), `LAST_AMENDED_DATE` is today if changes are made, otherwise keep previous.
34:    - `CONSTITUTION_VERSION` must increment according to semantic versioning rules:
35:      - MAJOR: Backward incompatible governance/principle removals or redefinitions.
36:      - MINOR: New principle/section added or materially expanded guidance.
37:      - PATCH: Clarifications, wording, typo fixes, non-semantic refinements.
38:    - If version bump type ambiguous, propose reasoning before finalizing.
39: 
40: 3. Draft the updated constitution content:
41:    - Replace every placeholder with concrete text (no bracketed tokens left except intentionally retained template slots that the project has chosen not to define yet‚Äîexplicitly justify any left).
42:    - Preserve heading hierarchy and comments can be removed once replaced unless they still add clarifying guidance.
43:    - Ensure each Principle section: succinct name line, paragraph (or bullet list) capturing non‚Äënegotiable rules, explicit rationale if not obvious.
44:    - Ensure Governance section lists amendment procedure, versioning policy, and compliance review expectations.
45: 
46: 4. Consistency propagation checklist (convert prior checklist into active validations):
47:    - Read `.specify/templates/plan-template.md` and ensure any "Constitution Check" or rules align with updated principles.
48:    - Read `.specify/templates/spec-template.md` for scope/requirements alignment‚Äîupdate if constitution adds/removes mandatory sections or constraints.
49:    - Read `.specify/templates/tasks-template.md` and ensure task categorization reflects new or removed principle-driven task types (e.g., observability, versioning, testing discipline).
50:    - Read each command file in `.specify/templates/commands/*.md` (including this one) to verify no outdated references (agent-specific names like CLAUDE only) remain when generic guidance is required.
51:    - Read any runtime guidance docs (e.g., `README.md`, `docs/quickstart.md`, or agent-specific guidance files if present). Update references to principles changed.
52: 
53: 5. Produce a Sync Impact Report (prepend as an HTML comment at top of the constitution file after update):
54:    - Version change: old ‚Üí new
55:    - List of modified principles (old title ‚Üí new title if renamed)
56:    - Added sections
57:    - Removed sections
58:    - Templates requiring updates (‚úÖ updated / ‚ö† pending) with file paths
59:    - Follow-up TODOs if any placeholders intentionally deferred.
60: 
61: 6. Validation before final output:
62:    - No remaining unexplained bracket tokens.
63:    - Version line matches report.
64:    - Dates ISO format YYYY-MM-DD.
65:    - Principles are declarative, testable, and free of vague language ("should" ‚Üí replace with MUST/SHOULD rationale where appropriate).
66: 
67: 7. Write the completed constitution back to `.specify/memory/constitution.md` (overwrite).
68: 
69: 8. Output a final summary to the user with:
70:    - New version and bump rationale.
71:    - Any files flagged for manual follow-up.
72:    - Suggested commit message (e.g., `docs: amend constitution to vX.Y.Z (principle additions + governance update)`).
73: 
74: Formatting & Style Requirements:
75: 
76: - Use Markdown headings exactly as in the template (do not demote/promote levels).
77: - Wrap long rationale lines to keep readability (<100 chars ideally) but do not hard enforce with awkward breaks.
78: - Keep a single blank line between sections.
79: - Avoid trailing whitespace.
80: 
81: If the user supplies partial updates (e.g., only one principle revision), still perform validation and version decision steps.
82: 
83: If critical info missing (e.g., ratification date truly unknown), insert `TODO(<FIELD_NAME>): explanation` and include in the Sync Impact Report under deferred items.
84: 
85: Do not create a new template; always operate on the existing `.specify/memory/constitution.md` file.
86: """
</file>

<file path=".gemini/commands/speckit.implement.toml">
  1: description = "Execute the implementation plan by processing and executing all tasks defined in tasks.md"
  2: 
  3: prompt = """
  4: ---
  5: description: Execute the implementation plan by processing and executing all tasks defined in tasks.md
  6: ---
  7: 
  8: ## User Input
  9: 
 10: ```text
 11: $ARGUMENTS
 12: ```
 13: 
 14: You **MUST** consider the user input before proceeding (if not empty).
 15: 
 16: ## Outline
 17: 
 18: 1. Run `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` from repo root and parse FEATURE_DIR and AVAILABLE_DOCS list. All paths must be absolute. For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
 19: 
 20: 2. **Check checklists status** (if FEATURE_DIR/checklists/ exists):
 21:    - Scan all checklist files in the checklists/ directory
 22:    - For each checklist, count:
 23:      - Total items: All lines matching `- [ ]` or `- [X]` or `- [x]`
 24:      - Completed items: Lines matching `- [X]` or `- [x]`
 25:      - Incomplete items: Lines matching `- [ ]`
 26:    - Create a status table:
 27: 
 28:      ```text
 29:      | Checklist | Total | Completed | Incomplete | Status |
 30:      |-----------|-------|-----------|------------|--------|
 31:      | ux.md     | 12    | 12        | 0          | ‚úì PASS |
 32:      | test.md   | 8     | 5         | 3          | ‚úó FAIL |
 33:      | security.md | 6   | 6         | 0          | ‚úì PASS |
 34:      ```
 35: 
 36:    - Calculate overall status:
 37:      - **PASS**: All checklists have 0 incomplete items
 38:      - **FAIL**: One or more checklists have incomplete items
 39: 
 40:    - **If any checklist is incomplete**:
 41:      - Display the table with incomplete item counts
 42:      - **STOP** and ask: "Some checklists are incomplete. Do you want to proceed with implementation anyway? (yes/no)"
 43:      - Wait for user response before continuing
 44:      - If user says "no" or "wait" or "stop", halt execution
 45:      - If user says "yes" or "proceed" or "continue", proceed to step 3
 46: 
 47:    - **If all checklists are complete**:
 48:      - Display the table showing all checklists passed
 49:      - Automatically proceed to step 3
 50: 
 51: 3. Load and analyze the implementation context:
 52:    - **REQUIRED**: Read tasks.md for the complete task list and execution plan
 53:    - **REQUIRED**: Read plan.md for tech stack, architecture, and file structure
 54:    - **IF EXISTS**: Read data-model.md for entities and relationships
 55:    - **IF EXISTS**: Read contracts/ for API specifications and test requirements
 56:    - **IF EXISTS**: Read research.md for technical decisions and constraints
 57:    - **IF EXISTS**: Read quickstart.md for integration scenarios
 58: 
 59: 4. **Project Setup Verification**:
 60:    - **REQUIRED**: Create/verify ignore files based on actual project setup:
 61: 
 62:    **Detection & Creation Logic**:
 63:    - Check if the following command succeeds to determine if the repository is a git repo (create/verify .gitignore if so):
 64: 
 65:      ```sh
 66:      git rev-parse --git-dir 2>/dev/null
 67:      ```
 68: 
 69:    - Check if Dockerfile* exists or Docker in plan.md ‚Üí create/verify .dockerignore
 70:    - Check if .eslintrc* exists ‚Üí create/verify .eslintignore
 71:    - Check if eslint.config.* exists ‚Üí ensure the config's `ignores` entries cover required patterns
 72:    - Check if .prettierrc* exists ‚Üí create/verify .prettierignore
 73:    - Check if .npmrc or package.json exists ‚Üí create/verify .npmignore (if publishing)
 74:    - Check if terraform files (*.tf) exist ‚Üí create/verify .terraformignore
 75:    - Check if .helmignore needed (helm charts present) ‚Üí create/verify .helmignore
 76: 
 77:    **If ignore file already exists**: Verify it contains essential patterns, append missing critical patterns only
 78:    **If ignore file missing**: Create with full pattern set for detected technology
 79: 
 80:    **Common Patterns by Technology** (from plan.md tech stack):
 81:    - **Node.js/JavaScript/TypeScript**: `node_modules/`, `dist/`, `build/`, `*.log`, `.env*`
 82:    - **Python**: `__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`
 83:    - **Java**: `target/`, `*.class`, `*.jar`, `.gradle/`, `build/`
 84:    - **C#/.NET**: `bin/`, `obj/`, `*.user`, `*.suo`, `packages/`
 85:    - **Go**: `*.exe`, `*.test`, `vendor/`, `*.out`
 86:    - **Ruby**: `.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`
 87:    - **PHP**: `vendor/`, `*.log`, `*.cache`, `*.env`
 88:    - **Rust**: `target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`
 89:    - **Kotlin**: `build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`
 90:    - **C++**: `build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`
 91:    - **C**: `build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`
 92:    - **Swift**: `.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`
 93:    - **R**: `.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`
 94:    - **Universal**: `.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`
 95: 
 96:    **Tool-Specific Patterns**:
 97:    - **Docker**: `node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`
 98:    - **ESLint**: `node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`
 99:    - **Prettier**: `node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`
100:    - **Terraform**: `.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`
101:    - **Kubernetes/k8s**: `*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`
102: 
103: 5. Parse tasks.md structure and extract:
104:    - **Task phases**: Setup, Tests, Core, Integration, Polish
105:    - **Task dependencies**: Sequential vs parallel execution rules
106:    - **Task details**: ID, description, file paths, parallel markers [P]
107:    - **Execution flow**: Order and dependency requirements
108: 
109: 6. Execute implementation following the task plan:
110:    - **Phase-by-phase execution**: Complete each phase before moving to the next
111:    - **Respect dependencies**: Run sequential tasks in order, parallel tasks [P] can run together  
112:    - **Follow TDD approach**: Execute test tasks before their corresponding implementation tasks
113:    - **File-based coordination**: Tasks affecting the same files must run sequentially
114:    - **Validation checkpoints**: Verify each phase completion before proceeding
115: 
116: 7. Implementation execution rules:
117:    - **Setup first**: Initialize project structure, dependencies, configuration
118:    - **Tests before code**: If you need to write tests for contracts, entities, and integration scenarios
119:    - **Core development**: Implement models, services, CLI commands, endpoints
120:    - **Integration work**: Database connections, middleware, logging, external services
121:    - **Polish and validation**: Unit tests, performance optimization, documentation
122: 
123: 8. Progress tracking and error handling:
124:    - Report progress after each completed task
125:    - Halt execution if any non-parallel task fails
126:    - For parallel tasks [P], continue with successful tasks, report failed ones
127:    - Provide clear error messages with context for debugging
128:    - Suggest next steps if implementation cannot proceed
129:    - **IMPORTANT** For completed tasks, make sure to mark the task off as [X] in the tasks file.
130: 
131: 9. Completion validation:
132:    - Verify all required tasks are completed
133:    - Check that implemented features match the original specification
134:    - Validate that tests pass and coverage meets requirements
135:    - Confirm the implementation follows the technical plan
136:    - Report final status with summary of completed work
137: 
138: Note: This command assumes a complete task breakdown exists in tasks.md. If tasks are incomplete or missing, suggest running `/speckit.tasks` first to regenerate the task list.
139: """
</file>

<file path=".gemini/commands/speckit.plan.toml">
 1: description = "Execute the implementation planning workflow using the plan template to generate design artifacts."
 2: 
 3: prompt = """
 4: ---
 5: description: Execute the implementation planning workflow using the plan template to generate design artifacts.
 6: handoffs: 
 7:   - label: Create Tasks
 8:     agent: speckit.tasks
 9:     prompt: Break the plan into tasks
10:     send: true
11:   - label: Create Checklist
12:     agent: speckit.checklist
13:     prompt: Create a checklist for the following domain...
14: ---
15: 
16: ## User Input
17: 
18: ```text
19: $ARGUMENTS
20: ```
21: 
22: You **MUST** consider the user input before proceeding (if not empty).
23: 
24: ## Outline
25: 
26: 1. **Setup**: Run `.specify/scripts/bash/setup-plan.sh --json` from repo root and parse JSON for FEATURE_SPEC, IMPL_PLAN, SPECS_DIR, BRANCH. For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
27: 
28: 2. **Load context**: Read FEATURE_SPEC and `.specify/memory/constitution.md`. Load IMPL_PLAN template (already copied).
29: 
30: 3. **Execute plan workflow**: Follow the structure in IMPL_PLAN template to:
31:    - Fill Technical Context (mark unknowns as "NEEDS CLARIFICATION")
32:    - Fill Constitution Check section from constitution
33:    - Evaluate gates (ERROR if violations unjustified)
34:    - Phase 0: Generate research.md (resolve all NEEDS CLARIFICATION)
35:    - Phase 1: Generate data-model.md, contracts/, quickstart.md
36:    - Phase 1: Update agent context by running the agent script
37:    - Re-evaluate Constitution Check post-design
38: 
39: 4. **Stop and report**: Command ends after Phase 2 planning. Report branch, IMPL_PLAN path, and generated artifacts.
40: 
41: ## Phases
42: 
43: ### Phase 0: Outline & Research
44: 
45: 1. **Extract unknowns from Technical Context** above:
46:    - For each NEEDS CLARIFICATION ‚Üí research task
47:    - For each dependency ‚Üí best practices task
48:    - For each integration ‚Üí patterns task
49: 
50: 2. **Generate and dispatch research agents**:
51: 
52:    ```text
53:    For each unknown in Technical Context:
54:      Task: "Research {unknown} for {feature context}"
55:    For each technology choice:
56:      Task: "Find best practices for {tech} in {domain}"
57:    ```
58: 
59: 3. **Consolidate findings** in `research.md` using format:
60:    - Decision: [what was chosen]
61:    - Rationale: [why chosen]
62:    - Alternatives considered: [what else evaluated]
63: 
64: **Output**: research.md with all NEEDS CLARIFICATION resolved
65: 
66: ### Phase 1: Design & Contracts
67: 
68: **Prerequisites:** `research.md` complete
69: 
70: 1. **Extract entities from feature spec** ‚Üí `data-model.md`:
71:    - Entity name, fields, relationships
72:    - Validation rules from requirements
73:    - State transitions if applicable
74: 
75: 2. **Generate API contracts** from functional requirements:
76:    - For each user action ‚Üí endpoint
77:    - Use standard REST/GraphQL patterns
78:    - Output OpenAPI/GraphQL schema to `/contracts/`
79: 
80: 3. **Agent context update**:
81:    - Run `.specify/scripts/bash/update-agent-context.sh gemini`
82:    - These scripts detect which AI agent is in use
83:    - Update the appropriate agent-specific context file
84:    - Add only new technology from current plan
85:    - Preserve manual additions between markers
86: 
87: **Output**: data-model.md, /contracts/*, quickstart.md, agent-specific file
88: 
89: ## Key rules
90: 
91: - Use absolute paths
92: - ERROR on gate failures or unresolved clarifications
93: """
</file>

<file path=".gemini/commands/speckit.specify.toml">
  1: description = "Create or update the feature specification from a natural language feature description."
  2: 
  3: prompt = """
  4: ---
  5: description: Create or update the feature specification from a natural language feature description.
  6: handoffs: 
  7:   - label: Build Technical Plan
  8:     agent: speckit.plan
  9:     prompt: Create a plan for the spec. I am building with...
 10:   - label: Clarify Spec Requirements
 11:     agent: speckit.clarify
 12:     prompt: Clarify specification requirements
 13:     send: true
 14: ---
 15: 
 16: ## User Input
 17: 
 18: ```text
 19: $ARGUMENTS
 20: ```
 21: 
 22: You **MUST** consider the user input before proceeding (if not empty).
 23: 
 24: ## Outline
 25: 
 26: The text the user typed after `/speckit.specify` in the triggering message **is** the feature description. Assume you always have it available in this conversation even if `{{args}}` appears literally below. Do not ask the user to repeat it unless they provided an empty command.
 27: 
 28: Given that feature description, do this:
 29: 
 30: 1. **Generate a concise short name** (2-4 words) for the branch:
 31:    - Analyze the feature description and extract the most meaningful keywords
 32:    - Create a 2-4 word short name that captures the essence of the feature
 33:    - Use action-noun format when possible (e.g., "add-user-auth", "fix-payment-bug")
 34:    - Preserve technical terms and acronyms (OAuth2, API, JWT, etc.)
 35:    - Keep it concise but descriptive enough to understand the feature at a glance
 36:    - Examples:
 37:      - "I want to add user authentication" ‚Üí "user-auth"
 38:      - "Implement OAuth2 integration for the API" ‚Üí "oauth2-api-integration"
 39:      - "Create a dashboard for analytics" ‚Üí "analytics-dashboard"
 40:      - "Fix payment processing timeout bug" ‚Üí "fix-payment-timeout"
 41: 
 42: 2. **Check for existing branches before creating new one**:
 43: 
 44:    a. First, fetch all remote branches to ensure we have the latest information:
 45: 
 46:       ```bash
 47:       git fetch --all --prune
 48:       ```
 49: 
 50:    b. Find the highest feature number across all sources for the short-name:
 51:       - Remote branches: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
 52:       - Local branches: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
 53:       - Specs directories: Check for directories matching `specs/[0-9]+-<short-name>`
 54: 
 55:    c. Determine the next available number:
 56:       - Extract all numbers from all three sources
 57:       - Find the highest number N
 58:       - Use N+1 for the new branch number
 59: 
 60:    d. Run the script `.specify/scripts/bash/create-new-feature.sh --json "{{args}}"` with the calculated number and short-name:
 61:       - Pass `--number N+1` and `--short-name "your-short-name"` along with the feature description
 62:       - Bash example: `.specify/scripts/bash/create-new-feature.sh --json "{{args}}" --json --number 5 --short-name "user-auth" "Add user authentication"`
 63:       - PowerShell example: `.specify/scripts/bash/create-new-feature.sh --json "{{args}}" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`
 64: 
 65:    **IMPORTANT**:
 66:    - Check all three sources (remote branches, local branches, specs directories) to find the highest number
 67:    - Only match branches/directories with the exact short-name pattern
 68:    - If no existing branches/directories found with this short-name, start with number 1
 69:    - You must only ever run this script once per feature
 70:    - The JSON is provided in the terminal as output - always refer to it to get the actual content you're looking for
 71:    - The JSON output will contain BRANCH_NAME and SPEC_FILE paths
 72:    - For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot")
 73: 
 74: 3. Load `.specify/templates/spec-template.md` to understand required sections.
 75: 
 76: 4. Follow this execution flow:
 77: 
 78:     1. Parse user description from Input
 79:        If empty: ERROR "No feature description provided"
 80:     2. Extract key concepts from description
 81:        Identify: actors, actions, data, constraints
 82:     3. For unclear aspects:
 83:        - Make informed guesses based on context and industry standards
 84:        - Only mark with [NEEDS CLARIFICATION: specific question] if:
 85:          - The choice significantly impacts feature scope or user experience
 86:          - Multiple reasonable interpretations exist with different implications
 87:          - No reasonable default exists
 88:        - **LIMIT: Maximum 3 [NEEDS CLARIFICATION] markers total**
 89:        - Prioritize clarifications by impact: scope > security/privacy > user experience > technical details
 90:     4. Fill User Scenarios & Testing section
 91:        If no clear user flow: ERROR "Cannot determine user scenarios"
 92:     5. Generate Functional Requirements
 93:        Each requirement must be testable
 94:        Use reasonable defaults for unspecified details (document assumptions in Assumptions section)
 95:     6. Define Success Criteria
 96:        Create measurable, technology-agnostic outcomes
 97:        Include both quantitative metrics (time, performance, volume) and qualitative measures (user satisfaction, task completion)
 98:        Each criterion must be verifiable without implementation details
 99:     7. Identify Key Entities (if data involved)
100:     8. Return: SUCCESS (spec ready for planning)
101: 
102: 5. Write the specification to SPEC_FILE using the template structure, replacing placeholders with concrete details derived from the feature description (arguments) while preserving section order and headings.
103: 
104: 6. **Specification Quality Validation**: After writing the initial spec, validate it against quality criteria:
105: 
106:    a. **Create Spec Quality Checklist**: Generate a checklist file at `FEATURE_DIR/checklists/requirements.md` using the checklist template structure with these validation items:
107: 
108:       ```markdown
109:       # Specification Quality Checklist: [FEATURE NAME]
110:       
111:       **Purpose**: Validate specification completeness and quality before proceeding to planning
112:       **Created**: [DATE]
113:       **Feature**: [Link to spec.md]
114:       
115:       ## Content Quality
116:       
117:       - [ ] No implementation details (languages, frameworks, APIs)
118:       - [ ] Focused on user value and business needs
119:       - [ ] Written for non-technical stakeholders
120:       - [ ] All mandatory sections completed
121:       
122:       ## Requirement Completeness
123:       
124:       - [ ] No [NEEDS CLARIFICATION] markers remain
125:       - [ ] Requirements are testable and unambiguous
126:       - [ ] Success criteria are measurable
127:       - [ ] Success criteria are technology-agnostic (no implementation details)
128:       - [ ] All acceptance scenarios are defined
129:       - [ ] Edge cases are identified
130:       - [ ] Scope is clearly bounded
131:       - [ ] Dependencies and assumptions identified
132:       
133:       ## Feature Readiness
134:       
135:       - [ ] All functional requirements have clear acceptance criteria
136:       - [ ] User scenarios cover primary flows
137:       - [ ] Feature meets measurable outcomes defined in Success Criteria
138:       - [ ] No implementation details leak into specification
139:       
140:       ## Notes
141:       
142:       - Items marked incomplete require spec updates before `/speckit.clarify` or `/speckit.plan`
143:       ```
144: 
145:    b. **Run Validation Check**: Review the spec against each checklist item:
146:       - For each item, determine if it passes or fails
147:       - Document specific issues found (quote relevant spec sections)
148: 
149:    c. **Handle Validation Results**:
150: 
151:       - **If all items pass**: Mark checklist complete and proceed to step 6
152: 
153:       - **If items fail (excluding [NEEDS CLARIFICATION])**:
154:         1. List the failing items and specific issues
155:         2. Update the spec to address each issue
156:         3. Re-run validation until all items pass (max 3 iterations)
157:         4. If still failing after 3 iterations, document remaining issues in checklist notes and warn user
158: 
159:       - **If [NEEDS CLARIFICATION] markers remain**:
160:         1. Extract all [NEEDS CLARIFICATION: ...] markers from the spec
161:         2. **LIMIT CHECK**: If more than 3 markers exist, keep only the 3 most critical (by scope/security/UX impact) and make informed guesses for the rest
162:         3. For each clarification needed (max 3), present options to user in this format:
163: 
164:            ```markdown
165:            ## Question [N]: [Topic]
166:            
167:            **Context**: [Quote relevant spec section]
168:            
169:            **What we need to know**: [Specific question from NEEDS CLARIFICATION marker]
170:            
171:            **Suggested Answers**:
172:            
173:            | Option | Answer | Implications |
174:            |--------|--------|--------------|
175:            | A      | [First suggested answer] | [What this means for the feature] |
176:            | B      | [Second suggested answer] | [What this means for the feature] |
177:            | C      | [Third suggested answer] | [What this means for the feature] |
178:            | Custom | Provide your own answer | [Explain how to provide custom input] |
179:            
180:            **Your choice**: _[Wait for user response]_
181:            ```
182: 
183:         4. **CRITICAL - Table Formatting**: Ensure markdown tables are properly formatted:
184:            - Use consistent spacing with pipes aligned
185:            - Each cell should have spaces around content: `| Content |` not `|Content|`
186:            - Header separator must have at least 3 dashes: `|--------|`
187:            - Test that the table renders correctly in markdown preview
188:         5. Number questions sequentially (Q1, Q2, Q3 - max 3 total)
189:         6. Present all questions together before waiting for responses
190:         7. Wait for user to respond with their choices for all questions (e.g., "Q1: A, Q2: Custom - [details], Q3: B")
191:         8. Update the spec by replacing each [NEEDS CLARIFICATION] marker with the user's selected or provided answer
192:         9. Re-run validation after all clarifications are resolved
193: 
194:    d. **Update Checklist**: After each validation iteration, update the checklist file with current pass/fail status
195: 
196: 7. Report completion with branch name, spec file path, checklist results, and readiness for the next phase (`/speckit.clarify` or `/speckit.plan`).
197: 
198: **NOTE:** The script creates and checks out the new branch and initializes the spec file before writing.
199: 
200: ## General Guidelines
201: 
202: ## Quick Guidelines
203: 
204: - Focus on **WHAT** users need and **WHY**.
205: - Avoid HOW to implement (no tech stack, APIs, code structure).
206: - Written for business stakeholders, not developers.
207: - DO NOT create any checklists that are embedded in the spec. That will be a separate command.
208: 
209: ### Section Requirements
210: 
211: - **Mandatory sections**: Must be completed for every feature
212: - **Optional sections**: Include only when relevant to the feature
213: - When a section doesn't apply, remove it entirely (don't leave as "N/A")
214: 
215: ### For AI Generation
216: 
217: When creating this spec from a user prompt:
218: 
219: 1. **Make informed guesses**: Use context, industry standards, and common patterns to fill gaps
220: 2. **Document assumptions**: Record reasonable defaults in the Assumptions section
221: 3. **Limit clarifications**: Maximum 3 [NEEDS CLARIFICATION] markers - use only for critical decisions that:
222:    - Significantly impact feature scope or user experience
223:    - Have multiple reasonable interpretations with different implications
224:    - Lack any reasonable default
225: 4. **Prioritize clarifications**: scope > security/privacy > user experience > technical details
226: 5. **Think like a tester**: Every vague requirement should fail the "testable and unambiguous" checklist item
227: 6. **Common areas needing clarification** (only if no reasonable default exists):
228:    - Feature scope and boundaries (include/exclude specific use cases)
229:    - User types and permissions (if multiple conflicting interpretations possible)
230:    - Security/compliance requirements (when legally/financially significant)
231: 
232: **Examples of reasonable defaults** (don't ask about these):
233: 
234: - Data retention: Industry-standard practices for the domain
235: - Performance targets: Standard web/mobile app expectations unless specified
236: - Error handling: User-friendly messages with appropriate fallbacks
237: - Authentication method: Standard session-based or OAuth2 for web apps
238: - Integration patterns: RESTful APIs unless specified otherwise
239: 
240: ### Success Criteria Guidelines
241: 
242: Success criteria must be:
243: 
244: 1. **Measurable**: Include specific metrics (time, percentage, count, rate)
245: 2. **Technology-agnostic**: No mention of frameworks, languages, databases, or tools
246: 3. **User-focused**: Describe outcomes from user/business perspective, not system internals
247: 4. **Verifiable**: Can be tested/validated without knowing implementation details
248: 
249: **Good examples**:
250: 
251: - "Users can complete checkout in under 3 minutes"
252: - "System supports 10,000 concurrent users"
253: - "95% of searches return results in under 1 second"
254: - "Task completion rate improves by 40%"
255: 
256: **Bad examples** (implementation-focused):
257: 
258: - "API response time is under 200ms" (too technical, use "Users see results instantly")
259: - "Database can handle 1000 TPS" (implementation detail, use user-facing metric)
260: - "React components render efficiently" (framework-specific)
261: - "Redis cache hit rate above 80%" (technology-specific)
262: """
</file>

<file path=".gemini/commands/speckit.tasks.toml">
  1: description = "Generate an actionable, dependency-ordered tasks.md for the feature based on available design artifacts."
  2: 
  3: prompt = """
  4: ---
  5: description: Generate an actionable, dependency-ordered tasks.md for the feature based on available design artifacts.
  6: handoffs: 
  7:   - label: Analyze For Consistency
  8:     agent: speckit.analyze
  9:     prompt: Run a project analysis for consistency
 10:     send: true
 11:   - label: Implement Project
 12:     agent: speckit.implement
 13:     prompt: Start the implementation in phases
 14:     send: true
 15: ---
 16: 
 17: ## User Input
 18: 
 19: ```text
 20: $ARGUMENTS
 21: ```
 22: 
 23: You **MUST** consider the user input before proceeding (if not empty).
 24: 
 25: ## Outline
 26: 
 27: 1. **Setup**: Run `.specify/scripts/bash/check-prerequisites.sh --json` from repo root and parse FEATURE_DIR and AVAILABLE_DOCS list. All paths must be absolute. For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
 28: 
 29: 2. **Load design documents**: Read from FEATURE_DIR:
 30:    - **Required**: plan.md (tech stack, libraries, structure), spec.md (user stories with priorities)
 31:    - **Optional**: data-model.md (entities), contracts/ (API endpoints), research.md (decisions), quickstart.md (test scenarios)
 32:    - Note: Not all projects have all documents. Generate tasks based on what's available.
 33: 
 34: 3. **Execute task generation workflow**:
 35:    - Load plan.md and extract tech stack, libraries, project structure
 36:    - Load spec.md and extract user stories with their priorities (P1, P2, P3, etc.)
 37:    - If data-model.md exists: Extract entities and map to user stories
 38:    - If contracts/ exists: Map endpoints to user stories
 39:    - If research.md exists: Extract decisions for setup tasks
 40:    - Generate tasks organized by user story (see Task Generation Rules below)
 41:    - Generate dependency graph showing user story completion order
 42:    - Create parallel execution examples per user story
 43:    - Validate task completeness (each user story has all needed tasks, independently testable)
 44: 
 45: 4. **Generate tasks.md**: Use `.specify/templates/tasks-template.md` as structure, fill with:
 46:    - Correct feature name from plan.md
 47:    - Phase 1: Setup tasks (project initialization)
 48:    - Phase 2: Foundational tasks (blocking prerequisites for all user stories)
 49:    - Phase 3+: One phase per user story (in priority order from spec.md)
 50:    - Each phase includes: story goal, independent test criteria, tests (if requested), implementation tasks
 51:    - Final Phase: Polish & cross-cutting concerns
 52:    - All tasks must follow the strict checklist format (see Task Generation Rules below)
 53:    - Clear file paths for each task
 54:    - Dependencies section showing story completion order
 55:    - Parallel execution examples per story
 56:    - Implementation strategy section (MVP first, incremental delivery)
 57: 
 58: 5. **Report**: Output path to generated tasks.md and summary:
 59:    - Total task count
 60:    - Task count per user story
 61:    - Parallel opportunities identified
 62:    - Independent test criteria for each story
 63:    - Suggested MVP scope (typically just User Story 1)
 64:    - Format validation: Confirm ALL tasks follow the checklist format (checkbox, ID, labels, file paths)
 65: 
 66: Context for task generation: {{args}}
 67: 
 68: The tasks.md should be immediately executable - each task must be specific enough that an LLM can complete it without additional context.
 69: 
 70: ## Task Generation Rules
 71: 
 72: **CRITICAL**: Tasks MUST be organized by user story to enable independent implementation and testing.
 73: 
 74: **Tests are OPTIONAL**: Only generate test tasks if explicitly requested in the feature specification or if user requests TDD approach.
 75: 
 76: ### Checklist Format (REQUIRED)
 77: 
 78: Every task MUST strictly follow this format:
 79: 
 80: ```text
 81: - [ ] [TaskID] [P?] [Story?] Description with file path
 82: ```
 83: 
 84: **Format Components**:
 85: 
 86: 1. **Checkbox**: ALWAYS start with `- [ ]` (markdown checkbox)
 87: 2. **Task ID**: Sequential number (T001, T002, T003...) in execution order
 88: 3. **[P] marker**: Include ONLY if task is parallelizable (different files, no dependencies on incomplete tasks)
 89: 4. **[Story] label**: REQUIRED for user story phase tasks only
 90:    - Format: [US1], [US2], [US3], etc. (maps to user stories from spec.md)
 91:    - Setup phase: NO story label
 92:    - Foundational phase: NO story label  
 93:    - User Story phases: MUST have story label
 94:    - Polish phase: NO story label
 95: 5. **Description**: Clear action with exact file path
 96: 
 97: **Examples**:
 98: 
 99: - ‚úÖ CORRECT: `- [ ] T001 Create project structure per implementation plan`
100: - ‚úÖ CORRECT: `- [ ] T005 [P] Implement authentication middleware in src/middleware/auth.py`
101: - ‚úÖ CORRECT: `- [ ] T012 [P] [US1] Create User model in src/models/user.py`
102: - ‚úÖ CORRECT: `- [ ] T014 [US1] Implement UserService in src/services/user_service.py`
103: - ‚ùå WRONG: `- [ ] Create User model` (missing ID and Story label)
104: - ‚ùå WRONG: `T001 [US1] Create model` (missing checkbox)
105: - ‚ùå WRONG: `- [ ] [US1] Create User model` (missing Task ID)
106: - ‚ùå WRONG: `- [ ] T001 [US1] Create model` (missing file path)
107: 
108: ### Task Organization
109: 
110: 1. **From User Stories (spec.md)** - PRIMARY ORGANIZATION:
111:    - Each user story (P1, P2, P3...) gets its own phase
112:    - Map all related components to their story:
113:      - Models needed for that story
114:      - Services needed for that story
115:      - Endpoints/UI needed for that story
116:      - If tests requested: Tests specific to that story
117:    - Mark story dependencies (most stories should be independent)
118: 
119: 2. **From Contracts**:
120:    - Map each contract/endpoint ‚Üí to the user story it serves
121:    - If tests requested: Each contract ‚Üí contract test task [P] before implementation in that story's phase
122: 
123: 3. **From Data Model**:
124:    - Map each entity to the user story(ies) that need it
125:    - If entity serves multiple stories: Put in earliest story or Setup phase
126:    - Relationships ‚Üí service layer tasks in appropriate story phase
127: 
128: 4. **From Setup/Infrastructure**:
129:    - Shared infrastructure ‚Üí Setup phase (Phase 1)
130:    - Foundational/blocking tasks ‚Üí Foundational phase (Phase 2)
131:    - Story-specific setup ‚Üí within that story's phase
132: 
133: ### Phase Structure
134: 
135: - **Phase 1**: Setup (project initialization)
136: - **Phase 2**: Foundational (blocking prerequisites - MUST complete before user stories)
137: - **Phase 3+**: User Stories in priority order (P1, P2, P3...)
138:   - Within each story: Tests (if requested) ‚Üí Models ‚Üí Services ‚Üí Endpoints ‚Üí Integration
139:   - Each phase should be a complete, independently testable increment
140: - **Final Phase**: Polish & Cross-Cutting Concerns
141: """
</file>

<file path=".gemini/commands/speckit.taskstoissues.toml">
 1: description = "Convert existing tasks into actionable, dependency-ordered GitHub issues for the feature based on available design artifacts."
 2: 
 3: prompt = """
 4: ---
 5: description: Convert existing tasks into actionable, dependency-ordered GitHub issues for the feature based on available design artifacts.
 6: tools: ['github/github-mcp-server/issue_write']
 7: ---
 8: 
 9: ## User Input
10: 
11: ```text
12: $ARGUMENTS
13: ```
14: 
15: You **MUST** consider the user input before proceeding (if not empty).
16: 
17: ## Outline
18: 
19: 1. Run `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks` from repo root and parse FEATURE_DIR and AVAILABLE_DOCS list. All paths must be absolute. For single quotes in args like "I'm Groot", use escape syntax: e.g 'I'\\''m Groot' (or double-quote if possible: "I'm Groot").
20: 1. From the executed script, extract the path to **tasks**.
21: 1. Get the Git remote by running:
22: 
23: ```bash
24: git config --get remote.origin.url
25: ```
26: 
27: > [!CAUTION]
28: > ONLY PROCEED TO NEXT STEPS IF THE REMOTE IS A GITHUB URL
29: 
30: 1. For each task in the list, use the GitHub MCP server to create a new issue in the repository that is representative of the Git remote.
31: 
32: > [!CAUTION]
33: > UNDER NO CIRCUMSTANCES EVER CREATE ISSUES IN REPOSITORIES THAT DO NOT MATCH THE REMOTE URL
34: """
</file>

<file path=".specify/memory/constitution.md">
 1: # [PROJECT_NAME] Constitution
 2: <!-- Example: Spec Constitution, TaskFlow Constitution, etc. -->
 3: 
 4: ## Core Principles
 5: 
 6: ### [PRINCIPLE_1_NAME]
 7: <!-- Example: I. Library-First -->
 8: [PRINCIPLE_1_DESCRIPTION]
 9: <!-- Example: Every feature starts as a standalone library; Libraries must be self-contained, independently testable, documented; Clear purpose required - no organizational-only libraries -->
10: 
11: ### [PRINCIPLE_2_NAME]
12: <!-- Example: II. CLI Interface -->
13: [PRINCIPLE_2_DESCRIPTION]
14: <!-- Example: Every library exposes functionality via CLI; Text in/out protocol: stdin/args ‚Üí stdout, errors ‚Üí stderr; Support JSON + human-readable formats -->
15: 
16: ### [PRINCIPLE_3_NAME]
17: <!-- Example: III. Test-First (NON-NEGOTIABLE) -->
18: [PRINCIPLE_3_DESCRIPTION]
19: <!-- Example: TDD mandatory: Tests written ‚Üí User approved ‚Üí Tests fail ‚Üí Then implement; Red-Green-Refactor cycle strictly enforced -->
20: 
21: ### [PRINCIPLE_4_NAME]
22: <!-- Example: IV. Integration Testing -->
23: [PRINCIPLE_4_DESCRIPTION]
24: <!-- Example: Focus areas requiring integration tests: New library contract tests, Contract changes, Inter-service communication, Shared schemas -->
25: 
26: ### [PRINCIPLE_5_NAME]
27: <!-- Example: V. Observability, VI. Versioning & Breaking Changes, VII. Simplicity -->
28: [PRINCIPLE_5_DESCRIPTION]
29: <!-- Example: Text I/O ensures debuggability; Structured logging required; Or: MAJOR.MINOR.BUILD format; Or: Start simple, YAGNI principles -->
30: 
31: ## [SECTION_2_NAME]
32: <!-- Example: Additional Constraints, Security Requirements, Performance Standards, etc. -->
33: 
34: [SECTION_2_CONTENT]
35: <!-- Example: Technology stack requirements, compliance standards, deployment policies, etc. -->
36: 
37: ## [SECTION_3_NAME]
38: <!-- Example: Development Workflow, Review Process, Quality Gates, etc. -->
39: 
40: [SECTION_3_CONTENT]
41: <!-- Example: Code review requirements, testing gates, deployment approval process, etc. -->
42: 
43: ## Governance
44: <!-- Example: Constitution supersedes all other practices; Amendments require documentation, approval, migration plan -->
45: 
46: [GOVERNANCE_RULES]
47: <!-- Example: All PRs/reviews must verify compliance; Complexity must be justified; Use [GUIDANCE_FILE] for runtime development guidance -->
48: 
49: **Version**: [CONSTITUTION_VERSION] | **Ratified**: [RATIFICATION_DATE] | **Last Amended**: [LAST_AMENDED_DATE]
50: <!-- Example: Version: 2.1.1 | Ratified: 2025-06-13 | Last Amended: 2025-07-16 -->
</file>

<file path=".specify/scripts/bash/check-prerequisites.sh">
  1: #!/usr/bin/env bash
  2: # Consolidated prerequisite checking script
  3: #
  4: # This script provides unified prerequisite checking for Spec-Driven Development workflow.
  5: # It replaces the functionality previously spread across multiple scripts.
  6: #
  7: # Usage: ./check-prerequisites.sh [OPTIONS]
  8: #
  9: # OPTIONS:
 10: #   --json              Output in JSON format
 11: #   --require-tasks     Require tasks.md to exist (for implementation phase)
 12: #   --include-tasks     Include tasks.md in AVAILABLE_DOCS list
 13: #   --paths-only        Only output path variables (no validation)
 14: #   --help, -h          Show help message
 15: #
 16: # OUTPUTS:
 17: #   JSON mode: {"FEATURE_DIR":"...", "AVAILABLE_DOCS":["..."]}
 18: #   Text mode: FEATURE_DIR:... \n AVAILABLE_DOCS: \n ‚úì/‚úó file.md
 19: #   Paths only: REPO_ROOT: ... \n BRANCH: ... \n FEATURE_DIR: ... etc.
 20: set -e
 21: # Parse command line arguments
 22: JSON_MODE=false
 23: REQUIRE_TASKS=false
 24: INCLUDE_TASKS=false
 25: PATHS_ONLY=false
 26: for arg in "$@"; do
 27:     case "$arg" in
 28:         --json)
 29:             JSON_MODE=true
 30:             ;;
 31:         --require-tasks)
 32:             REQUIRE_TASKS=true
 33:             ;;
 34:         --include-tasks)
 35:             INCLUDE_TASKS=true
 36:             ;;
 37:         --paths-only)
 38:             PATHS_ONLY=true
 39:             ;;
 40:         --help|-h)
 41:             cat << 'EOF'
 42: Usage: check-prerequisites.sh [OPTIONS]
 43: Consolidated prerequisite checking for Spec-Driven Development workflow.
 44: OPTIONS:
 45:   --json              Output in JSON format
 46:   --require-tasks     Require tasks.md to exist (for implementation phase)
 47:   --include-tasks     Include tasks.md in AVAILABLE_DOCS list
 48:   --paths-only        Only output path variables (no prerequisite validation)
 49:   --help, -h          Show this help message
 50: EXAMPLES:
 51:   # Check task prerequisites (plan.md required)
 52:   ./check-prerequisites.sh --json
 53:   # Check implementation prerequisites (plan.md + tasks.md required)
 54:   ./check-prerequisites.sh --json --require-tasks --include-tasks
 55:   # Get feature paths only (no validation)
 56:   ./check-prerequisites.sh --paths-only
 57: EOF
 58:             exit 0
 59:             ;;
 60:         *)
 61:             echo "ERROR: Unknown option '$arg'. Use --help for usage information." >&2
 62:             exit 1
 63:             ;;
 64:     esac
 65: done
 66: # Source common functions
 67: SCRIPT_DIR="$(CDPATH="" cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 68: source "$SCRIPT_DIR/common.sh"
 69: # Get feature paths and validate branch
 70: eval $(get_feature_paths)
 71: check_feature_branch "$CURRENT_BRANCH" "$HAS_GIT" || exit 1
 72: # If paths-only mode, output paths and exit (support JSON + paths-only combined)
 73: if $PATHS_ONLY; then
 74:     if $JSON_MODE; then
 75:         # Minimal JSON paths payload (no validation performed)
 76:         printf '{"REPO_ROOT":"%s","BRANCH":"%s","FEATURE_DIR":"%s","FEATURE_SPEC":"%s","IMPL_PLAN":"%s","TASKS":"%s"}\n' \
 77:             "$REPO_ROOT" "$CURRENT_BRANCH" "$FEATURE_DIR" "$FEATURE_SPEC" "$IMPL_PLAN" "$TASKS"
 78:     else
 79:         echo "REPO_ROOT: $REPO_ROOT"
 80:         echo "BRANCH: $CURRENT_BRANCH"
 81:         echo "FEATURE_DIR: $FEATURE_DIR"
 82:         echo "FEATURE_SPEC: $FEATURE_SPEC"
 83:         echo "IMPL_PLAN: $IMPL_PLAN"
 84:         echo "TASKS: $TASKS"
 85:     fi
 86:     exit 0
 87: fi
 88: # Validate required directories and files
 89: if [[ ! -d "$FEATURE_DIR" ]]; then
 90:     echo "ERROR: Feature directory not found: $FEATURE_DIR" >&2
 91:     echo "Run /speckit.specify first to create the feature structure." >&2
 92:     exit 1
 93: fi
 94: if [[ ! -f "$IMPL_PLAN" ]]; then
 95:     echo "ERROR: plan.md not found in $FEATURE_DIR" >&2
 96:     echo "Run /speckit.plan first to create the implementation plan." >&2
 97:     exit 1
 98: fi
 99: # Check for tasks.md if required
100: if $REQUIRE_TASKS && [[ ! -f "$TASKS" ]]; then
101:     echo "ERROR: tasks.md not found in $FEATURE_DIR" >&2
102:     echo "Run /speckit.tasks first to create the task list." >&2
103:     exit 1
104: fi
105: # Build list of available documents
106: docs=()
107: # Always check these optional docs
108: [[ -f "$RESEARCH" ]] && docs+=("research.md")
109: [[ -f "$DATA_MODEL" ]] && docs+=("data-model.md")
110: # Check contracts directory (only if it exists and has files)
111: if [[ -d "$CONTRACTS_DIR" ]] && [[ -n "$(ls -A "$CONTRACTS_DIR" 2>/dev/null)" ]]; then
112:     docs+=("contracts/")
113: fi
114: [[ -f "$QUICKSTART" ]] && docs+=("quickstart.md")
115: # Include tasks.md if requested and it exists
116: if $INCLUDE_TASKS && [[ -f "$TASKS" ]]; then
117:     docs+=("tasks.md")
118: fi
119: # Output results
120: if $JSON_MODE; then
121:     # Build JSON array of documents
122:     if [[ ${#docs[@]} -eq 0 ]]; then
123:         json_docs="[]"
124:     else
125:         json_docs=$(printf '"%s",' "${docs[@]}")
126:         json_docs="[${json_docs%,}]"
127:     fi
128:     printf '{"FEATURE_DIR":"%s","AVAILABLE_DOCS":%s}\n' "$FEATURE_DIR" "$json_docs"
129: else
130:     # Text output
131:     echo "FEATURE_DIR:$FEATURE_DIR"
132:     echo "AVAILABLE_DOCS:"
133:     # Show status of each potential document
134:     check_file "$RESEARCH" "research.md"
135:     check_file "$DATA_MODEL" "data-model.md"
136:     check_dir "$CONTRACTS_DIR" "contracts/"
137:     check_file "$QUICKSTART" "quickstart.md"
138:     if $INCLUDE_TASKS; then
139:         check_file "$TASKS" "tasks.md"
140:     fi
141: fi
</file>

<file path=".specify/scripts/bash/common.sh">
  1: #!/usr/bin/env bash
  2: # Common functions and variables for all scripts
  3: # Get repository root, with fallback for non-git repositories
  4: get_repo_root() {
  5:     if git rev-parse --show-toplevel >/dev/null 2>&1; then
  6:         git rev-parse --show-toplevel
  7:     else
  8:         # Fall back to script location for non-git repos
  9:         local script_dir="$(CDPATH="" cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 10:         (cd "$script_dir/../../.." && pwd)
 11:     fi
 12: }
 13: # Get current branch, with fallback for non-git repositories
 14: get_current_branch() {
 15:     # First check if SPECIFY_FEATURE environment variable is set
 16:     if [[ -n "${SPECIFY_FEATURE:-}" ]]; then
 17:         echo "$SPECIFY_FEATURE"
 18:         return
 19:     fi
 20:     # Then check git if available
 21:     if git rev-parse --abbrev-ref HEAD >/dev/null 2>&1; then
 22:         git rev-parse --abbrev-ref HEAD
 23:         return
 24:     fi
 25:     # For non-git repos, try to find the latest feature directory
 26:     local repo_root=$(get_repo_root)
 27:     local specs_dir="$repo_root/specs"
 28:     if [[ -d "$specs_dir" ]]; then
 29:         local latest_feature=""
 30:         local highest=0
 31:         for dir in "$specs_dir"/*; do
 32:             if [[ -d "$dir" ]]; then
 33:                 local dirname=$(basename "$dir")
 34:                 if [[ "$dirname" =~ ^([0-9]{3})- ]]; then
 35:                     local number=${BASH_REMATCH[1]}
 36:                     number=$((10#$number))
 37:                     if [[ "$number" -gt "$highest" ]]; then
 38:                         highest=$number
 39:                         latest_feature=$dirname
 40:                     fi
 41:                 fi
 42:             fi
 43:         done
 44:         if [[ -n "$latest_feature" ]]; then
 45:             echo "$latest_feature"
 46:             return
 47:         fi
 48:     fi
 49:     echo "main"  # Final fallback
 50: }
 51: # Check if we have git available
 52: has_git() {
 53:     git rev-parse --show-toplevel >/dev/null 2>&1
 54: }
 55: check_feature_branch() {
 56:     local branch="$1"
 57:     local has_git_repo="$2"
 58:     # For non-git repos, we can't enforce branch naming but still provide output
 59:     if [[ "$has_git_repo" != "true" ]]; then
 60:         echo "[specify] Warning: Git repository not detected; skipped branch validation" >&2
 61:         return 0
 62:     fi
 63:     if [[ ! "$branch" =~ ^[0-9]{3}- ]]; then
 64:         echo "ERROR: Not on a feature branch. Current branch: $branch" >&2
 65:         echo "Feature branches should be named like: 001-feature-name" >&2
 66:         return 1
 67:     fi
 68:     return 0
 69: }
 70: get_feature_dir() { echo "$1/specs/$2"; }
 71: # Find feature directory by numeric prefix instead of exact branch match
 72: # This allows multiple branches to work on the same spec (e.g., 004-fix-bug, 004-add-feature)
 73: find_feature_dir_by_prefix() {
 74:     local repo_root="$1"
 75:     local branch_name="$2"
 76:     local specs_dir="$repo_root/specs"
 77:     # Extract numeric prefix from branch (e.g., "004" from "004-whatever")
 78:     if [[ ! "$branch_name" =~ ^([0-9]{3})- ]]; then
 79:         # If branch doesn't have numeric prefix, fall back to exact match
 80:         echo "$specs_dir/$branch_name"
 81:         return
 82:     fi
 83:     local prefix="${BASH_REMATCH[1]}"
 84:     # Search for directories in specs/ that start with this prefix
 85:     local matches=()
 86:     if [[ -d "$specs_dir" ]]; then
 87:         for dir in "$specs_dir"/"$prefix"-*; do
 88:             if [[ -d "$dir" ]]; then
 89:                 matches+=("$(basename "$dir")")
 90:             fi
 91:         done
 92:     fi
 93:     # Handle results
 94:     if [[ ${#matches[@]} -eq 0 ]]; then
 95:         # No match found - return the branch name path (will fail later with clear error)
 96:         echo "$specs_dir/$branch_name"
 97:     elif [[ ${#matches[@]} -eq 1 ]]; then
 98:         # Exactly one match - perfect!
 99:         echo "$specs_dir/${matches[0]}"
100:     else
101:         # Multiple matches - this shouldn't happen with proper naming convention
102:         echo "ERROR: Multiple spec directories found with prefix '$prefix': ${matches[*]}" >&2
103:         echo "Please ensure only one spec directory exists per numeric prefix." >&2
104:         echo "$specs_dir/$branch_name"  # Return something to avoid breaking the script
105:     fi
106: }
107: get_feature_paths() {
108:     local repo_root=$(get_repo_root)
109:     local current_branch=$(get_current_branch)
110:     local has_git_repo="false"
111:     if has_git; then
112:         has_git_repo="true"
113:     fi
114:     # Use prefix-based lookup to support multiple branches per spec
115:     local feature_dir=$(find_feature_dir_by_prefix "$repo_root" "$current_branch")
116:     cat <<EOF
117: REPO_ROOT='$repo_root'
118: CURRENT_BRANCH='$current_branch'
119: HAS_GIT='$has_git_repo'
120: FEATURE_DIR='$feature_dir'
121: FEATURE_SPEC='$feature_dir/spec.md'
122: IMPL_PLAN='$feature_dir/plan.md'
123: TASKS='$feature_dir/tasks.md'
124: RESEARCH='$feature_dir/research.md'
125: DATA_MODEL='$feature_dir/data-model.md'
126: QUICKSTART='$feature_dir/quickstart.md'
127: CONTRACTS_DIR='$feature_dir/contracts'
128: EOF
129: }
130: check_file() { [[ -f "$1" ]] && echo "  ‚úì $2" || echo "  ‚úó $2"; }
131: check_dir() { [[ -d "$1" && -n $(ls -A "$1" 2>/dev/null) ]] && echo "  ‚úì $2" || echo "  ‚úó $2"; }
</file>

<file path=".specify/scripts/bash/create-new-feature.sh">
  1: #!/usr/bin/env bash
  2: set -e
  3: JSON_MODE=false
  4: SHORT_NAME=""
  5: BRANCH_NUMBER=""
  6: ARGS=()
  7: i=1
  8: while [ $i -le $# ]; do
  9:     arg="${!i}"
 10:     case "$arg" in
 11:         --json) 
 12:             JSON_MODE=true 
 13:             ;;
 14:         --short-name)
 15:             if [ $((i + 1)) -gt $# ]; then
 16:                 echo 'Error: --short-name requires a value' >&2
 17:                 exit 1
 18:             fi
 19:             i=$((i + 1))
 20:             next_arg="${!i}"
 21:             # Check if the next argument is another option (starts with --)
 22:             if [[ "$next_arg" == --* ]]; then
 23:                 echo 'Error: --short-name requires a value' >&2
 24:                 exit 1
 25:             fi
 26:             SHORT_NAME="$next_arg"
 27:             ;;
 28:         --number)
 29:             if [ $((i + 1)) -gt $# ]; then
 30:                 echo 'Error: --number requires a value' >&2
 31:                 exit 1
 32:             fi
 33:             i=$((i + 1))
 34:             next_arg="${!i}"
 35:             if [[ "$next_arg" == --* ]]; then
 36:                 echo 'Error: --number requires a value' >&2
 37:                 exit 1
 38:             fi
 39:             BRANCH_NUMBER="$next_arg"
 40:             ;;
 41:         --help|-h) 
 42:             echo "Usage: $0 [--json] [--short-name <name>] [--number N] <feature_description>"
 43:             echo ""
 44:             echo "Options:"
 45:             echo "  --json              Output in JSON format"
 46:             echo "  --short-name <name> Provide a custom short name (2-4 words) for the branch"
 47:             echo "  --number N          Specify branch number manually (overrides auto-detection)"
 48:             echo "  --help, -h          Show this help message"
 49:             echo ""
 50:             echo "Examples:"
 51:             echo "  $0 'Add user authentication system' --short-name 'user-auth'"
 52:             echo "  $0 'Implement OAuth2 integration for API' --number 5"
 53:             exit 0
 54:             ;;
 55:         *) 
 56:             ARGS+=("$arg") 
 57:             ;;
 58:     esac
 59:     i=$((i + 1))
 60: done
 61: FEATURE_DESCRIPTION="${ARGS[*]}"
 62: if [ -z "$FEATURE_DESCRIPTION" ]; then
 63:     echo "Usage: $0 [--json] [--short-name <name>] [--number N] <feature_description>" >&2
 64:     exit 1
 65: fi
 66: # Function to find the repository root by searching for existing project markers
 67: find_repo_root() {
 68:     local dir="$1"
 69:     while [ "$dir" != "/" ]; do
 70:         if [ -d "$dir/.git" ] || [ -d "$dir/.specify" ]; then
 71:             echo "$dir"
 72:             return 0
 73:         fi
 74:         dir="$(dirname "$dir")"
 75:     done
 76:     return 1
 77: }
 78: # Function to get highest number from specs directory
 79: get_highest_from_specs() {
 80:     local specs_dir="$1"
 81:     local highest=0
 82:     if [ -d "$specs_dir" ]; then
 83:         for dir in "$specs_dir"/*; do
 84:             [ -d "$dir" ] || continue
 85:             dirname=$(basename "$dir")
 86:             number=$(echo "$dirname" | grep -o '^[0-9]\+' || echo "0")
 87:             number=$((10#$number))
 88:             if [ "$number" -gt "$highest" ]; then
 89:                 highest=$number
 90:             fi
 91:         done
 92:     fi
 93:     echo "$highest"
 94: }
 95: # Function to get highest number from git branches
 96: get_highest_from_branches() {
 97:     local highest=0
 98:     # Get all branches (local and remote)
 99:     branches=$(git branch -a 2>/dev/null || echo "")
100:     if [ -n "$branches" ]; then
101:         while IFS= read -r branch; do
102:             # Clean branch name: remove leading markers and remote prefixes
103:             clean_branch=$(echo "$branch" | sed 's/^[* ]*//; s|^remotes/[^/]*/||')
104:             # Extract feature number if branch matches pattern ###-*
105:             if echo "$clean_branch" | grep -q '^[0-9]\{3\}-'; then
106:                 number=$(echo "$clean_branch" | grep -o '^[0-9]\{3\}' || echo "0")
107:                 number=$((10#$number))
108:                 if [ "$number" -gt "$highest" ]; then
109:                     highest=$number
110:                 fi
111:             fi
112:         done <<< "$branches"
113:     fi
114:     echo "$highest"
115: }
116: # Function to check existing branches (local and remote) and return next available number
117: check_existing_branches() {
118:     local specs_dir="$1"
119:     # Fetch all remotes to get latest branch info (suppress errors if no remotes)
120:     git fetch --all --prune 2>/dev/null || true
121:     # Get highest number from ALL branches (not just matching short name)
122:     local highest_branch=$(get_highest_from_branches)
123:     # Get highest number from ALL specs (not just matching short name)
124:     local highest_spec=$(get_highest_from_specs "$specs_dir")
125:     # Take the maximum of both
126:     local max_num=$highest_branch
127:     if [ "$highest_spec" -gt "$max_num" ]; then
128:         max_num=$highest_spec
129:     fi
130:     # Return next number
131:     echo $((max_num + 1))
132: }
133: # Function to clean and format a branch name
134: clean_branch_name() {
135:     local name="$1"
136:     echo "$name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/-\+/-/g' | sed 's/^-//' | sed 's/-$//'
137: }
138: # Resolve repository root. Prefer git information when available, but fall back
139: # to searching for repository markers so the workflow still functions in repositories that
140: # were initialised with --no-git.
141: SCRIPT_DIR="$(CDPATH="" cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
142: if git rev-parse --show-toplevel >/dev/null 2>&1; then
143:     REPO_ROOT=$(git rev-parse --show-toplevel)
144:     HAS_GIT=true
145: else
146:     REPO_ROOT="$(find_repo_root "$SCRIPT_DIR")"
147:     if [ -z "$REPO_ROOT" ]; then
148:         echo "Error: Could not determine repository root. Please run this script from within the repository." >&2
149:         exit 1
150:     fi
151:     HAS_GIT=false
152: fi
153: cd "$REPO_ROOT"
154: SPECS_DIR="$REPO_ROOT/specs"
155: mkdir -p "$SPECS_DIR"
156: # Function to generate branch name with stop word filtering and length filtering
157: generate_branch_name() {
158:     local description="$1"
159:     # Common stop words to filter out
160:     local stop_words="^(i|a|an|the|to|for|of|in|on|at|by|with|from|is|are|was|were|be|been|being|have|has|had|do|does|did|will|would|should|could|can|may|might|must|shall|this|that|these|those|my|your|our|their|want|need|add|get|set)$"
161:     # Convert to lowercase and split into words
162:     local clean_name=$(echo "$description" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/ /g')
163:     # Filter words: remove stop words and words shorter than 3 chars (unless they're uppercase acronyms in original)
164:     local meaningful_words=()
165:     for word in $clean_name; do
166:         # Skip empty words
167:         [ -z "$word" ] && continue
168:         # Keep words that are NOT stop words AND (length >= 3 OR are potential acronyms)
169:         if ! echo "$word" | grep -qiE "$stop_words"; then
170:             if [ ${#word} -ge 3 ]; then
171:                 meaningful_words+=("$word")
172:             elif echo "$description" | grep -q "\b${word^^}\b"; then
173:                 # Keep short words if they appear as uppercase in original (likely acronyms)
174:                 meaningful_words+=("$word")
175:             fi
176:         fi
177:     done
178:     # If we have meaningful words, use first 3-4 of them
179:     if [ ${#meaningful_words[@]} -gt 0 ]; then
180:         local max_words=3
181:         if [ ${#meaningful_words[@]} -eq 4 ]; then max_words=4; fi
182:         local result=""
183:         local count=0
184:         for word in "${meaningful_words[@]}"; do
185:             if [ $count -ge $max_words ]; then break; fi
186:             if [ -n "$result" ]; then result="$result-"; fi
187:             result="$result$word"
188:             count=$((count + 1))
189:         done
190:         echo "$result"
191:     else
192:         # Fallback to original logic if no meaningful words found
193:         local cleaned=$(clean_branch_name "$description")
194:         echo "$cleaned" | tr '-' '\n' | grep -v '^$' | head -3 | tr '\n' '-' | sed 's/-$//'
195:     fi
196: }
197: # Generate branch name
198: if [ -n "$SHORT_NAME" ]; then
199:     # Use provided short name, just clean it up
200:     BRANCH_SUFFIX=$(clean_branch_name "$SHORT_NAME")
201: else
202:     # Generate from description with smart filtering
203:     BRANCH_SUFFIX=$(generate_branch_name "$FEATURE_DESCRIPTION")
204: fi
205: # Determine branch number
206: if [ -z "$BRANCH_NUMBER" ]; then
207:     if [ "$HAS_GIT" = true ]; then
208:         # Check existing branches on remotes
209:         BRANCH_NUMBER=$(check_existing_branches "$SPECS_DIR")
210:     else
211:         # Fall back to local directory check
212:         HIGHEST=$(get_highest_from_specs "$SPECS_DIR")
213:         BRANCH_NUMBER=$((HIGHEST + 1))
214:     fi
215: fi
216: # Force base-10 interpretation to prevent octal conversion (e.g., 010 ‚Üí 8 in octal, but should be 10 in decimal)
217: FEATURE_NUM=$(printf "%03d" "$((10#$BRANCH_NUMBER))")
218: BRANCH_NAME="${FEATURE_NUM}-${BRANCH_SUFFIX}"
219: # GitHub enforces a 244-byte limit on branch names
220: # Validate and truncate if necessary
221: MAX_BRANCH_LENGTH=244
222: if [ ${#BRANCH_NAME} -gt $MAX_BRANCH_LENGTH ]; then
223:     # Calculate how much we need to trim from suffix
224:     # Account for: feature number (3) + hyphen (1) = 4 chars
225:     MAX_SUFFIX_LENGTH=$((MAX_BRANCH_LENGTH - 4))
226:     # Truncate suffix at word boundary if possible
227:     TRUNCATED_SUFFIX=$(echo "$BRANCH_SUFFIX" | cut -c1-$MAX_SUFFIX_LENGTH)
228:     # Remove trailing hyphen if truncation created one
229:     TRUNCATED_SUFFIX=$(echo "$TRUNCATED_SUFFIX" | sed 's/-$//')
230:     ORIGINAL_BRANCH_NAME="$BRANCH_NAME"
231:     BRANCH_NAME="${FEATURE_NUM}-${TRUNCATED_SUFFIX}"
232:     >&2 echo "[specify] Warning: Branch name exceeded GitHub's 244-byte limit"
233:     >&2 echo "[specify] Original: $ORIGINAL_BRANCH_NAME (${#ORIGINAL_BRANCH_NAME} bytes)"
234:     >&2 echo "[specify] Truncated to: $BRANCH_NAME (${#BRANCH_NAME} bytes)"
235: fi
236: if [ "$HAS_GIT" = true ]; then
237:     git checkout -b "$BRANCH_NAME"
238: else
239:     >&2 echo "[specify] Warning: Git repository not detected; skipped branch creation for $BRANCH_NAME"
240: fi
241: FEATURE_DIR="$SPECS_DIR/$BRANCH_NAME"
242: mkdir -p "$FEATURE_DIR"
243: TEMPLATE="$REPO_ROOT/.specify/templates/spec-template.md"
244: SPEC_FILE="$FEATURE_DIR/spec.md"
245: if [ -f "$TEMPLATE" ]; then cp "$TEMPLATE" "$SPEC_FILE"; else touch "$SPEC_FILE"; fi
246: # Set the SPECIFY_FEATURE environment variable for the current session
247: export SPECIFY_FEATURE="$BRANCH_NAME"
248: if $JSON_MODE; then
249:     printf '{"BRANCH_NAME":"%s","SPEC_FILE":"%s","FEATURE_NUM":"%s"}\n' "$BRANCH_NAME" "$SPEC_FILE" "$FEATURE_NUM"
250: else
251:     echo "BRANCH_NAME: $BRANCH_NAME"
252:     echo "SPEC_FILE: $SPEC_FILE"
253:     echo "FEATURE_NUM: $FEATURE_NUM"
254:     echo "SPECIFY_FEATURE environment variable set to: $BRANCH_NAME"
255: fi
</file>

<file path=".specify/scripts/bash/setup-plan.sh">
 1: #!/usr/bin/env bash
 2: set -e
 3: # Parse command line arguments
 4: JSON_MODE=false
 5: ARGS=()
 6: for arg in "$@"; do
 7:     case "$arg" in
 8:         --json) 
 9:             JSON_MODE=true 
10:             ;;
11:         --help|-h) 
12:             echo "Usage: $0 [--json]"
13:             echo "  --json    Output results in JSON format"
14:             echo "  --help    Show this help message"
15:             exit 0 
16:             ;;
17:         *) 
18:             ARGS+=("$arg") 
19:             ;;
20:     esac
21: done
22: # Get script directory and load common functions
23: SCRIPT_DIR="$(CDPATH="" cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
24: source "$SCRIPT_DIR/common.sh"
25: # Get all paths and variables from common functions
26: eval $(get_feature_paths)
27: # Check if we're on a proper feature branch (only for git repos)
28: check_feature_branch "$CURRENT_BRANCH" "$HAS_GIT" || exit 1
29: # Ensure the feature directory exists
30: mkdir -p "$FEATURE_DIR"
31: # Copy plan template if it exists
32: TEMPLATE="$REPO_ROOT/.specify/templates/plan-template.md"
33: if [[ -f "$TEMPLATE" ]]; then
34:     cp "$TEMPLATE" "$IMPL_PLAN"
35:     echo "Copied plan template to $IMPL_PLAN"
36: else
37:     echo "Warning: Plan template not found at $TEMPLATE"
38:     # Create a basic plan file if template doesn't exist
39:     touch "$IMPL_PLAN"
40: fi
41: # Output results
42: if $JSON_MODE; then
43:     printf '{"FEATURE_SPEC":"%s","IMPL_PLAN":"%s","SPECS_DIR":"%s","BRANCH":"%s","HAS_GIT":"%s"}\n' \
44:         "$FEATURE_SPEC" "$IMPL_PLAN" "$FEATURE_DIR" "$CURRENT_BRANCH" "$HAS_GIT"
45: else
46:     echo "FEATURE_SPEC: $FEATURE_SPEC"
47:     echo "IMPL_PLAN: $IMPL_PLAN" 
48:     echo "SPECS_DIR: $FEATURE_DIR"
49:     echo "BRANCH: $CURRENT_BRANCH"
50:     echo "HAS_GIT: $HAS_GIT"
51: fi
</file>

<file path=".specify/scripts/bash/update-agent-context.sh">
  1: #!/usr/bin/env bash
  2: # Update agent context files with information from plan.md
  3: #
  4: # This script maintains AI agent context files by parsing feature specifications 
  5: # and updating agent-specific configuration files with project information.
  6: #
  7: # MAIN FUNCTIONS:
  8: # 1. Environment Validation
  9: #    - Verifies git repository structure and branch information
 10: #    - Checks for required plan.md files and templates
 11: #    - Validates file permissions and accessibility
 12: #
 13: # 2. Plan Data Extraction
 14: #    - Parses plan.md files to extract project metadata
 15: #    - Identifies language/version, frameworks, databases, and project types
 16: #    - Handles missing or incomplete specification data gracefully
 17: #
 18: # 3. Agent File Management
 19: #    - Creates new agent context files from templates when needed
 20: #    - Updates existing agent files with new project information
 21: #    - Preserves manual additions and custom configurations
 22: #    - Supports multiple AI agent formats and directory structures
 23: #
 24: # 4. Content Generation
 25: #    - Generates language-specific build/test commands
 26: #    - Creates appropriate project directory structures
 27: #    - Updates technology stacks and recent changes sections
 28: #    - Maintains consistent formatting and timestamps
 29: #
 30: # 5. Multi-Agent Support
 31: #    - Handles agent-specific file paths and naming conventions
 32: #    - Supports: Claude, Gemini, Copilot, Cursor, Qwen, opencode, Codex, Windsurf, Kilo Code, Auggie CLI, Roo Code, CodeBuddy CLI, Qoder CLI, Amp, SHAI, or Amazon Q Developer CLI
 33: #    - Can update single agents or all existing agent files
 34: #    - Creates default Claude file if no agent files exist
 35: #
 36: # Usage: ./update-agent-context.sh [agent_type]
 37: # Agent types: claude|gemini|copilot|cursor-agent|qwen|opencode|codex|windsurf|kilocode|auggie|shai|q|bob|qoder
 38: # Leave empty to update all existing agent files
 39: set -e
 40: # Enable strict error handling
 41: set -u
 42: set -o pipefail
 43: #==============================================================================
 44: # Configuration and Global Variables
 45: #==============================================================================
 46: # Get script directory and load common functions
 47: SCRIPT_DIR="$(CDPATH="" cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
 48: source "$SCRIPT_DIR/common.sh"
 49: # Get all paths and variables from common functions
 50: eval $(get_feature_paths)
 51: NEW_PLAN="$IMPL_PLAN"  # Alias for compatibility with existing code
 52: AGENT_TYPE="${1:-}"
 53: # Agent-specific file paths  
 54: CLAUDE_FILE="$REPO_ROOT/CLAUDE.md"
 55: GEMINI_FILE="$REPO_ROOT/GEMINI.md"
 56: COPILOT_FILE="$REPO_ROOT/.github/agents/copilot-instructions.md"
 57: CURSOR_FILE="$REPO_ROOT/.cursor/rules/specify-rules.mdc"
 58: QWEN_FILE="$REPO_ROOT/QWEN.md"
 59: AGENTS_FILE="$REPO_ROOT/AGENTS.md"
 60: WINDSURF_FILE="$REPO_ROOT/.windsurf/rules/specify-rules.md"
 61: KILOCODE_FILE="$REPO_ROOT/.kilocode/rules/specify-rules.md"
 62: AUGGIE_FILE="$REPO_ROOT/.augment/rules/specify-rules.md"
 63: ROO_FILE="$REPO_ROOT/.roo/rules/specify-rules.md"
 64: CODEBUDDY_FILE="$REPO_ROOT/CODEBUDDY.md"
 65: QODER_FILE="$REPO_ROOT/QODER.md"
 66: AMP_FILE="$REPO_ROOT/AGENTS.md"
 67: SHAI_FILE="$REPO_ROOT/SHAI.md"
 68: Q_FILE="$REPO_ROOT/AGENTS.md"
 69: BOB_FILE="$REPO_ROOT/AGENTS.md"
 70: # Template file
 71: TEMPLATE_FILE="$REPO_ROOT/.specify/templates/agent-file-template.md"
 72: # Global variables for parsed plan data
 73: NEW_LANG=""
 74: NEW_FRAMEWORK=""
 75: NEW_DB=""
 76: NEW_PROJECT_TYPE=""
 77: #==============================================================================
 78: # Utility Functions
 79: #==============================================================================
 80: log_info() {
 81:     echo "INFO: $1"
 82: }
 83: log_success() {
 84:     echo "‚úì $1"
 85: }
 86: log_error() {
 87:     echo "ERROR: $1" >&2
 88: }
 89: log_warning() {
 90:     echo "WARNING: $1" >&2
 91: }
 92: # Cleanup function for temporary files
 93: cleanup() {
 94:     local exit_code=$?
 95:     rm -f /tmp/agent_update_*_$$
 96:     rm -f /tmp/manual_additions_$$
 97:     exit $exit_code
 98: }
 99: # Set up cleanup trap
100: trap cleanup EXIT INT TERM
101: #==============================================================================
102: # Validation Functions
103: #==============================================================================
104: validate_environment() {
105:     # Check if we have a current branch/feature (git or non-git)
106:     if [[ -z "$CURRENT_BRANCH" ]]; then
107:         log_error "Unable to determine current feature"
108:         if [[ "$HAS_GIT" == "true" ]]; then
109:             log_info "Make sure you're on a feature branch"
110:         else
111:             log_info "Set SPECIFY_FEATURE environment variable or create a feature first"
112:         fi
113:         exit 1
114:     fi
115:     # Check if plan.md exists
116:     if [[ ! -f "$NEW_PLAN" ]]; then
117:         log_error "No plan.md found at $NEW_PLAN"
118:         log_info "Make sure you're working on a feature with a corresponding spec directory"
119:         if [[ "$HAS_GIT" != "true" ]]; then
120:             log_info "Use: export SPECIFY_FEATURE=your-feature-name or create a new feature first"
121:         fi
122:         exit 1
123:     fi
124:     # Check if template exists (needed for new files)
125:     if [[ ! -f "$TEMPLATE_FILE" ]]; then
126:         log_warning "Template file not found at $TEMPLATE_FILE"
127:         log_warning "Creating new agent files will fail"
128:     fi
129: }
130: #==============================================================================
131: # Plan Parsing Functions
132: #==============================================================================
133: extract_plan_field() {
134:     local field_pattern="$1"
135:     local plan_file="$2"
136:     grep "^\*\*${field_pattern}\*\*: " "$plan_file" 2>/dev/null | \
137:         head -1 | \
138:         sed "s|^\*\*${field_pattern}\*\*: ||" | \
139:         sed 's/^[ \t]*//;s/[ \t]*$//' | \
140:         grep -v "NEEDS CLARIFICATION" | \
141:         grep -v "^N/A$" || echo ""
142: }
143: parse_plan_data() {
144:     local plan_file="$1"
145:     if [[ ! -f "$plan_file" ]]; then
146:         log_error "Plan file not found: $plan_file"
147:         return 1
148:     fi
149:     if [[ ! -r "$plan_file" ]]; then
150:         log_error "Plan file is not readable: $plan_file"
151:         return 1
152:     fi
153:     log_info "Parsing plan data from $plan_file"
154:     NEW_LANG=$(extract_plan_field "Language/Version" "$plan_file")
155:     NEW_FRAMEWORK=$(extract_plan_field "Primary Dependencies" "$plan_file")
156:     NEW_DB=$(extract_plan_field "Storage" "$plan_file")
157:     NEW_PROJECT_TYPE=$(extract_plan_field "Project Type" "$plan_file")
158:     # Log what we found
159:     if [[ -n "$NEW_LANG" ]]; then
160:         log_info "Found language: $NEW_LANG"
161:     else
162:         log_warning "No language information found in plan"
163:     fi
164:     if [[ -n "$NEW_FRAMEWORK" ]]; then
165:         log_info "Found framework: $NEW_FRAMEWORK"
166:     fi
167:     if [[ -n "$NEW_DB" ]] && [[ "$NEW_DB" != "N/A" ]]; then
168:         log_info "Found database: $NEW_DB"
169:     fi
170:     if [[ -n "$NEW_PROJECT_TYPE" ]]; then
171:         log_info "Found project type: $NEW_PROJECT_TYPE"
172:     fi
173: }
174: format_technology_stack() {
175:     local lang="$1"
176:     local framework="$2"
177:     local parts=()
178:     # Add non-empty parts
179:     [[ -n "$lang" && "$lang" != "NEEDS CLARIFICATION" ]] && parts+=("$lang")
180:     [[ -n "$framework" && "$framework" != "NEEDS CLARIFICATION" && "$framework" != "N/A" ]] && parts+=("$framework")
181:     # Join with proper formatting
182:     if [[ ${#parts[@]} -eq 0 ]]; then
183:         echo ""
184:     elif [[ ${#parts[@]} -eq 1 ]]; then
185:         echo "${parts[0]}"
186:     else
187:         # Join multiple parts with " + "
188:         local result="${parts[0]}"
189:         for ((i=1; i<${#parts[@]}; i++)); do
190:             result="$result + ${parts[i]}"
191:         done
192:         echo "$result"
193:     fi
194: }
195: #==============================================================================
196: # Template and Content Generation Functions
197: #==============================================================================
198: get_project_structure() {
199:     local project_type="$1"
200:     if [[ "$project_type" == *"web"* ]]; then
201:         echo "backend/\\nfrontend/\\ntests/"
202:     else
203:         echo "src/\\ntests/"
204:     fi
205: }
206: get_commands_for_language() {
207:     local lang="$1"
208:     case "$lang" in
209:         *"Python"*)
210:             echo "cd src && pytest && ruff check ."
211:             ;;
212:         *"Rust"*)
213:             echo "cargo test && cargo clippy"
214:             ;;
215:         *"JavaScript"*|*"TypeScript"*)
216:             echo "npm test \\&\\& npm run lint"
217:             ;;
218:         *)
219:             echo "# Add commands for $lang"
220:             ;;
221:     esac
222: }
223: get_language_conventions() {
224:     local lang="$1"
225:     echo "$lang: Follow standard conventions"
226: }
227: create_new_agent_file() {
228:     local target_file="$1"
229:     local temp_file="$2"
230:     local project_name="$3"
231:     local current_date="$4"
232:     if [[ ! -f "$TEMPLATE_FILE" ]]; then
233:         log_error "Template not found at $TEMPLATE_FILE"
234:         return 1
235:     fi
236:     if [[ ! -r "$TEMPLATE_FILE" ]]; then
237:         log_error "Template file is not readable: $TEMPLATE_FILE"
238:         return 1
239:     fi
240:     log_info "Creating new agent context file from template..."
241:     if ! cp "$TEMPLATE_FILE" "$temp_file"; then
242:         log_error "Failed to copy template file"
243:         return 1
244:     fi
245:     # Replace template placeholders
246:     local project_structure
247:     project_structure=$(get_project_structure "$NEW_PROJECT_TYPE")
248:     local commands
249:     commands=$(get_commands_for_language "$NEW_LANG")
250:     local language_conventions
251:     language_conventions=$(get_language_conventions "$NEW_LANG")
252:     # Perform substitutions with error checking using safer approach
253:     # Escape special characters for sed by using a different delimiter or escaping
254:     local escaped_lang=$(printf '%s\n' "$NEW_LANG" | sed 's/[\[\.*^$()+{}|]/\\&/g')
255:     local escaped_framework=$(printf '%s\n' "$NEW_FRAMEWORK" | sed 's/[\[\.*^$()+{}|]/\\&/g')
256:     local escaped_branch=$(printf '%s\n' "$CURRENT_BRANCH" | sed 's/[\[\.*^$()+{}|]/\\&/g')
257:     # Build technology stack and recent change strings conditionally
258:     local tech_stack
259:     if [[ -n "$escaped_lang" && -n "$escaped_framework" ]]; then
260:         tech_stack="- $escaped_lang + $escaped_framework ($escaped_branch)"
261:     elif [[ -n "$escaped_lang" ]]; then
262:         tech_stack="- $escaped_lang ($escaped_branch)"
263:     elif [[ -n "$escaped_framework" ]]; then
264:         tech_stack="- $escaped_framework ($escaped_branch)"
265:     else
266:         tech_stack="- ($escaped_branch)"
267:     fi
268:     local recent_change
269:     if [[ -n "$escaped_lang" && -n "$escaped_framework" ]]; then
270:         recent_change="- $escaped_branch: Added $escaped_lang + $escaped_framework"
271:     elif [[ -n "$escaped_lang" ]]; then
272:         recent_change="- $escaped_branch: Added $escaped_lang"
273:     elif [[ -n "$escaped_framework" ]]; then
274:         recent_change="- $escaped_branch: Added $escaped_framework"
275:     else
276:         recent_change="- $escaped_branch: Added"
277:     fi
278:     local substitutions=(
279:         "s|\[PROJECT NAME\]|$project_name|"
280:         "s|\[DATE\]|$current_date|"
281:         "s|\[EXTRACTED FROM ALL PLAN.MD FILES\]|$tech_stack|"
282:         "s|\[ACTUAL STRUCTURE FROM PLANS\]|$project_structure|g"
283:         "s|\[ONLY COMMANDS FOR ACTIVE TECHNOLOGIES\]|$commands|"
284:         "s|\[LANGUAGE-SPECIFIC, ONLY FOR LANGUAGES IN USE\]|$language_conventions|"
285:         "s|\[LAST 3 FEATURES AND WHAT THEY ADDED\]|$recent_change|"
286:     )
287:     for substitution in "${substitutions[@]}"; do
288:         if ! sed -i.bak -e "$substitution" "$temp_file"; then
289:             log_error "Failed to perform substitution: $substitution"
290:             rm -f "$temp_file" "$temp_file.bak"
291:             return 1
292:         fi
293:     done
294:     # Convert \n sequences to actual newlines
295:     newline=$(printf '\n')
296:     sed -i.bak2 "s/\\\\n/${newline}/g" "$temp_file"
297:     # Clean up backup files
298:     rm -f "$temp_file.bak" "$temp_file.bak2"
299:     return 0
300: }
301: update_existing_agent_file() {
302:     local target_file="$1"
303:     local current_date="$2"
304:     log_info "Updating existing agent context file..."
305:     # Use a single temporary file for atomic update
306:     local temp_file
307:     temp_file=$(mktemp) || {
308:         log_error "Failed to create temporary file"
309:         return 1
310:     }
311:     # Process the file in one pass
312:     local tech_stack=$(format_technology_stack "$NEW_LANG" "$NEW_FRAMEWORK")
313:     local new_tech_entries=()
314:     local new_change_entry=""
315:     # Prepare new technology entries
316:     if [[ -n "$tech_stack" ]] && ! grep -q "$tech_stack" "$target_file"; then
317:         new_tech_entries+=("- $tech_stack ($CURRENT_BRANCH)")
318:     fi
319:     if [[ -n "$NEW_DB" ]] && [[ "$NEW_DB" != "N/A" ]] && [[ "$NEW_DB" != "NEEDS CLARIFICATION" ]] && ! grep -q "$NEW_DB" "$target_file"; then
320:         new_tech_entries+=("- $NEW_DB ($CURRENT_BRANCH)")
321:     fi
322:     # Prepare new change entry
323:     if [[ -n "$tech_stack" ]]; then
324:         new_change_entry="- $CURRENT_BRANCH: Added $tech_stack"
325:     elif [[ -n "$NEW_DB" ]] && [[ "$NEW_DB" != "N/A" ]] && [[ "$NEW_DB" != "NEEDS CLARIFICATION" ]]; then
326:         new_change_entry="- $CURRENT_BRANCH: Added $NEW_DB"
327:     fi
328:     # Check if sections exist in the file
329:     local has_active_technologies=0
330:     local has_recent_changes=0
331:     if grep -q "^## Active Technologies" "$target_file" 2>/dev/null; then
332:         has_active_technologies=1
333:     fi
334:     if grep -q "^## Recent Changes" "$target_file" 2>/dev/null; then
335:         has_recent_changes=1
336:     fi
337:     # Process file line by line
338:     local in_tech_section=false
339:     local in_changes_section=false
340:     local tech_entries_added=false
341:     local changes_entries_added=false
342:     local existing_changes_count=0
343:     local file_ended=false
344:     while IFS= read -r line || [[ -n "$line" ]]; do
345:         # Handle Active Technologies section
346:         if [[ "$line" == "## Active Technologies" ]]; then
347:             echo "$line" >> "$temp_file"
348:             in_tech_section=true
349:             continue
350:         elif [[ $in_tech_section == true ]] && [[ "$line" =~ ^##[[:space:]] ]]; then
351:             # Add new tech entries before closing the section
352:             if [[ $tech_entries_added == false ]] && [[ ${#new_tech_entries[@]} -gt 0 ]]; then
353:                 printf '%s\n' "${new_tech_entries[@]}" >> "$temp_file"
354:                 tech_entries_added=true
355:             fi
356:             echo "$line" >> "$temp_file"
357:             in_tech_section=false
358:             continue
359:         elif [[ $in_tech_section == true ]] && [[ -z "$line" ]]; then
360:             # Add new tech entries before empty line in tech section
361:             if [[ $tech_entries_added == false ]] && [[ ${#new_tech_entries[@]} -gt 0 ]]; then
362:                 printf '%s\n' "${new_tech_entries[@]}" >> "$temp_file"
363:                 tech_entries_added=true
364:             fi
365:             echo "$line" >> "$temp_file"
366:             continue
367:         fi
368:         # Handle Recent Changes section
369:         if [[ "$line" == "## Recent Changes" ]]; then
370:             echo "$line" >> "$temp_file"
371:             # Add new change entry right after the heading
372:             if [[ -n "$new_change_entry" ]]; then
373:                 echo "$new_change_entry" >> "$temp_file"
374:             fi
375:             in_changes_section=true
376:             changes_entries_added=true
377:             continue
378:         elif [[ $in_changes_section == true ]] && [[ "$line" =~ ^##[[:space:]] ]]; then
379:             echo "$line" >> "$temp_file"
380:             in_changes_section=false
381:             continue
382:         elif [[ $in_changes_section == true ]] && [[ "$line" == "- "* ]]; then
383:             # Keep only first 2 existing changes
384:             if [[ $existing_changes_count -lt 2 ]]; then
385:                 echo "$line" >> "$temp_file"
386:                 ((existing_changes_count++))
387:             fi
388:             continue
389:         fi
390:         # Update timestamp
391:         if [[ "$line" =~ \*\*Last\ updated\*\*:.*[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9] ]]; then
392:             echo "$line" | sed "s/[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]/$current_date/" >> "$temp_file"
393:         else
394:             echo "$line" >> "$temp_file"
395:         fi
396:     done < "$target_file"
397:     # Post-loop check: if we're still in the Active Technologies section and haven't added new entries
398:     if [[ $in_tech_section == true ]] && [[ $tech_entries_added == false ]] && [[ ${#new_tech_entries[@]} -gt 0 ]]; then
399:         printf '%s\n' "${new_tech_entries[@]}" >> "$temp_file"
400:         tech_entries_added=true
401:     fi
402:     # If sections don't exist, add them at the end of the file
403:     if [[ $has_active_technologies -eq 0 ]] && [[ ${#new_tech_entries[@]} -gt 0 ]]; then
404:         echo "" >> "$temp_file"
405:         echo "## Active Technologies" >> "$temp_file"
406:         printf '%s\n' "${new_tech_entries[@]}" >> "$temp_file"
407:         tech_entries_added=true
408:     fi
409:     if [[ $has_recent_changes -eq 0 ]] && [[ -n "$new_change_entry" ]]; then
410:         echo "" >> "$temp_file"
411:         echo "## Recent Changes" >> "$temp_file"
412:         echo "$new_change_entry" >> "$temp_file"
413:         changes_entries_added=true
414:     fi
415:     # Move temp file to target atomically
416:     if ! mv "$temp_file" "$target_file"; then
417:         log_error "Failed to update target file"
418:         rm -f "$temp_file"
419:         return 1
420:     fi
421:     return 0
422: }
423: #==============================================================================
424: # Main Agent File Update Function
425: #==============================================================================
426: update_agent_file() {
427:     local target_file="$1"
428:     local agent_name="$2"
429:     if [[ -z "$target_file" ]] || [[ -z "$agent_name" ]]; then
430:         log_error "update_agent_file requires target_file and agent_name parameters"
431:         return 1
432:     fi
433:     log_info "Updating $agent_name context file: $target_file"
434:     local project_name
435:     project_name=$(basename "$REPO_ROOT")
436:     local current_date
437:     current_date=$(date +%Y-%m-%d)
438:     # Create directory if it doesn't exist
439:     local target_dir
440:     target_dir=$(dirname "$target_file")
441:     if [[ ! -d "$target_dir" ]]; then
442:         if ! mkdir -p "$target_dir"; then
443:             log_error "Failed to create directory: $target_dir"
444:             return 1
445:         fi
446:     fi
447:     if [[ ! -f "$target_file" ]]; then
448:         # Create new file from template
449:         local temp_file
450:         temp_file=$(mktemp) || {
451:             log_error "Failed to create temporary file"
452:             return 1
453:         }
454:         if create_new_agent_file "$target_file" "$temp_file" "$project_name" "$current_date"; then
455:             if mv "$temp_file" "$target_file"; then
456:                 log_success "Created new $agent_name context file"
457:             else
458:                 log_error "Failed to move temporary file to $target_file"
459:                 rm -f "$temp_file"
460:                 return 1
461:             fi
462:         else
463:             log_error "Failed to create new agent file"
464:             rm -f "$temp_file"
465:             return 1
466:         fi
467:     else
468:         # Update existing file
469:         if [[ ! -r "$target_file" ]]; then
470:             log_error "Cannot read existing file: $target_file"
471:             return 1
472:         fi
473:         if [[ ! -w "$target_file" ]]; then
474:             log_error "Cannot write to existing file: $target_file"
475:             return 1
476:         fi
477:         if update_existing_agent_file "$target_file" "$current_date"; then
478:             log_success "Updated existing $agent_name context file"
479:         else
480:             log_error "Failed to update existing agent file"
481:             return 1
482:         fi
483:     fi
484:     return 0
485: }
486: #==============================================================================
487: # Agent Selection and Processing
488: #==============================================================================
489: update_specific_agent() {
490:     local agent_type="$1"
491:     case "$agent_type" in
492:         claude)
493:             update_agent_file "$CLAUDE_FILE" "Claude Code"
494:             ;;
495:         gemini)
496:             update_agent_file "$GEMINI_FILE" "Gemini CLI"
497:             ;;
498:         copilot)
499:             update_agent_file "$COPILOT_FILE" "GitHub Copilot"
500:             ;;
501:         cursor-agent)
502:             update_agent_file "$CURSOR_FILE" "Cursor IDE"
503:             ;;
504:         qwen)
505:             update_agent_file "$QWEN_FILE" "Qwen Code"
506:             ;;
507:         opencode)
508:             update_agent_file "$AGENTS_FILE" "opencode"
509:             ;;
510:         codex)
511:             update_agent_file "$AGENTS_FILE" "Codex CLI"
512:             ;;
513:         windsurf)
514:             update_agent_file "$WINDSURF_FILE" "Windsurf"
515:             ;;
516:         kilocode)
517:             update_agent_file "$KILOCODE_FILE" "Kilo Code"
518:             ;;
519:         auggie)
520:             update_agent_file "$AUGGIE_FILE" "Auggie CLI"
521:             ;;
522:         roo)
523:             update_agent_file "$ROO_FILE" "Roo Code"
524:             ;;
525:         codebuddy)
526:             update_agent_file "$CODEBUDDY_FILE" "CodeBuddy CLI"
527:             ;;
528:         qoder)
529:             update_agent_file "$QODER_FILE" "Qoder CLI"
530:             ;;
531:         amp)
532:             update_agent_file "$AMP_FILE" "Amp"
533:             ;;
534:         shai)
535:             update_agent_file "$SHAI_FILE" "SHAI"
536:             ;;
537:         q)
538:             update_agent_file "$Q_FILE" "Amazon Q Developer CLI"
539:             ;;
540:         bob)
541:             update_agent_file "$BOB_FILE" "IBM Bob"
542:             ;;
543:         *)
544:             log_error "Unknown agent type '$agent_type'"
545:             log_error "Expected: claude|gemini|copilot|cursor-agent|qwen|opencode|codex|windsurf|kilocode|auggie|roo|amp|shai|q|bob|qoder"
546:             exit 1
547:             ;;
548:     esac
549: }
550: update_all_existing_agents() {
551:     local found_agent=false
552:     # Check each possible agent file and update if it exists
553:     if [[ -f "$CLAUDE_FILE" ]]; then
554:         update_agent_file "$CLAUDE_FILE" "Claude Code"
555:         found_agent=true
556:     fi
557:     if [[ -f "$GEMINI_FILE" ]]; then
558:         update_agent_file "$GEMINI_FILE" "Gemini CLI"
559:         found_agent=true
560:     fi
561:     if [[ -f "$COPILOT_FILE" ]]; then
562:         update_agent_file "$COPILOT_FILE" "GitHub Copilot"
563:         found_agent=true
564:     fi
565:     if [[ -f "$CURSOR_FILE" ]]; then
566:         update_agent_file "$CURSOR_FILE" "Cursor IDE"
567:         found_agent=true
568:     fi
569:     if [[ -f "$QWEN_FILE" ]]; then
570:         update_agent_file "$QWEN_FILE" "Qwen Code"
571:         found_agent=true
572:     fi
573:     if [[ -f "$AGENTS_FILE" ]]; then
574:         update_agent_file "$AGENTS_FILE" "Codex/opencode"
575:         found_agent=true
576:     fi
577:     if [[ -f "$WINDSURF_FILE" ]]; then
578:         update_agent_file "$WINDSURF_FILE" "Windsurf"
579:         found_agent=true
580:     fi
581:     if [[ -f "$KILOCODE_FILE" ]]; then
582:         update_agent_file "$KILOCODE_FILE" "Kilo Code"
583:         found_agent=true
584:     fi
585:     if [[ -f "$AUGGIE_FILE" ]]; then
586:         update_agent_file "$AUGGIE_FILE" "Auggie CLI"
587:         found_agent=true
588:     fi
589:     if [[ -f "$ROO_FILE" ]]; then
590:         update_agent_file "$ROO_FILE" "Roo Code"
591:         found_agent=true
592:     fi
593:     if [[ -f "$CODEBUDDY_FILE" ]]; then
594:         update_agent_file "$CODEBUDDY_FILE" "CodeBuddy CLI"
595:         found_agent=true
596:     fi
597:     if [[ -f "$SHAI_FILE" ]]; then
598:         update_agent_file "$SHAI_FILE" "SHAI"
599:         found_agent=true
600:     fi
601:     if [[ -f "$QODER_FILE" ]]; then
602:         update_agent_file "$QODER_FILE" "Qoder CLI"
603:         found_agent=true
604:     fi
605:     if [[ -f "$Q_FILE" ]]; then
606:         update_agent_file "$Q_FILE" "Amazon Q Developer CLI"
607:         found_agent=true
608:     fi
609:     if [[ -f "$BOB_FILE" ]]; then
610:         update_agent_file "$BOB_FILE" "IBM Bob"
611:         found_agent=true
612:     fi
613:     # If no agent files exist, create a default Claude file
614:     if [[ "$found_agent" == false ]]; then
615:         log_info "No existing agent files found, creating default Claude file..."
616:         update_agent_file "$CLAUDE_FILE" "Claude Code"
617:     fi
618: }
619: print_summary() {
620:     echo
621:     log_info "Summary of changes:"
622:     if [[ -n "$NEW_LANG" ]]; then
623:         echo "  - Added language: $NEW_LANG"
624:     fi
625:     if [[ -n "$NEW_FRAMEWORK" ]]; then
626:         echo "  - Added framework: $NEW_FRAMEWORK"
627:     fi
628:     if [[ -n "$NEW_DB" ]] && [[ "$NEW_DB" != "N/A" ]]; then
629:         echo "  - Added database: $NEW_DB"
630:     fi
631:     echo
632:     log_info "Usage: $0 [claude|gemini|copilot|cursor-agent|qwen|opencode|codex|windsurf|kilocode|auggie|codebuddy|shai|q|bob|qoder]"
633: }
634: #==============================================================================
635: # Main Execution
636: #==============================================================================
637: main() {
638:     # Validate environment before proceeding
639:     validate_environment
640:     log_info "=== Updating agent context files for feature $CURRENT_BRANCH ==="
641:     # Parse the plan file to extract project information
642:     if ! parse_plan_data "$NEW_PLAN"; then
643:         log_error "Failed to parse plan data"
644:         exit 1
645:     fi
646:     # Process based on agent type argument
647:     local success=true
648:     if [[ -z "$AGENT_TYPE" ]]; then
649:         # No specific agent provided - update all existing agent files
650:         log_info "No agent specified, updating all existing agent files..."
651:         if ! update_all_existing_agents; then
652:             success=false
653:         fi
654:     else
655:         # Specific agent provided - update only that agent
656:         log_info "Updating specific agent: $AGENT_TYPE"
657:         if ! update_specific_agent "$AGENT_TYPE"; then
658:             success=false
659:         fi
660:     fi
661:     # Print summary
662:     print_summary
663:     if [[ "$success" == true ]]; then
664:         log_success "Agent context update completed successfully"
665:         exit 0
666:     else
667:         log_error "Agent context update completed with errors"
668:         exit 1
669:     fi
670: }
671: # Execute main function if script is run directly
672: if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
673:     main "$@"
674: fi
</file>

<file path=".specify/templates/agent-file-template.md">
 1: # [PROJECT NAME] Development Guidelines
 2: 
 3: Auto-generated from all feature plans. Last updated: [DATE]
 4: 
 5: ## Active Technologies
 6: 
 7: [EXTRACTED FROM ALL PLAN.MD FILES]
 8: 
 9: ## Project Structure
10: 
11: ```text
12: [ACTUAL STRUCTURE FROM PLANS]
13: ```
14: 
15: ## Commands
16: 
17: [ONLY COMMANDS FOR ACTIVE TECHNOLOGIES]
18: 
19: ## Code Style
20: 
21: [LANGUAGE-SPECIFIC, ONLY FOR LANGUAGES IN USE]
22: 
23: ## Recent Changes
24: 
25: [LAST 3 FEATURES AND WHAT THEY ADDED]
26: 
27: <!-- MANUAL ADDITIONS START -->
28: <!-- MANUAL ADDITIONS END -->
</file>

<file path=".specify/templates/checklist-template.md">
 1: # [CHECKLIST TYPE] Checklist: [FEATURE NAME]
 2: 
 3: **Purpose**: [Brief description of what this checklist covers]
 4: **Created**: [DATE]
 5: **Feature**: [Link to spec.md or relevant documentation]
 6: 
 7: **Note**: This checklist is generated by the `/speckit.checklist` command based on feature context and requirements.
 8: 
 9: <!-- 
10:   ============================================================================
11:   IMPORTANT: The checklist items below are SAMPLE ITEMS for illustration only.
12:   
13:   The /speckit.checklist command MUST replace these with actual items based on:
14:   - User's specific checklist request
15:   - Feature requirements from spec.md
16:   - Technical context from plan.md
17:   - Implementation details from tasks.md
18:   
19:   DO NOT keep these sample items in the generated checklist file.
20:   ============================================================================
21: -->
22: 
23: ## [Category 1]
24: 
25: - [ ] CHK001 First checklist item with clear action
26: - [ ] CHK002 Second checklist item
27: - [ ] CHK003 Third checklist item
28: 
29: ## [Category 2]
30: 
31: - [ ] CHK004 Another category item
32: - [ ] CHK005 Item with specific criteria
33: - [ ] CHK006 Final item in this category
34: 
35: ## Notes
36: 
37: - Check items off as completed: `[x]`
38: - Add comments or findings inline
39: - Link to relevant resources or documentation
40: - Items are numbered sequentially for easy reference
</file>

<file path=".specify/templates/plan-template.md">
  1: # Implementation Plan: [FEATURE]
  2: 
  3: **Branch**: `[###-feature-name]` | **Date**: [DATE] | **Spec**: [link]
  4: **Input**: Feature specification from `/specs/[###-feature-name]/spec.md`
  5: 
  6: **Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.
  7: 
  8: ## Summary
  9: 
 10: [Extract from feature spec: primary requirement + technical approach from research]
 11: 
 12: ## Technical Context
 13: 
 14: <!--
 15:   ACTION REQUIRED: Replace the content in this section with the technical details
 16:   for the project. The structure here is presented in advisory capacity to guide
 17:   the iteration process.
 18: -->
 19: 
 20: **Language/Version**: [e.g., Python 3.11, Swift 5.9, Rust 1.75 or NEEDS CLARIFICATION]  
 21: **Primary Dependencies**: [e.g., FastAPI, UIKit, LLVM or NEEDS CLARIFICATION]  
 22: **Storage**: [if applicable, e.g., PostgreSQL, CoreData, files or N/A]  
 23: **Testing**: [e.g., pytest, XCTest, cargo test or NEEDS CLARIFICATION]  
 24: **Target Platform**: [e.g., Linux server, iOS 15+, WASM or NEEDS CLARIFICATION]
 25: **Project Type**: [single/web/mobile - determines source structure]  
 26: **Performance Goals**: [domain-specific, e.g., 1000 req/s, 10k lines/sec, 60 fps or NEEDS CLARIFICATION]  
 27: **Constraints**: [domain-specific, e.g., <200ms p95, <100MB memory, offline-capable or NEEDS CLARIFICATION]  
 28: **Scale/Scope**: [domain-specific, e.g., 10k users, 1M LOC, 50 screens or NEEDS CLARIFICATION]
 29: 
 30: ## Constitution Check
 31: 
 32: *GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*
 33: 
 34: [Gates determined based on constitution file]
 35: 
 36: ## Project Structure
 37: 
 38: ### Documentation (this feature)
 39: 
 40: ```text
 41: specs/[###-feature]/
 42: ‚îú‚îÄ‚îÄ plan.md              # This file (/speckit.plan command output)
 43: ‚îú‚îÄ‚îÄ research.md          # Phase 0 output (/speckit.plan command)
 44: ‚îú‚îÄ‚îÄ data-model.md        # Phase 1 output (/speckit.plan command)
 45: ‚îú‚îÄ‚îÄ quickstart.md        # Phase 1 output (/speckit.plan command)
 46: ‚îú‚îÄ‚îÄ contracts/           # Phase 1 output (/speckit.plan command)
 47: ‚îî‚îÄ‚îÄ tasks.md             # Phase 2 output (/speckit.tasks command - NOT created by /speckit.plan)
 48: ```
 49: 
 50: ### Source Code (repository root)
 51: <!--
 52:   ACTION REQUIRED: Replace the placeholder tree below with the concrete layout
 53:   for this feature. Delete unused options and expand the chosen structure with
 54:   real paths (e.g., apps/admin, packages/something). The delivered plan must
 55:   not include Option labels.
 56: -->
 57: 
 58: ```text
 59: # [REMOVE IF UNUSED] Option 1: Single project (DEFAULT)
 60: src/
 61: ‚îú‚îÄ‚îÄ models/
 62: ‚îú‚îÄ‚îÄ services/
 63: ‚îú‚îÄ‚îÄ cli/
 64: ‚îî‚îÄ‚îÄ lib/
 65: 
 66: tests/
 67: ‚îú‚îÄ‚îÄ contract/
 68: ‚îú‚îÄ‚îÄ integration/
 69: ‚îî‚îÄ‚îÄ unit/
 70: 
 71: # [REMOVE IF UNUSED] Option 2: Web application (when "frontend" + "backend" detected)
 72: backend/
 73: ‚îú‚îÄ‚îÄ src/
 74: ‚îÇ   ‚îú‚îÄ‚îÄ models/
 75: ‚îÇ   ‚îú‚îÄ‚îÄ services/
 76: ‚îÇ   ‚îî‚îÄ‚îÄ api/
 77: ‚îî‚îÄ‚îÄ tests/
 78: 
 79: frontend/
 80: ‚îú‚îÄ‚îÄ src/
 81: ‚îÇ   ‚îú‚îÄ‚îÄ components/
 82: ‚îÇ   ‚îú‚îÄ‚îÄ pages/
 83: ‚îÇ   ‚îî‚îÄ‚îÄ services/
 84: ‚îî‚îÄ‚îÄ tests/
 85: 
 86: # [REMOVE IF UNUSED] Option 3: Mobile + API (when "iOS/Android" detected)
 87: api/
 88: ‚îî‚îÄ‚îÄ [same as backend above]
 89: 
 90: ios/ or android/
 91: ‚îî‚îÄ‚îÄ [platform-specific structure: feature modules, UI flows, platform tests]
 92: ```
 93: 
 94: **Structure Decision**: [Document the selected structure and reference the real
 95: directories captured above]
 96: 
 97: ## Complexity Tracking
 98: 
 99: > **Fill ONLY if Constitution Check has violations that must be justified**
100: 
101: | Violation | Why Needed | Simpler Alternative Rejected Because |
102: |-----------|------------|-------------------------------------|
103: | [e.g., 4th project] | [current need] | [why 3 projects insufficient] |
104: | [e.g., Repository pattern] | [specific problem] | [why direct DB access insufficient] |
</file>

<file path=".specify/templates/spec-template.md">
  1: # Feature Specification: [FEATURE NAME]
  2: 
  3: **Feature Branch**: `[###-feature-name]`  
  4: **Created**: [DATE]  
  5: **Status**: Draft  
  6: **Input**: User description: "$ARGUMENTS"
  7: 
  8: ## User Scenarios & Testing *(mandatory)*
  9: 
 10: <!--
 11:   IMPORTANT: User stories should be PRIORITIZED as user journeys ordered by importance.
 12:   Each user story/journey must be INDEPENDENTLY TESTABLE - meaning if you implement just ONE of them,
 13:   you should still have a viable MVP (Minimum Viable Product) that delivers value.
 14:   
 15:   Assign priorities (P1, P2, P3, etc.) to each story, where P1 is the most critical.
 16:   Think of each story as a standalone slice of functionality that can be:
 17:   - Developed independently
 18:   - Tested independently
 19:   - Deployed independently
 20:   - Demonstrated to users independently
 21: -->
 22: 
 23: ### User Story 1 - [Brief Title] (Priority: P1)
 24: 
 25: [Describe this user journey in plain language]
 26: 
 27: **Why this priority**: [Explain the value and why it has this priority level]
 28: 
 29: **Independent Test**: [Describe how this can be tested independently - e.g., "Can be fully tested by [specific action] and delivers [specific value]"]
 30: 
 31: **Acceptance Scenarios**:
 32: 
 33: 1. **Given** [initial state], **When** [action], **Then** [expected outcome]
 34: 2. **Given** [initial state], **When** [action], **Then** [expected outcome]
 35: 
 36: ---
 37: 
 38: ### User Story 2 - [Brief Title] (Priority: P2)
 39: 
 40: [Describe this user journey in plain language]
 41: 
 42: **Why this priority**: [Explain the value and why it has this priority level]
 43: 
 44: **Independent Test**: [Describe how this can be tested independently]
 45: 
 46: **Acceptance Scenarios**:
 47: 
 48: 1. **Given** [initial state], **When** [action], **Then** [expected outcome]
 49: 
 50: ---
 51: 
 52: ### User Story 3 - [Brief Title] (Priority: P3)
 53: 
 54: [Describe this user journey in plain language]
 55: 
 56: **Why this priority**: [Explain the value and why it has this priority level]
 57: 
 58: **Independent Test**: [Describe how this can be tested independently]
 59: 
 60: **Acceptance Scenarios**:
 61: 
 62: 1. **Given** [initial state], **When** [action], **Then** [expected outcome]
 63: 
 64: ---
 65: 
 66: [Add more user stories as needed, each with an assigned priority]
 67: 
 68: ### Edge Cases
 69: 
 70: <!--
 71:   ACTION REQUIRED: The content in this section represents placeholders.
 72:   Fill them out with the right edge cases.
 73: -->
 74: 
 75: - What happens when [boundary condition]?
 76: - How does system handle [error scenario]?
 77: 
 78: ## Requirements *(mandatory)*
 79: 
 80: <!--
 81:   ACTION REQUIRED: The content in this section represents placeholders.
 82:   Fill them out with the right functional requirements.
 83: -->
 84: 
 85: ### Functional Requirements
 86: 
 87: - **FR-001**: System MUST [specific capability, e.g., "allow users to create accounts"]
 88: - **FR-002**: System MUST [specific capability, e.g., "validate email addresses"]  
 89: - **FR-003**: Users MUST be able to [key interaction, e.g., "reset their password"]
 90: - **FR-004**: System MUST [data requirement, e.g., "persist user preferences"]
 91: - **FR-005**: System MUST [behavior, e.g., "log all security events"]
 92: 
 93: *Example of marking unclear requirements:*
 94: 
 95: - **FR-006**: System MUST authenticate users via [NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]
 96: - **FR-007**: System MUST retain user data for [NEEDS CLARIFICATION: retention period not specified]
 97: 
 98: ### Key Entities *(include if feature involves data)*
 99: 
100: - **[Entity 1]**: [What it represents, key attributes without implementation]
101: - **[Entity 2]**: [What it represents, relationships to other entities]
102: 
103: ## Success Criteria *(mandatory)*
104: 
105: <!--
106:   ACTION REQUIRED: Define measurable success criteria.
107:   These must be technology-agnostic and measurable.
108: -->
109: 
110: ### Measurable Outcomes
111: 
112: - **SC-001**: [Measurable metric, e.g., "Users can complete account creation in under 2 minutes"]
113: - **SC-002**: [Measurable metric, e.g., "System handles 1000 concurrent users without degradation"]
114: - **SC-003**: [User satisfaction metric, e.g., "90% of users successfully complete primary task on first attempt"]
115: - **SC-004**: [Business metric, e.g., "Reduce support tickets related to [X] by 50%"]
</file>

<file path=".specify/templates/tasks-template.md">
  1: ---
  2: 
  3: description: "Task list template for feature implementation"
  4: ---
  5: 
  6: # Tasks: [FEATURE NAME]
  7: 
  8: **Input**: Design documents from `/specs/[###-feature-name]/`
  9: **Prerequisites**: plan.md (required), spec.md (required for user stories), research.md, data-model.md, contracts/
 10: 
 11: **Tests**: The examples below include test tasks. Tests are OPTIONAL - only include them if explicitly requested in the feature specification.
 12: 
 13: **Organization**: Tasks are grouped by user story to enable independent implementation and testing of each story.
 14: 
 15: ## Format: `[ID] [P?] [Story] Description`
 16: 
 17: - **[P]**: Can run in parallel (different files, no dependencies)
 18: - **[Story]**: Which user story this task belongs to (e.g., US1, US2, US3)
 19: - Include exact file paths in descriptions
 20: 
 21: ## Path Conventions
 22: 
 23: - **Single project**: `src/`, `tests/` at repository root
 24: - **Web app**: `backend/src/`, `frontend/src/`
 25: - **Mobile**: `api/src/`, `ios/src/` or `android/src/`
 26: - Paths shown below assume single project - adjust based on plan.md structure
 27: 
 28: <!-- 
 29:   ============================================================================
 30:   IMPORTANT: The tasks below are SAMPLE TASKS for illustration purposes only.
 31:   
 32:   The /speckit.tasks command MUST replace these with actual tasks based on:
 33:   - User stories from spec.md (with their priorities P1, P2, P3...)
 34:   - Feature requirements from plan.md
 35:   - Entities from data-model.md
 36:   - Endpoints from contracts/
 37:   
 38:   Tasks MUST be organized by user story so each story can be:
 39:   - Implemented independently
 40:   - Tested independently
 41:   - Delivered as an MVP increment
 42:   
 43:   DO NOT keep these sample tasks in the generated tasks.md file.
 44:   ============================================================================
 45: -->
 46: 
 47: ## Phase 1: Setup (Shared Infrastructure)
 48: 
 49: **Purpose**: Project initialization and basic structure
 50: 
 51: - [ ] T001 Create project structure per implementation plan
 52: - [ ] T002 Initialize [language] project with [framework] dependencies
 53: - [ ] T003 [P] Configure linting and formatting tools
 54: 
 55: ---
 56: 
 57: ## Phase 2: Foundational (Blocking Prerequisites)
 58: 
 59: **Purpose**: Core infrastructure that MUST be complete before ANY user story can be implemented
 60: 
 61: **‚ö†Ô∏è CRITICAL**: No user story work can begin until this phase is complete
 62: 
 63: Examples of foundational tasks (adjust based on your project):
 64: 
 65: - [ ] T004 Setup database schema and migrations framework
 66: - [ ] T005 [P] Implement authentication/authorization framework
 67: - [ ] T006 [P] Setup API routing and middleware structure
 68: - [ ] T007 Create base models/entities that all stories depend on
 69: - [ ] T008 Configure error handling and logging infrastructure
 70: - [ ] T009 Setup environment configuration management
 71: 
 72: **Checkpoint**: Foundation ready - user story implementation can now begin in parallel
 73: 
 74: ---
 75: 
 76: ## Phase 3: User Story 1 - [Title] (Priority: P1) üéØ MVP
 77: 
 78: **Goal**: [Brief description of what this story delivers]
 79: 
 80: **Independent Test**: [How to verify this story works on its own]
 81: 
 82: ### Tests for User Story 1 (OPTIONAL - only if tests requested) ‚ö†Ô∏è
 83: 
 84: > **NOTE: Write these tests FIRST, ensure they FAIL before implementation**
 85: 
 86: - [ ] T010 [P] [US1] Contract test for [endpoint] in tests/contract/test_[name].py
 87: - [ ] T011 [P] [US1] Integration test for [user journey] in tests/integration/test_[name].py
 88: 
 89: ### Implementation for User Story 1
 90: 
 91: - [ ] T012 [P] [US1] Create [Entity1] model in src/models/[entity1].py
 92: - [ ] T013 [P] [US1] Create [Entity2] model in src/models/[entity2].py
 93: - [ ] T014 [US1] Implement [Service] in src/services/[service].py (depends on T012, T013)
 94: - [ ] T015 [US1] Implement [endpoint/feature] in src/[location]/[file].py
 95: - [ ] T016 [US1] Add validation and error handling
 96: - [ ] T017 [US1] Add logging for user story 1 operations
 97: 
 98: **Checkpoint**: At this point, User Story 1 should be fully functional and testable independently
 99: 
100: ---
101: 
102: ## Phase 4: User Story 2 - [Title] (Priority: P2)
103: 
104: **Goal**: [Brief description of what this story delivers]
105: 
106: **Independent Test**: [How to verify this story works on its own]
107: 
108: ### Tests for User Story 2 (OPTIONAL - only if tests requested) ‚ö†Ô∏è
109: 
110: - [ ] T018 [P] [US2] Contract test for [endpoint] in tests/contract/test_[name].py
111: - [ ] T019 [P] [US2] Integration test for [user journey] in tests/integration/test_[name].py
112: 
113: ### Implementation for User Story 2
114: 
115: - [ ] T020 [P] [US2] Create [Entity] model in src/models/[entity].py
116: - [ ] T021 [US2] Implement [Service] in src/services/[service].py
117: - [ ] T022 [US2] Implement [endpoint/feature] in src/[location]/[file].py
118: - [ ] T023 [US2] Integrate with User Story 1 components (if needed)
119: 
120: **Checkpoint**: At this point, User Stories 1 AND 2 should both work independently
121: 
122: ---
123: 
124: ## Phase 5: User Story 3 - [Title] (Priority: P3)
125: 
126: **Goal**: [Brief description of what this story delivers]
127: 
128: **Independent Test**: [How to verify this story works on its own]
129: 
130: ### Tests for User Story 3 (OPTIONAL - only if tests requested) ‚ö†Ô∏è
131: 
132: - [ ] T024 [P] [US3] Contract test for [endpoint] in tests/contract/test_[name].py
133: - [ ] T025 [P] [US3] Integration test for [user journey] in tests/integration/test_[name].py
134: 
135: ### Implementation for User Story 3
136: 
137: - [ ] T026 [P] [US3] Create [Entity] model in src/models/[entity].py
138: - [ ] T027 [US3] Implement [Service] in src/services/[service].py
139: - [ ] T028 [US3] Implement [endpoint/feature] in src/[location]/[file].py
140: 
141: **Checkpoint**: All user stories should now be independently functional
142: 
143: ---
144: 
145: [Add more user story phases as needed, following the same pattern]
146: 
147: ---
148: 
149: ## Phase N: Polish & Cross-Cutting Concerns
150: 
151: **Purpose**: Improvements that affect multiple user stories
152: 
153: - [ ] TXXX [P] Documentation updates in docs/
154: - [ ] TXXX Code cleanup and refactoring
155: - [ ] TXXX Performance optimization across all stories
156: - [ ] TXXX [P] Additional unit tests (if requested) in tests/unit/
157: - [ ] TXXX Security hardening
158: - [ ] TXXX Run quickstart.md validation
159: 
160: ---
161: 
162: ## Dependencies & Execution Order
163: 
164: ### Phase Dependencies
165: 
166: - **Setup (Phase 1)**: No dependencies - can start immediately
167: - **Foundational (Phase 2)**: Depends on Setup completion - BLOCKS all user stories
168: - **User Stories (Phase 3+)**: All depend on Foundational phase completion
169:   - User stories can then proceed in parallel (if staffed)
170:   - Or sequentially in priority order (P1 ‚Üí P2 ‚Üí P3)
171: - **Polish (Final Phase)**: Depends on all desired user stories being complete
172: 
173: ### User Story Dependencies
174: 
175: - **User Story 1 (P1)**: Can start after Foundational (Phase 2) - No dependencies on other stories
176: - **User Story 2 (P2)**: Can start after Foundational (Phase 2) - May integrate with US1 but should be independently testable
177: - **User Story 3 (P3)**: Can start after Foundational (Phase 2) - May integrate with US1/US2 but should be independently testable
178: 
179: ### Within Each User Story
180: 
181: - Tests (if included) MUST be written and FAIL before implementation
182: - Models before services
183: - Services before endpoints
184: - Core implementation before integration
185: - Story complete before moving to next priority
186: 
187: ### Parallel Opportunities
188: 
189: - All Setup tasks marked [P] can run in parallel
190: - All Foundational tasks marked [P] can run in parallel (within Phase 2)
191: - Once Foundational phase completes, all user stories can start in parallel (if team capacity allows)
192: - All tests for a user story marked [P] can run in parallel
193: - Models within a story marked [P] can run in parallel
194: - Different user stories can be worked on in parallel by different team members
195: 
196: ---
197: 
198: ## Parallel Example: User Story 1
199: 
200: ```bash
201: # Launch all tests for User Story 1 together (if tests requested):
202: Task: "Contract test for [endpoint] in tests/contract/test_[name].py"
203: Task: "Integration test for [user journey] in tests/integration/test_[name].py"
204: 
205: # Launch all models for User Story 1 together:
206: Task: "Create [Entity1] model in src/models/[entity1].py"
207: Task: "Create [Entity2] model in src/models/[entity2].py"
208: ```
209: 
210: ---
211: 
212: ## Implementation Strategy
213: 
214: ### MVP First (User Story 1 Only)
215: 
216: 1. Complete Phase 1: Setup
217: 2. Complete Phase 2: Foundational (CRITICAL - blocks all stories)
218: 3. Complete Phase 3: User Story 1
219: 4. **STOP and VALIDATE**: Test User Story 1 independently
220: 5. Deploy/demo if ready
221: 
222: ### Incremental Delivery
223: 
224: 1. Complete Setup + Foundational ‚Üí Foundation ready
225: 2. Add User Story 1 ‚Üí Test independently ‚Üí Deploy/Demo (MVP!)
226: 3. Add User Story 2 ‚Üí Test independently ‚Üí Deploy/Demo
227: 4. Add User Story 3 ‚Üí Test independently ‚Üí Deploy/Demo
228: 5. Each story adds value without breaking previous stories
229: 
230: ### Parallel Team Strategy
231: 
232: With multiple developers:
233: 
234: 1. Team completes Setup + Foundational together
235: 2. Once Foundational is done:
236:    - Developer A: User Story 1
237:    - Developer B: User Story 2
238:    - Developer C: User Story 3
239: 3. Stories complete and integrate independently
240: 
241: ---
242: 
243: ## Notes
244: 
245: - [P] tasks = different files, no dependencies
246: - [Story] label maps task to specific user story for traceability
247: - Each user story should be independently completable and testable
248: - Verify tests fail before implementing
249: - Commit after each task or logical group
250: - Stop at any checkpoint to validate story independently
251: - Avoid: vague tasks, same file conflicts, cross-story dependencies that break independence
</file>

<file path="src/App.css">
 1: .app {
 2:   width: min(900px, 96vw);
 3:   aspect-ratio: 3 / 4;
 4:   background: rgba(248, 250, 252, 0.85);
 5:   border-radius: 24px;
 6:   box-shadow: 0 30px 80px rgba(15, 23, 42, 0.25);
 7:   overflow: hidden;
 8:   display: grid;
 9:   grid-template-rows: auto 1fr;
10:   border: 1px solid rgba(148, 163, 184, 0.4);
11: }
12: .app-header {
13:   padding: 18px 22px;
14:   display: flex;
15:   align-items: center;
16:   justify-content: space-between;
17:   background: linear-gradient(120deg, #0f172a, #1e293b);
18:   color: #f8fafc;
19:   letter-spacing: 0.02em;
20: }
21: .app-header h1 {
22:   font-size: 20px;
23:   margin: 0;
24: }
25: .app-header span {
26:   font-size: 13px;
27:   color: #cbd5f5;
28: }
29: .canvas-wrap {
30:   position: relative;
31:   display: flex;
32:   align-items: center;
33:   justify-content: center;
34:   background: linear-gradient(180deg, #e2e8f0 0%, #cbd5f5 50%, #94a3b8 100%);
35:   cursor: pointer;
36: }
37: .canvas-wrap canvas {
38:   border-radius: 18px;
39:   background: transparent;
40: }
</file>

<file path="src/App.tsx">
 1: import './App.css';
 2: function App() {
 3:   return (
 4:     <div style={{
 5:       display: 'flex',
 6:       justifyContent: 'center',
 7:       alignItems: 'center',
 8:       height: '100vh',
 9:       fontSize: '4rem',
10:       fontFamily: 'sans-serif',
11:       background: '#f0f0f0',
12:       color: '#333'
13:     }}>
14:       Hello World
15:     </div>
16:   );
17: }
18: export default App;
</file>

<file path="src/index.css">
 1: @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&display=swap');
 2: :root {
 3:   font-family: 'Space Grotesk', system-ui, sans-serif;
 4:   color: #0f172a;
 5:   background-color: #e2e8f0;
 6: }
 7: * {
 8:   box-sizing: border-box;
 9: }
10: body {
11:   margin: 0;
12:   min-height: 100vh;
13:   background: radial-gradient(circle at 20% 20%, #f8fafc, #cbd5f5 50%, #94a3b8 100%);
14: }
15: #root {
16:   min-height: 100vh;
17:   display: flex;
18:   align-items: center;
19:   justify-content: center;
20: }
</file>

<file path="src/main.tsx">
1: import React from 'react';
2: import ReactDOM from 'react-dom/client';
3: import App from './App';
4: import './index.css';
5: ReactDOM.createRoot(document.getElementById('root')!).render(
6:   <React.StrictMode>
7:     <App />
8:   </React.StrictMode>
9: );
</file>

<file path="src/vite-env.d.ts">
1: /// <reference types="vite/client" />
2: declare global {
3:   interface Window {
4:     advanceTime: (ms: number) => void;
5:     render_game_to_text: () => string;
6:   }
7: }
8: export {};
</file>

<file path="index.html">
 1: <!doctype html>
 2: <html lang="en">
 3:   <head>
 4:     <meta charset="UTF-8" />
 5:     <link rel="icon" type="image/svg+xml" href="/vite.svg" />
 6:     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 7:     <title>Stack Builder</title>
 8:   </head>
 9:   <body>
10:     <div id="root"></div>
11:     <script type="module" src="/src/main.tsx"></script>
12:   </body>
13: </html>
</file>

<file path="package.json">
 1: {
 2:   "name": "stack-builder",
 3:   "private": true,
 4:   "version": "0.0.0",
 5:   "type": "module",
 6:   "scripts": {
 7:     "dev": "vite",
 8:     "build": "tsc -b && vite build",
 9:     "preview": "vite preview"
10:   },
11:   "dependencies": {
12:     "pixi.js": "^8.3.1",
13:     "react": "^18.2.0",
14:     "react-dom": "^18.2.0"
15:   },
16:   "devDependencies": {
17:     "@types/react": "^18.2.48",
18:     "@types/react-dom": "^18.2.18",
19:     "@vitejs/plugin-react": "^4.2.1",
20:     "playwright": "^1.58.2",
21:     "typescript": "^5.3.3",
22:     "vite": "^5.0.12"
23:   }
24: }
</file>

<file path="progress.md">
1: Original prompt: ‡πÉ‡∏ä‡πâ Vite React Vite + PixiJS TS ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏Å‡∏°‡∏™‡πå Stack Builder: ‡∏ß‡∏≤‡∏á‡∏ö‡∏•‡πá‡∏≠‡∏Å‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ï‡∏∂‡∏Å‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î ‡∏Ç‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏õ‡πá‡∏ô step
2: 
3: - Started manual Vite + React + TS scaffold since npm create timed out.
4: - Added manual Vite + React + TS scaffold files (package.json, tsconfigs, vite config, index.html).
5: - Built PixiJS Stack Builder prototype with start screen, stacking logic, and basic UI.
6: - Exposed window.render_game_to_text and window.advanceTime hooks for automated tests.
7: - npm install timed out (120s), so dependencies not installed and Playwright tests not run yet.
8: - Updated PixiJS init flow to v8 API (Application.init + app.canvas) to fix canvas undefined errors.
9: - Ensured Pixi app/ticker explicitly start; added click listener and pointer prevention for reliable input.
</file>

<file path="repomix-instruction.md">
 1: # Project Context
 2: ‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ `/Volumes/DEVCH001/Github/games_web` ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡πá‡∏ö‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏° (Web-based Game) ‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏™‡∏°‡∏±‡∏¢‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏ú‡πà‡∏≤‡∏ô WebGL ‡πÇ‡∏î‡∏¢‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏õ‡πá‡∏ô React 18 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ UI ‡πÅ‡∏•‡∏∞ PixiJS (v8) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Game Engine ‡πÅ‡∏•‡∏∞ Rendering ‡∏†‡∏≤‡∏¢‡πÉ‡∏ï‡πâ‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏Ç‡∏≠‡∏á Vite ‡πÅ‡∏•‡∏∞ TypeScript
 3: 
 4: # AI Persona & Role
 5: ‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ Senior Game Frontend Architect ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏ß‡πà‡∏≤ 50 ‡∏õ‡∏µ ‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡∏î‡πâ‡∏≤‡∏ô Graphics Performance, WebGL Optimization ‡πÅ‡∏•‡∏∞ React Design Patterns ‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡πâ‡∏î (Stability), ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢ (Clarity) ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏±‡∏Å‡∏©‡∏≤‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏¢‡∏≤‡∏ß (Maintainability) ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î‡πÅ‡∏ö‡∏ö "Minimal Diff" ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏ó‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÇ‡∏î‡∏¢‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
 6: 
 7: # General Instructions
 8: 1. **Language:** ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (Thailand) ‡πÅ‡∏ï‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡∏á‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (English) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£
 9: 2. **Analysis:** ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏Ñ‡πâ‡∏î ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö (Impact Analysis) ‡∏ï‡πà‡∏≠‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Component ‡∏Ç‡∏≠‡∏á React ‡πÅ‡∏•‡∏∞‡∏ß‡∏á‡∏à‡∏£‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (Lifecycle/Ticker) ‡∏Ç‡∏≠‡∏á PixiJS ‡πÄ‡∏™‡∏°‡∏≠
10: 3. **Code Style:**
11:    - ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å DRY (Don't Repeat Yourself) ‡πÅ‡∏•‡∏∞ SOLID ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏î
12:    - **React & PixiJS:** ‡πÉ‡∏ä‡πâ Hooks ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ State ‡πÅ‡∏•‡∏∞ Lifecycle (‡πÄ‡∏ä‡πà‡∏ô `useEffect`, `useMemo`) ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Object ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô Game Loop (Ticker) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏†‡∏≤‡∏£‡∏∞‡∏Ç‡∏≠‡∏á Garbage Collector
13:    - ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏ä‡∏¥‡∏á‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (Descriptive names)
14:    - ‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ Type Definitions ‡∏´‡∏£‡∏∑‡∏≠ Annotations ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏ï‡∏≤‡∏°‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô TypeScript
15: 
16: # Security & Performance Guidelines
17: 1. **No Hardcoded Secrets:** ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏™‡πà Password, API Key ‡∏´‡∏£‡∏∑‡∏≠ Credential ‡πÉ‡∏î‡πÜ ‡∏•‡∏á‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Environment Variables ‡πÄ‡∏™‡∏°‡∏≠
18: 2. **Error Handling:** ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Error ‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° (Graceful Degradation) ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î Assets ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£ Render
19: 3. **Graphics Performance:** ‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á "React Rerenders" ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ã‡∏∂‡πà‡∏á‡∏≠‡∏≤‡∏à‡∏Ç‡∏±‡∏î‡∏Ç‡∏ß‡∏≤‡∏á Game Loop ‡πÅ‡∏•‡∏∞‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Texture Bundling / Object Pooling ‡πÉ‡∏ô PixiJS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤ Frame Rate ‡πÉ‡∏´‡πâ‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
20: 4. **Stability & Maintainability:** ‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡∏ó‡∏ô‡∏ó‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (Robustness) ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ "Magic Numbers" ‡∏´‡∏£‡∏∑‡∏≠ Logic ‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
21: 
22: # Output Format
23: - ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡πÉ‡∏´‡πâ Refactor ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡πà‡∏ß‡∏ô "Before" ‡πÅ‡∏•‡∏∞ "After" ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏∞‡∏ö‡∏∏‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô (‡πÄ‡∏ä‡πà‡∏ô [MODIFY], [NEW])
24: - ‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∞‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ "‡∏ó‡∏≥‡πÑ‡∏° (Why)" ‡∏ñ‡∏∂‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ô‡∏±‡πâ‡∏ô‡πÜ ‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡∏ï‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Senior Architect
25: - ‡∏™‡∏£‡∏∏‡∏õ‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡∏ô‡∏≠‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Commit (Commit Message) ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢
</file>

<file path="repomix.config.json">
 1: {
 2:     "output": {
 3:         "style": "xml",
 4:         "filePath": "repomix-output.xml",
 5:         "showLineNumbers": true,
 6:         "removeEmptyLines": true,
 7:         "topFilesLength": 10,
 8:         "instructionFilePath": "repomix-instruction.md"
 9:     },
10:     "ignore": {
11:         "useGitignore": true,
12:         "useDefaultPatterns": true,
13:         "customPatterns": [
14:             "**/*.lock",
15:             "**/dist/**",
16:             "**/build/**",
17:             "**/coverage/**",
18:             "**/*.log",
19:             "**/*.svg",
20:             "**/assets/**",
21:             "**/*.test.ts",
22:             "**/public/**"
23:         ]
24:     },
25:     "security": {
26:         "enableSecurityCheck": true
27:     }
28: }
</file>

<file path="tsconfig.app.json">
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2020",
 4:     "useDefineForClassFields": true,
 5:     "lib": ["ES2020", "DOM", "DOM.Iterable"],
 6:     "module": "ESNext",
 7:     "skipLibCheck": true,
 8:     "moduleResolution": "Bundler",
 9:     "allowImportingTsExtensions": true,
10:     "resolveJsonModule": true,
11:     "isolatedModules": true,
12:     "noEmit": true,
13:     "jsx": "react-jsx",
14:     "strict": true,
15:     "noUnusedLocals": true,
16:     "noUnusedParameters": true,
17:     "noFallthroughCasesInSwitch": true
18:   },
19:   "include": ["src"]
20: }
</file>

<file path="tsconfig.json">
1: {
2:   "files": [],
3:   "references": [{ "path": "./tsconfig.app.json" }, { "path": "./tsconfig.node.json" }]
4: }
</file>

<file path="tsconfig.node.json">
 1: {
 2:   "compilerOptions": {
 3:     "composite": true,
 4:     "skipLibCheck": true,
 5:     "module": "ESNext",
 6:     "moduleResolution": "Bundler",
 7:     "allowSyntheticDefaultImports": true,
 8:     "strict": true
 9:   },
10:   "include": ["vite.config.ts"]
11: }
</file>

<file path="vite.config.ts">
1: import { defineConfig } from 'vite';
2: import react from '@vitejs/plugin-react';
3: export default defineConfig({
4:   plugins: [react()],
5: });
</file>

</files>



<instruction>
# Project Context
‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå‡∏ô‡∏µ‡πâ‡∏Ñ‡∏∑‡∏≠ `/Volumes/DEVCH001/Github/games_web` ‡∏ã‡∏∂‡πà‡∏á‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡πá‡∏ö‡πÅ‡∏≠‡∏õ‡∏û‡∏•‡∏¥‡πÄ‡∏Ñ‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡∏° (Web-based Game) ‡∏ó‡∏µ‡πà‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏î‡πâ‡∏ß‡∏¢‡πÄ‡∏ó‡∏Ñ‡πÇ‡∏ô‡πÇ‡∏•‡∏¢‡∏µ‡∏™‡∏°‡∏±‡∏¢‡πÉ‡∏´‡∏°‡πà ‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏ú‡πà‡∏≤‡∏ô WebGL ‡πÇ‡∏î‡∏¢‡∏°‡∏µ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏•‡∏±‡∏Å‡πÄ‡∏õ‡πá‡∏ô React 18 ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ UI ‡πÅ‡∏•‡∏∞ PixiJS (v8) ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Game Engine ‡πÅ‡∏•‡∏∞ Rendering ‡∏†‡∏≤‡∏¢‡πÉ‡∏ï‡πâ‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏Ç‡∏≠‡∏á Vite ‡πÅ‡∏•‡∏∞ TypeScript

# AI Persona & Role
‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ Senior Game Frontend Architect ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏ß‡πà‡∏≤ 50 ‡∏õ‡∏µ ‡πÄ‡∏ä‡∏µ‡πà‡∏¢‡∏ß‡∏ä‡∏≤‡∏ç‡∏î‡πâ‡∏≤‡∏ô Graphics Performance, WebGL Optimization ‡πÅ‡∏•‡∏∞ React Design Patterns ‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏´‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡∏Ç‡∏≠‡∏á‡πÇ‡∏Ñ‡πâ‡∏î (Stability), ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏á‡πà‡∏≤‡∏¢ (Clarity) ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏î‡∏π‡πÅ‡∏•‡∏£‡∏±‡∏Å‡∏©‡∏≤‡πÉ‡∏ô‡∏£‡∏∞‡∏¢‡∏∞‡∏¢‡∏≤‡∏ß (Maintainability) ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î‡πÅ‡∏ö‡∏ö "Minimal Diff" ‡∏Ñ‡∏∑‡∏≠‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÄ‡∏ó‡πà‡∏≤‡∏ó‡∏µ‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏ï‡πà‡∏≠‡∏£‡∏∞‡∏ö‡∏ö‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏∑‡πà‡∏ô‡πÇ‡∏î‡∏¢‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô

# General Instructions
1. **Language:** ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢ (Thailand) ‡πÅ‡∏ï‡πà‡πÉ‡∏´‡πâ‡∏Ñ‡∏á‡∏Ñ‡∏≥‡∏®‡∏±‡∏û‡∏ó‡πå‡πÄ‡∏ó‡∏Ñ‡∏ô‡∏¥‡∏Ñ‡πÑ‡∏ß‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡∏≠‡∏±‡∏á‡∏Å‡∏§‡∏© (English) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏°‡πà‡∏ô‡∏¢‡∏≥‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏∑‡πà‡∏≠‡∏™‡∏≤‡∏£
2. **Analysis:** ‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÇ‡∏Ñ‡πâ‡∏î ‡πÉ‡∏´‡πâ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ú‡∏•‡∏Å‡∏£‡∏∞‡∏ó‡∏ö (Impact Analysis) ‡∏ï‡πà‡∏≠‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á Component ‡∏Ç‡∏≠‡∏á React ‡πÅ‡∏•‡∏∞‡∏ß‡∏á‡∏à‡∏£‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (Lifecycle/Ticker) ‡∏Ç‡∏≠‡∏á PixiJS ‡πÄ‡∏™‡∏°‡∏≠
3. **Code Style:**
   - ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ï‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å DRY (Don't Repeat Yourself) ‡πÅ‡∏•‡∏∞ SOLID ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÄ‡∏Ñ‡∏£‡πà‡∏á‡∏Ñ‡∏£‡∏±‡∏î
   - **React & PixiJS:** ‡πÉ‡∏ä‡πâ Hooks ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ State ‡πÅ‡∏•‡∏∞ Lifecycle (‡πÄ‡∏ä‡πà‡∏ô `useEffect`, `useMemo`) ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á Object ‡πÉ‡∏´‡∏°‡πà‡πÉ‡∏ô Game Loop (Ticker) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡∏†‡∏≤‡∏£‡∏∞‡∏Ç‡∏≠‡∏á Garbage Collector
   - ‡∏ä‡∏∑‡πà‡∏≠‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÅ‡∏•‡∏∞‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏ô‡πÄ‡∏ä‡∏¥‡∏á‡∏ò‡∏∏‡∏£‡∏Å‡∏¥‡∏à‡∏´‡∏£‡∏∑‡∏≠‡∏´‡∏ô‡πâ‡∏≤‡∏ó‡∏µ‡πà‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô (Descriptive names)
   - ‡∏ï‡πâ‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏∏ Type Definitions ‡∏´‡∏£‡∏∑‡∏≠ Annotations ‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏ï‡∏≤‡∏°‡∏°‡∏≤‡∏ï‡∏£‡∏ê‡∏≤‡∏ô TypeScript

# Security & Performance Guidelines
1. **No Hardcoded Secrets:** ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏™‡πà Password, API Key ‡∏´‡∏£‡∏∑‡∏≠ Credential ‡πÉ‡∏î‡πÜ ‡∏•‡∏á‡πÉ‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ Environment Variables ‡πÄ‡∏™‡∏°‡∏≠
2. **Error Handling:** ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£ Error ‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° (Graceful Degradation) ‡πÇ‡∏î‡∏¢‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î Assets ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£ Render
3. **Graphics Performance:** ‡∏£‡∏∞‡∏°‡∏±‡∏î‡∏£‡∏∞‡∏ß‡∏±‡∏á‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á "React Rerenders" ‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô‡∏ã‡∏∂‡πà‡∏á‡∏≠‡∏≤‡∏à‡∏Ç‡∏±‡∏î‡∏Ç‡∏ß‡∏≤‡∏á Game Loop ‡πÅ‡∏•‡∏∞‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ Texture Bundling / Object Pooling ‡πÉ‡∏ô PixiJS ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏Å‡∏©‡∏≤ Frame Rate ‡πÉ‡∏´‡πâ‡∏Ñ‡∏á‡∏ó‡∏µ‡πà
4. **Stability & Maintainability:** ‡πÄ‡∏ô‡πâ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡πÇ‡∏Ñ‡πâ‡∏î‡∏ó‡∏µ‡πà‡∏ó‡∏ô‡∏ó‡∏≤‡∏ô‡∏ï‡πà‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á (Robustness) ‡πÅ‡∏•‡∏∞‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ "Magic Numbers" ‡∏´‡∏£‡∏∑‡∏≠ Logic ‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô

# Output Format
- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡πÉ‡∏´‡πâ Refactor ‡πÉ‡∏´‡πâ‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏™‡πà‡∏ß‡∏ô "Before" ‡πÅ‡∏•‡∏∞ "After" ‡∏´‡∏£‡∏∑‡∏≠‡∏£‡∏∞‡∏ö‡∏∏‡∏´‡∏±‡∏ß‡∏Ç‡πâ‡∏≠‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÉ‡∏´‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô (‡πÄ‡∏ä‡πà‡∏ô [MODIFY], [NEW])
- ‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∞‡πÄ‡∏™‡∏ô‡∏≠‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç ‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢ "‡∏ó‡∏≥‡πÑ‡∏° (Why)" ‡∏ñ‡∏∂‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ô‡∏±‡πâ‡∏ô‡πÜ ‡πÄ‡∏™‡∏°‡∏≠ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏õ‡∏ï‡∏≤‡∏°‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≠‡∏á Senior Architect
- ‡∏™‡∏£‡∏∏‡∏õ‡∏á‡∏≤‡∏ô‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏î‡πâ‡∏ß‡∏¢‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏™‡∏ô‡∏≠‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ Commit (Commit Message) ‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢

</instruction>
